<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 基本的图算法 · Persuing</title><meta name="description" content="基本的图算法 - Persuing"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://Persuingsdu.github.io/atom.xml" title="Persuing"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">基本的图算法</h1><div class="post-info">Mar 22, 2018</div><div class="post-content"><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>算法伪代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">BFS(G)</div><div class="line"><span class="keyword">for</span> each vertex u ∈G.V-&#123;s&#125;</div><div class="line">   u.color=WHITE</div><div class="line">   u.d= ∞</div><div class="line">   u.π=NIL</div><div class="line">s.color=GRAY</div><div class="line">s.d=<span class="number">0</span></div><div class="line">s.π=NIL</div><div class="line">Q≠ф</div><div class="line">ENQUEUE(G,s)</div><div class="line"><span class="keyword">while</span> Q≠ф</div><div class="line">u=DEQUEUE(Q)</div><div class="line"><span class="keyword">for</span> each v∈G.Adj[u]</div><div class="line">   <span class="keyword">if</span>(v.color==WHITE)</div><div class="line">      v.color=GRAY</div><div class="line">      v.d=u.d+<span class="number">1</span></div><div class="line">      v.π=u</div><div class="line">      ENQUEUE(Q,v)</div><div class="line">u.color=BLACK</div></pre></td></tr></table></figure></p>
<p>时间复杂度为O(V+E)，广度优先搜索的运行时间是邻接链表大小的一个线性函数。<br>下面的伪代码输出从源结点s到结点v的一条最短路径上的所有结点：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">PRINT-PATH(G,s,v)</div><div class="line"><span class="keyword">if</span> v==s</div><div class="line">   print s</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> v.π==NIL</div><div class="line">   print <span class="string">"no path from"</span>s<span class="string">"to"</span>v<span class="string">"exits"</span></div><div class="line"><span class="keyword">else</span> PRINT-PATH(G,s,v.π)</div><div class="line">   print v</div></pre></td></tr></table></figure></p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>算法伪代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">DFS(G)</div><div class="line"><span class="keyword">for</span> each vertex u ∈ G.V</div><div class="line">   u.color=WHITE</div><div class="line">   u.π=NIL</div><div class="line">time=<span class="number">0</span></div><div class="line"><span class="keyword">for</span> each vertex u ∈ G.V</div><div class="line">   <span class="keyword">if</span> u.color==WHITE</div><div class="line">   DFS-VISIT(G,u)</div><div class="line"></div><div class="line">DFS-VISIT(G,u)</div><div class="line">time=time+<span class="number">1</span>         <span class="comment">//white vertex u has just been discovered</span></div><div class="line">u.d=time</div><div class="line">u.color=GRAY</div><div class="line"><span class="keyword">for</span> each vertex v ∈ G:Adj[u]</div><div class="line">   <span class="keyword">if</span> v.color==WHITE</div><div class="line">      v.π=u</div><div class="line">      DFS-VISIT(G,v)</div><div class="line">u.color=BLACK       <span class="comment">//blacken u;it is finished</span></div><div class="line">time=time+<span class="number">1</span></div><div class="line">u.f=time</div></pre></td></tr></table></figure></p>
<p>1.括号定理<br>2.白色路径定理：在有向或无向图G=(V,E)的深度优先森林中，结点v是结点u的后代当且仅当在发现结点u的时间u.d，存在一条从结点u到结点v的全部由白色结点所构成的路径。<br>边的分类：<br>1.树边 2.后向边(back) 3.前向边(forward) 4.横向边(cross)<br>当第一次探索边(u,v)时：<br>1.结点v为白色表明该边是一条树边。<br>2.结点v为灰色表明该边是一条后向边。<br>3.结点v为黑色表明该边是一条前向边或横向边。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">TOPOLOGICAL-SORT(G)</div><div class="line">call DFS(G) to compute finishing time v.f for each vertex v</div><div class="line">as each vertex is finished,insert it onto the front of a linked <span class="built_in">list</span></div><div class="line"><span class="keyword">return</span> the linked <span class="built_in">list</span> of vertices</div></pre></td></tr></table></figure></p>
<p><strong>引理：一个有向图G=(V,E)是无环的，当且仅当对其进行的深度优先搜索不产生后向边。</strong><br><strong>定理：拓扑排序算法生成的是有向无环图的拓扑排序。</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">证明：</div><div class="line">在有向无环图G=(V,E)上运行DFS来计算结点的完成时间。</div><div class="line">只需要证明，对于任意一对不同的结点u,v∈V,如果图G包含一条从结点u到结点v的边，则v.f &lt; u.f。</div><div class="line">考虑算法DFS(G)所探索的边(u,v)。当这条边被探索时，结点v不可能是灰色。</div><div class="line">若为灰色，则结点v是结点u的祖先，所以(u,v)是一条后向边，与之前的引理矛盾。</div><div class="line">所以结点v为白色或者黑色。若为白色，v是u的后代，则v.f &lt; u.f</div><div class="line">若为黑色，则对其全部的处理已经完成，v.f已经被设置。还需对u进行探索，最终一定有v.f &lt; u.f。</div></pre></td></tr></table></figure></p>
<p>拓扑排序的另外一种实现方式：<br>Another way to perform topological sorting on a directed acyclic graph G = (V, E) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time O(V + E). What happens to this algorithm if G has cycles?<br>General idea:<br>Run BFS or DFS to calculate in-degree of each vertex. O(V+E)<br>For each vertex that in-degree is 0, print it and update the in-degree of its neighbors accordingly, then there will be new in-degree=0 vertexes. Repeat this step until all vertex got printed. The entire process is also O(V+E)<br>If G has cycles, then after several iterations there will be no in-degree=0 vertexes. But original topological sorting algorithm is also only applied to directed acyclic graph.<br>判断一个有向图是否存在环，只要判断是否有<strong>backedge</strong>。<br><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="external">题目Course Schedule</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> res=<span class="literal">true</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_visited</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites, </span></span></div><div class="line"><span class="function"><span class="params">	<span class="keyword">int</span> s,<span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; adj)</span></span>&#123;</div><div class="line">	visited[s] = <span class="number">0</span>;</div><div class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</div><div class="line">	<span class="keyword">for</span> (i = adj[s].begin(); i != adj[s].end(); i++) &#123;</div><div class="line">		<span class="keyword">if</span> (visited[*i] == <span class="number">-1</span>) </div><div class="line">			dfs_visited(visited, prerequisites, *i, adj);</div><div class="line">		<span class="keyword">if</span> (visited[*i] == <span class="number">0</span>) &#123;</div><div class="line">			res = <span class="literal">false</span>;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	visited[s] = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(numCourses, <span class="number">-1</span>);</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</div><div class="line">		<span class="keyword">int</span> u = prerequisites[i].second;</div><div class="line">		<span class="keyword">int</span> v = prerequisites[i].first;</div><div class="line">		adj[u].push_back(v);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numCourses; j++)</div><div class="line">		dfs_visited(visited, prerequisites, j, adj);</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>创建GT的时间为O(V+E)<br>下面的线性时间算法使用两次深度优先搜索计算有向图G=(V,E)的强连通分量。<br>这两次深度优先搜索一次运行在G上，一次运行在转置图GT上。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">call DFS(G) to compute finishing times u.f for each vertex u</div><div class="line">compute GT</div><div class="line">call DFS(GT),but in the main loop of DFS,consider the vertices</div><div class="line">   in order of decreasing u.f(as computed in line 1)</div><div class="line">output the vertices of each tree in the depth-first forest formed</div><div class="line">   in line 3 as a separated connected component</div></pre></td></tr></table></figure></p>
<p>分量图的关键性质：分量图是一个有向无环图。<br>定义：d(U)=min(u∈U){u.d},f(U)=max(u∈U){u.f}<br>即d(U)和f(U)分别是结点集合U中所有结点里最早发现的时间和最晚的结束时间。</p>
<p><strong>引理：设C和C’为有向图G=(V,E)的两个不同的强连通分量。假如存在一条边(u,v)∈E，这里u∈C，v∈C’。则：f(C)&gt;f(C’)</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">证明:</div><div class="line"><span class="number">1.</span>第一种情况：若d(C) &lt; d(C')，设x为C中最早被发现的结点。则在x.d时，所有C和C'中的结点都是白色。</div><div class="line">在该时刻，图G中包含一条从结点x到C中每个结点的仅有包含白色结点的路径。因为(u,v)∈E，对于任意结点</div><div class="line">w∈C'，在时刻x.d时，G中存在一条只包含白色结点的路径：x~u-v~w，所以根据白色路径定理，连通分量C'中</div><div class="line">的所有结点都成为深度优先搜索树中x的的后代，则根据<span class="number">22.8</span>，结点x的完成时间比其它所有的后代都晚，</div><div class="line">则x.f=f(C)&gt;f(C')。</div><div class="line"><span class="number">2.</span>第二种情况：如果d(C) &gt; d(C')，设y为C'中最早被发现的结点。则在y.d时，所有C'中的结点都是白色。</div><div class="line">且图C'包含一条从结点y到C'中每个结点的仅包含白色结点的路径。根据白色路径定理，C'中的所有结点都将成为</div><div class="line">深度优先搜索树中y的后代，有f(C')=y.f。在时刻y.d，所有C中的结点都为白色，有(u,v)，所以不可能存在</div><div class="line">从C'到C的路径，所以C中的结点不可能从y到达。在时刻y.f，所有C中的结点都为白色。因此对任意结点w∈C来说</div><div class="line">有w.f&gt;y.f，所以f(C)&gt;f(C')。</div></pre></td></tr></table></figure></p>
<p><strong>推论：设C和C’为有向图G=(V,E)两个不同的强连通分量，加入存在一条边(u,v)属于ET，这里u∈C，v∈C’则有f(C)&lt; f(C’)</strong><br>第二次深度优先搜索运行在GT上，我们从完成时间最晚的强连通分量C开始。搜索算法从C中的某个结点x开始，访问C<br>中的所有结点。根据该推论，GT中不可能包含从C到其它任何强连通分量的边。<br><strong>定理：算法STRONGLY-CONNECTED-COMPONENTS能够正确地计算出有向图G的强连通分量</strong><br>利用归纳法证明。<br>给定有向图G=(V,E)，如果对所有结点对u，v∈V，我们都有u~v或者v~u，则G是半连通的。给出一个有效的算法来判断图G是否是半连通的。<br>先求出所有的强连通分量，然后利用拓扑排序，若存在链条式的结构则说明该图是半连通的。<br><strong>3/23更新</strong></p>
<h2 id="衔接点、桥和双连通分量"><a href="#衔接点、桥和双连通分量" class="headerlink" title="衔接点、桥和双连通分量"></a>衔接点、桥和双连通分量</h2><p><a href="https://en.wikipedia.org/wiki/Biconnected_component" target="_blank" rel="external">Biconnected component</a><br><a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/articulation-points-and-bridges/tutorial/" target="_blank" rel="external">参考一</a><br><a href="https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/" target="_blank" rel="external">参考二</a><br>求Articulation Points算法伪代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">GetArticulationPoints(i, d)</div><div class="line">    visited[i] = <span class="literal">true</span></div><div class="line">    dis[i] = d</div><div class="line">    low[i] = d  <span class="comment">//定义u.low=MIN(u.d,w.d:(v,w)是结点u的某个后代v的一个backedge)</span></div><div class="line">    childCount = <span class="number">0</span></div><div class="line">    isArticulation = <span class="literal">false</span></div><div class="line">    <span class="keyword">for</span> each ni in adj[i]</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[ni]<span class="comment">//没有访问过</span></div><div class="line">            parent[ni] = i  </div><div class="line">            GetArticulationPoints(ni, d + <span class="number">1</span>)</div><div class="line">            childCount = childCount + <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> low[ni] &gt;= dis[i] </div><div class="line">                isArticulation = <span class="literal">true</span></div><div class="line">            low[i] = Min(low[i], low[ni]) </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ni &lt;&gt; parent[i] <span class="comment">//访问过</span></div><div class="line">            low[i] = Min(low[i], dis[ni])   <span class="comment">//较小者 ni为i能到达的结点，也就是backedge</span></div><div class="line">    <span class="keyword">if</span> (parent[i] &lt;&gt; null <span class="keyword">and</span> isArticulation) <span class="keyword">or</span> (parent[i] == null <span class="keyword">and</span> childCount &gt; <span class="number">1</span>)</div><div class="line">        Output i as articulation point</div></pre></td></tr></table></figure></p>
<p>Reason：<br><img src="/img/ac.png" alt="解释"><br><strong><em>Biconnected graph</em></strong>: A graph with no articulation point called biconnected. In other words, a graph is biconnected if and only if any vertex is deleted, the graph remains connected.<br>判断一个图是否是<strong>Biconnected</strong>只需要判断图中是否存在<strong>articulation point</strong></p>
<p><strong><em>Biconnected component</em></strong>: A biconnected component of a graph is a maximal biconnected subgraph- a biconnected subgraph that is not properly contained in a larger biconnected subgraph.<br><a href="https://www.geeksforgeeks.org/biconnected-components/" target="_blank" rel="external">参考一</a><br><a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/biconnected-components/tutorial/" target="_blank" rel="external">参考二</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/11/B计算机图形学/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://Persuingsdu.github.io">Persuing</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>