<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 单源最短路径 · Persuing</title><meta name="description" content="单源最短路径 - Persuing"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://Persuingsdu.github.io/atom.xml" title="Persuing"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">单源最短路径</h1><div class="post-info">Mar 31, 2018</div><div class="post-content"><h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="external">Bellman-Ford算法</a><br>解决的是一般情况下的单源最短路径问题，在这里，边的权重可以为负值。<br>算法返回一个布尔值，以表明是否存在一个从源结点可以到达的权重为负值的环路。如果存在这样一个环路，则算法将返回False，以表明不存在解决方案。反之，算法将给出最短路径和它们的权重。<br><img src="/img/bf.png" alt="bf"><br><strong>Bellman-Ford算法伪代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">BELLMAN-FORD(G,w,s)</div><div class="line"> INITIALIZE-SIGLE-SOURCE(G,s)</div><div class="line"> <span class="keyword">for</span> i=<span class="number">1</span> to|G.V|<span class="number">-1</span>      <span class="comment">//重复对每一边进行松弛操作</span></div><div class="line">   <span class="keyword">for</span> each egde(u,v)∈G.E</div><div class="line">     RELAX(u,v,w)</div><div class="line"> <span class="keyword">for</span> each edge(u,v)∈G.E <span class="comment">//检查负权环</span></div><div class="line">   <span class="keyword">if</span> v.d&gt;u.d+w(u,v)</div><div class="line">     <span class="keyword">return</span> FALSE</div><div class="line"> <span class="keyword">return</span> TRUE</div></pre></td></tr></table></figure></p>
<p><strong>松弛</strong>操作实际上是对相邻结点的访问，第n次松弛操作保证了所有深度为n的路径最短。由于图的最短路径最长不会经过超过V-1条边，所以可知该算法所得为最短路径。<br><strong>循环的提前跳出：</strong>若没有边进行松弛操作，则可以直接跳出。<br><strong>算法复杂度：</strong>O(VE)<br><strong>代码实现：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//只放核心代码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">relase</span><span class="params">(Edge E)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (dis[E.src]!=INT_MAX&amp;&amp;dis[E.dest] &gt; dis[E.src] + E.weight) &#123;</div><div class="line">		dis[E.dest] = dis[E.src] + E.weight;</div><div class="line">		parent[E.dest] = E.src;</div><div class="line">		t = <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">	dis = <span class="keyword">new</span> <span class="keyword">int</span>[graph-&gt;V];</div><div class="line">	parent = <span class="keyword">new</span> <span class="keyword">int</span>[graph-&gt;V];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</div><div class="line">		dis[i] = INT_MAX;</div><div class="line">		parent[i] = <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	dis[s] = <span class="number">0</span>;</div><div class="line">	parent[s] = s;</div><div class="line">&#125;</div><div class="line"><span class="comment">//寻找路径</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (s == t) </div><div class="line">		<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	   <span class="keyword">if</span> (t == <span class="number">-1</span>) </div><div class="line">		  <span class="built_in">cout</span> &lt;&lt; <span class="string">"No path"</span>;</div><div class="line">	   <span class="keyword">else</span> &#123;</div><div class="line">		   findPath(s, parent[t]);</div><div class="line">		   <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span>;</div><div class="line">	   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman_ford</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">	initialize(graph, s);</div><div class="line">	<span class="keyword">int</span> E = graph-&gt;edges.size();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V - <span class="number">1</span>; i++) &#123; <span class="comment">//n-1次对每条边松弛</span></div><div class="line">		t = <span class="literal">false</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</div><div class="line">			relase(graph-&gt;edges[j]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!t)</div><div class="line">			<span class="keyword">break</span>;<span class="comment">//未有松弛，及时终止</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123; <span class="comment">//判断是否有环</span></div><div class="line">		Edge E = graph-&gt;edges[j];</div><div class="line">		<span class="keyword">if</span> (dis[E.dest] &gt; dis[E.src] + E.weight)</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank" rel="external">Dijkstra算法</a>解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为<strong>非负值</strong>。<br><img src="/img/dj.png" alt="dj"><br><strong>伪代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">DIJKSTRA(G,w,s)</div><div class="line"> INITIALIZE-SINGAL-SOURCE(G,s)</div><div class="line"> S=ф</div><div class="line"> Q=G.V</div><div class="line"> <span class="keyword">while</span> Q≠ф</div><div class="line">    u=EXTRACT-MIN(Q)</div><div class="line">    S=S∪&#123;u&#125;</div><div class="line">    <span class="keyword">for</span> each vertex v∈G.Adj[u]</div><div class="line">      RELAX(u,v,w)</div></pre></td></tr></table></figure></p>
<p><strong>代码实现：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">	init(graph, s); <span class="comment">//初始化</span></div><div class="line">	Q.push(make_pair(<span class="number">0</span>, s));</div><div class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</div><div class="line">		P x = Q.top(); Q.pop();</div><div class="line">		<span class="keyword">int</span> u = x.second;</div><div class="line">		<span class="keyword">if</span> (done[u]) <span class="keyword">continue</span>;</div><div class="line">		done[u] = <span class="number">1</span>;    <span class="comment">//该点已经加入S</span></div><div class="line">		<span class="built_in">list</span>&lt;Edge&gt;::iterator iter;</div><div class="line">		<span class="keyword">for</span> (iter = graph-&gt;adj[u].begin();</div><div class="line">			iter != graph-&gt;adj[u].end(); iter++) &#123;</div><div class="line">			<span class="keyword">int</span> v = iter-&gt;dest;</div><div class="line">			<span class="keyword">if</span> (dis[v] &gt; dis[u] + iter-&gt;weight) &#123;</div><div class="line">				dis[v] = dis[u] + iter-&gt;weight;</div><div class="line">				Q.push(make_pair(dis[v], v));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为Dijkstra算法总是选择V-S中“最轻”或“最近”的结点来加入到集合S中，该算法使用的是贪心策略。这里的关键是证明这样的一个事实：该算法每次选择结点u来加入到集合S时，有u.d=min{w(p):s-p-u}。<br><strong>相关问题：</strong><br><a href="https://leetcode.com/problems/network-delay-time/description/" target="_blank" rel="external">1.Network Delay Time</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/27/最小生成树/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://Persuingsdu.github.io">Persuing</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>