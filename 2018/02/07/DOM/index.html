<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> DOM · Persuing</title><meta name="description" content="DOM - Persuing"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://Persuingsdu.github.io/atom.xml" title="Persuing"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">DOM</h1><div class="post-info">Feb 7, 2018</div><div class="post-content"><p><code>DOM</code>可以将任何<code>HTML</code>或<code>XML</code>文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外与其它节点存在某种关系，节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的HTML为例子:<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<html>元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其它所有元素都包含在这个文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是<html>元素。<br>将上述HTML文档表示为一个层次结构<br><img src="/img/文档层次结构.png" alt="文档层次结构"></html></html></p>
<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p><strong>节点关系</strong><br>每个节点都有一个<code>childNodes</code>属性，其中保存着一个<code>NodeList</code>对象，可以用<code>[]</code>来访问NodeList的值，而且有<code>length</code>属性，并且它是基于DOM结构动态执行查询的结果，而不是在访问某一瞬间拍摄下来的快照。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> firstChild=someNode.childNodes[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> secondChild=someNode.childNodes.item(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> count=someNode.childNodes.length;</div></pre></td></tr></table></figure></p>
<p>将NodeList对象转换为数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> array=<span class="literal">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        array=<span class="built_in">Array</span>.prototype.slice.call(nodes,<span class="number">0</span>);<span class="comment">//针对非ie浏览器</span></div><div class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</div><div class="line">        array=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=nodes.length;i&lt;len;i++)&#123;</div><div class="line">            array.push(nodes[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个节点都有一个<code>parentNode</code>属性，该属性指向文档树中的父节点。包含在childNodes列表中所有节点都具有相同的父节点。此外，包含在其中的每个节点相互之间都是同胞节点。<br>使用<code>previousSibling</code>和<code>nextSibling</code>属性，可以访问同一列表中的其他节点。并且第一个节点的previousSibling和最后一个节点的nextSibling为null。<br>父节点的<code>firstChild</code>和<code>lastChild</code>属性分别指向childNodes列表中的第一个节点和最后一个节点。<br><code>hasChildNodes()</code>方法在节点包含一个或多个节点的情况下返回true。<br>所有节点都有的一个属性是<code>ownerDocument</code>，该属性指向表示整个文档的文档节点。<br><img src="/img/节点关系.png" alt="节点关系"><br><strong>操作节点</strong><br>因为关系指针都是只读的，所以DOM提供了一些操作节点的方法。<br><code>appendChild()</code>，用于向childNodes列表的末尾添加一个节点，如果该节点已经是文档的一部分，就将该节点从原来位置转移到新位置。<br><code>insertBefor()</code>放到childNodes列表中某个特定的位置上，接受两个参数：要插入的节点和作为参照的节点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//插入后成为最后一个节点</span></div><div class="line"><span class="keyword">var</span> returnNode=someNode.insertBefore(newNode,<span class="literal">null</span>);</div><div class="line">alert(returnNode==someNode.lastChild);<span class="comment">//true;</span></div><div class="line"><span class="comment">//插入后成为第一个节点</span></div><div class="line">returnNode=someNode.insertBefore(newNode,someNode.firstChild);</div><div class="line">alert(returnNode==newNode);<span class="comment">//true</span></div><div class="line">alert(newNode=someNode.firstChild);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><code>replaceChild()</code>接受两个参数：要插入的节点和要替换的节点。<br>要替换的节点将由这个方法返回并从文档中移除，同时由要插入的节点占据其位置。<br>被替换的节点仍然还在文档中，但它在文档中已经没有自己的位置<br><code>removeChild()</code>也是类似。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//替换第一个节点</span></div><div class="line"><span class="keyword">var</span> returnNode=someNode.replaceChild(newNode,someNode.firstChild);</div><div class="line"><span class="comment">//移除第一个节点</span></div><div class="line"><span class="keyword">var</span> formerFirstChild=someNode.removeChild(someNode.firstChild);</div></pre></td></tr></table></figure></p>
<p><code>cloneNode()</code>接受一个布尔值，表示是否执行深复制。</p>
<h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>JavaScript通过Document类型表示文档。在浏览器中，<code>document</code>对象是<code>HTMLDocument</code>（继承自Document类型）的一个<code>实例</code>，表示整个HTML页面。而且Document对象是window对象的一个属性，因此可以将其作为全局对象访问。<br>Document类型可以表示HTML页面或者其它基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以获得与页面有关的信息，而且还能操作页面的外观及其底层结构。<br>1.<strong>文档的子节点</strong></p>
<ul>
<li><code>documentElement</code>，该属性始终指向HTML页面中的<html>元素<br><code>var html=document.documentElement;</code></html></li>
<li><code>body</code>属性直接指向body元素<br><code>var body=document.body;</code></li>
</ul>
<p>2.<strong>文档信息</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//取得文档标题</span></div><div class="line"><span class="keyword">var</span> oringinalTitle=<span class="built_in">document</span>.title;</div><div class="line"><span class="comment">//设置文档</span></div><div class="line"><span class="built_in">document</span>.title=<span class="string">"New Page title"</span>;</div><div class="line"><span class="comment">//取得完整的URL</span></div><div class="line"><span class="keyword">var</span> url=<span class="built_in">document</span>.URL;</div><div class="line"><span class="comment">//取得域名</span></div><div class="line"><span class="keyword">var</span> domain=<span class="built_in">document</span>.domain;</div><div class="line"><span class="comment">//取得来源页面的URL</span></div><div class="line"><span class="keyword">var</span> referrer=<span class="built_in">document</span>.referrer;</div></pre></td></tr></table></figure></p>
<p>3.<strong>查找元素</strong><br>1.<code>getElementById()</code><br>如果页面中多个元素的ID值相同，只返回文档中第一次出现的元素<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;div id=<span class="string">"myDiv"</span>&gt;Some text&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">var div=document.getElementById("myDiv");/</span><span class="regexp">/获得&lt;div&gt;元素的引用</span></div></pre></td></tr></table></figure></p>
<p>由于IE7特性，最好不要让表单字段的name值与其它元素的id值相同。<br>2.<code>getElementByTagName()</code><br>在HTML文档中，这个方法会返回一个<code>HTMLCollection</code>对象，使用方括号或者item()方法来访问该对象中的项，通过length属性获得该对象中元素的个数,使用namedItem()通过元素的name特性取得集合中的项。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;img src=<span class="string">"myimage.gif"</span> name=<span class="string">"myImage"</span>&gt;</div><div class="line"><span class="keyword">var</span> images=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</div><div class="line">alert(images.length);<span class="comment">//输出图像的数量</span></div><div class="line">alert(images[<span class="number">0</span>].src);<span class="comment">//输出第一个图像元素的src特性</span></div><div class="line">alert(images.item(<span class="number">0</span>).src);</div><div class="line"><span class="comment">//通过如下方式从images变量中获得&lt;img&gt;元素</span></div><div class="line"><span class="keyword">var</span> myImg=images.namedItem(<span class="string">"myImage"</span>);</div><div class="line"><span class="keyword">var</span> myImg=images[<span class="string">"myImage"</span>]</div></pre></td></tr></table></figure></p>
<p>4.<strong>特殊集合</strong><br><code>document.images document.links</code><br><code>document.anchors document.forms</code><br>5.<strong>文档写入</strong><br><code>write()</code>和<code>writel()</code>(字符串末尾添加一个换行\n符号)方法都会接受一个字符串参数，即要写入到输出流中的文本。<br>并且在文档加载结束后再调用document.write(),那么输出的内容将会重写整个页面。<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The current data and time is:</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;strong&gt;"</span>+(<span class="keyword">new</span> <span class="built_in">Date</span>()).toString()+<span class="string">"&lt;/strong&gt;"</span>)</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果如下:<br><img src="/img/time.png" alt="time"></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/06/正则表达式/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://Persuingsdu.github.io">Persuing</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>