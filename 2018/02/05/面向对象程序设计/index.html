<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 面向对象程序设计 · Persuing</title><meta name="description" content="面向对象程序设计 - Persuing"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://Persuingsdu.github.io/atom.xml" title="Persuing"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">面向对象程序设计</h1><div class="post-info">Feb 5, 2018</div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>ECMA-262把对象定义为“<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>”，严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都一个名字，而每个名字都映射到一个值。<br>1.常用<code>对象字面量</code>创建这种使用Object来创建自定义对象的方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    age:<span class="number">29</span>,</div><div class="line">    job:<span class="string">"Software Engineer"</span></div><div class="line">    sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>属性类型</strong><br>ECMAScript中有两种属性：<strong>数据属性</strong>和<strong>访问器属性</strong><br>1.数据属性<br><code>[[Configurable]]</code>,<code>[[Enumerble]]</code>,<code>[[Writable]]</code>,<code>[[Value]]</code><br>直接在对象上定义的属性，它们的前三种特性都被设置为<code>true</code>，而<code>[[Value]]</code>特性被设置为指定的值。<br>使用<code>Obejct.defineProperty()</code>修改属性默认的特性，接受三个参数属性所在的对象、属性的名字和一个描述符对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    writable:<span class="literal">false</span>,</div><div class="line">    value:<span class="string">"Nicholas"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>一旦把<code>configurable</code>设置为false之后就会有限制了。<br>在调用<code>Obejct.defineProperty()</code>方法创建一个新的属性时，如果不指定，其三种特定都被设置为false。<br>2.访问器属性<br><code>[[Configurable]]</code>,<code>[[Enumerable]]</code>,<code>[[Get]]</code>,<code>[[Set]]</code><br>访问器属性不能够直接定义，必须使用<code>Obejct.defineProperty()</code>来定义。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> book=&#123;</div><div class="line">    _year:<span class="number">2004</span>,</div><div class="line">    edition:<span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</div><div class="line">            <span class="keyword">this</span>._year=newValue;</div><div class="line">            <span class="keyword">this</span>.edition+=newValue<span class="number">-2004</span>;<span class="comment">//设置一个属性的值会导致其它属性的值发生变化</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line"><span class="built_in">console</span>.log(book.edition);<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>定义多个属性的值，使用<code>Object.defineProperties</code>，接受两个对象参数：一个对象是要添加或者修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。<br>读取属性的特性<code>Object.getOwnPropertyDescriptor();</code>,接受两个参数：属性所在的对象和要读取其描述符的属性名称。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><strong>构造函数模式</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div></pre></td></tr></table></figure></p>
<p>存在的问题：每个方法在每个实例上都要重新创建一遍。<br><strong>原型模式</strong><br>我们创建的每个函数都一个<code>prototype(原型)</code>属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>每当代码读取某个对象的某个属性时，都会执行一次搜索，首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值。如果没有这个值，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。当为对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。<br>使用<code>delete</code>操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。<br>使用<code>hasOwnProperty()</code>方法可以检测一个属性是否存在于实例中，还是存在于原型中。<br><strong>更简单的原型语法</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    name:"Nicholas",</div><div class="line">    age:29,</div><div class="line">    job:"Software Engineer",</div><div class="line">    sayName:function()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>原型的动态性</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> friend=<span class="keyword">new</span> Person();</div><div class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>)</div><div class="line">&#125;</div><div class="line">friend.sayHi();<span class="comment">//Hi</span></div></pre></td></tr></table></figure></p>
<p>原型对象存在数据共享的问题。<br><strong>组合使用构造函数和原型模式</strong><br>避免构造函数和原型对象产生的问题。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.friends=[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    sayName:function()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"Grey"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div><div class="line">person1.friends.push(<span class="string">"Van"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.friends);<span class="comment">//"Shelby,Court,Van"</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//"Shelby,Court"</span></div></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。<br><strong>调用构造函数时会为实例添加一个指向最初原型的<code>[[Prototype]]</code>指针</strong><br>1.实现原型链的基本模式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.propery=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propery;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty=<span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了SuperType</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>关系图示<br><img src="/img/原型链继承.png" alt="图示"><br>原型链存在的问题：1.包含引用类型值的原型。2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。<br><strong>使用构造函数</strong><br>传递参数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//继承了SuperType,同时还传递了参数</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,<span class="string">"Nicholas"</span>);</div><div class="line">    <span class="keyword">this</span>.age=<span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.name);</div><div class="line"><span class="built_in">console</span>.log(instance.age);</div></pre></td></tr></table></figure></p>
<p><strong>组合继承</strong><br>组合继承（combination inheritance）：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="comment">//继承属性</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line">SubType.constructor=SubType;</div><div class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance1=<span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></div><div class="line">instance1.sayName();<span class="comment">//Nichaolas</span></div><div class="line">instance1.sayAge();<span class="comment">//29</span></div><div class="line"><span class="keyword">var</span> instance2=<span class="keyword">new</span> SubType(<span class="string">"Grey"</span>,<span class="number">27</span>);</div><div class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green"</span></div><div class="line">instance2.sayName();<span class="comment">//Grey</span></div><div class="line">instance2.sayAge();<span class="comment">//27</span></div></pre></td></tr></table></figure></p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，称为JavaScript中最常用的继承模式。<br><strong>原型式继承</strong><br>要求必须有一个对象作为另一个对象的基础。<br>ECMAScript5通过新增<code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义的额外的属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    friends:[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>,<span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson=<span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name=<span class="string">"Grey"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="keyword">var</span> yetAnotherPerson=<span class="built_in">Object</span>.create(person);</div><div class="line">yetAnotherPerson.name=<span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure></p>
<p><strong>寄生式继承</strong><br>寄生式（parasitic）即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> clone=<span class="built_in">Object</span>(original);</div><div class="line">    clone.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    friends:[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>,<span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson=createAnother(person);</div><div class="line">anotherPerson.sayHi();<span class="comment">//Hi</span></div></pre></td></tr></table></figure></p>
<p>包含引用类型的值始终会共享相应的值。<br><strong>寄生组合式继承</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype=<span class="built_in">Object</span>(superType.prototype);</div><div class="line">    prototype.constructor=subType;</div><div class="line">    subType.prototype=prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/06/正则表达式/" class="prev">PREV</a><a href="/2018/01/31/引用类型/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://Persuingsdu.github.io">Persuing</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>