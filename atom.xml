<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Persuing</title>
  
  <subtitle>study &amp; life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Persuingsdu.github.io/"/>
  <updated>2018-06-11T01:27:41.071Z</updated>
  <id>http://Persuingsdu.github.io/</id>
  
  <author>
    <name>Persuing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>edu邮箱</title>
    <link href="http://Persuingsdu.github.io/2018/06/09/edu%E9%82%AE%E7%AE%B1/"/>
    <id>http://Persuingsdu.github.io/2018/06/09/edu邮箱/</id>
    <published>2018-06-09T03:05:35.000Z</published>
    <updated>2018-06-11T01:27:41.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>用edu邮箱申请了JetBrains的<a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F" target="_blank" rel="external">学生授权</a><br><img src="/img/uuu.jpg" alt="edu"><br>申请OneDrive 1024GB 使用空间，速度很快<br><img src="/img/one.png" alt="one"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;p&gt;用edu邮箱申请了JetBrains的&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单源最短路径</title>
    <link href="http://Persuingsdu.github.io/2018/03/31/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://Persuingsdu.github.io/2018/03/31/单源最短路径/</id>
    <published>2018-03-31T04:25:05.000Z</published>
    <updated>2018-03-31T08:22:37.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="external">Bellman-Ford算法</a><br>解决的是一般情况下的单源最短路径问题，在这里，边的权重可以为负值。<br>算法返回一个布尔值，以表明是否存在一个从源结点可以到达的权重为负值的环路。如果存在这样一个环路，则算法将返回False，以表明不存在解决方案。反之，算法将给出最短路径和它们的权重。<br><img src="/img/bf.png" alt="bf"><br><strong>Bellman-Ford算法伪代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">BELLMAN-FORD(G,w,s)</div><div class="line"> INITIALIZE-SIGLE-SOURCE(G,s)</div><div class="line"> <span class="keyword">for</span> i=<span class="number">1</span> to|G.V|<span class="number">-1</span>      <span class="comment">//重复对每一边进行松弛操作</span></div><div class="line">   <span class="keyword">for</span> each egde(u,v)∈G.E</div><div class="line">     RELAX(u,v,w)</div><div class="line"> <span class="keyword">for</span> each edge(u,v)∈G.E <span class="comment">//检查负权环</span></div><div class="line">   <span class="keyword">if</span> v.d&gt;u.d+w(u,v)</div><div class="line">     <span class="keyword">return</span> FALSE</div><div class="line"> <span class="keyword">return</span> TRUE</div></pre></td></tr></table></figure></p><p><strong>松弛</strong>操作实际上是对相邻结点的访问，第n次松弛操作保证了所有深度为n的路径最短。由于图的最短路径最长不会经过超过V-1条边，所以可知该算法所得为最短路径。<br><strong>循环的提前跳出：</strong>若没有边进行松弛操作，则可以直接跳出。<br><strong>算法复杂度：</strong>O(VE)<br><strong>代码实现：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//只放核心代码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">relase</span><span class="params">(Edge E)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (dis[E.src]!=INT_MAX&amp;&amp;dis[E.dest] &gt; dis[E.src] + E.weight) &#123;</div><div class="line">dis[E.dest] = dis[E.src] + E.weight;</div><div class="line">parent[E.dest] = E.src;</div><div class="line">t = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">dis = <span class="keyword">new</span> <span class="keyword">int</span>[graph-&gt;V];</div><div class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[graph-&gt;V];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</div><div class="line">dis[i] = INT_MAX;</div><div class="line">parent[i] = <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">dis[s] = <span class="number">0</span>;</div><div class="line">parent[s] = s;</div><div class="line">&#125;</div><div class="line"><span class="comment">//寻找路径</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (s == t) </div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="keyword">if</span> (t == <span class="number">-1</span>) </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"No path"</span>;</div><div class="line">   <span class="keyword">else</span> &#123;</div><div class="line">   findPath(s, parent[t]);</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman_ford</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">initialize(graph, s);</div><div class="line"><span class="keyword">int</span> E = graph-&gt;edges.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V - <span class="number">1</span>; i++) &#123; <span class="comment">//n-1次对每条边松弛</span></div><div class="line">t = <span class="literal">false</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</div><div class="line">relase(graph-&gt;edges[j]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!t)</div><div class="line"><span class="keyword">break</span>;<span class="comment">//未有松弛，及时终止</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123; <span class="comment">//判断是否有环</span></div><div class="line">Edge E = graph-&gt;edges[j];</div><div class="line"><span class="keyword">if</span> (dis[E.dest] &gt; dis[E.src] + E.weight)</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank" rel="external">Dijkstra算法</a>解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为<strong>非负值</strong>。<br><img src="/img/dj.png" alt="dj"><br><strong>伪代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">DIJKSTRA(G,w,s)</div><div class="line"> INITIALIZE-SINGAL-SOURCE(G,s)</div><div class="line"> S=ф</div><div class="line"> Q=G.V</div><div class="line"> <span class="keyword">while</span> Q≠ф</div><div class="line">    u=EXTRACT-MIN(Q)</div><div class="line">    S=S∪&#123;u&#125;</div><div class="line">    <span class="keyword">for</span> each vertex v∈G.Adj[u]</div><div class="line">      RELAX(u,v,w)</div></pre></td></tr></table></figure></p><p><strong>代码实现：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">init(graph, s); <span class="comment">//初始化</span></div><div class="line">Q.push(make_pair(<span class="number">0</span>, s));</div><div class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</div><div class="line">P x = Q.top(); Q.pop();</div><div class="line"><span class="keyword">int</span> u = x.second;</div><div class="line"><span class="keyword">if</span> (done[u]) <span class="keyword">continue</span>;</div><div class="line">done[u] = <span class="number">1</span>;    <span class="comment">//该点已经加入S</span></div><div class="line"><span class="built_in">list</span>&lt;Edge&gt;::iterator iter;</div><div class="line"><span class="keyword">for</span> (iter = graph-&gt;adj[u].begin();</div><div class="line">iter != graph-&gt;adj[u].end(); iter++) &#123;</div><div class="line"><span class="keyword">int</span> v = iter-&gt;dest;</div><div class="line"><span class="keyword">if</span> (dis[v] &gt; dis[u] + iter-&gt;weight) &#123;</div><div class="line">dis[v] = dis[u] + iter-&gt;weight;</div><div class="line">Q.push(make_pair(dis[v], v));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为Dijkstra算法总是选择V-S中“最轻”或“最近”的结点来加入到集合S中，该算法使用的是贪心策略。这里的关键是证明这样的一个事实：该算法每次选择结点u来加入到集合S时，有u.d=min{w(p):s-p-u}。<br><strong>相关问题：</strong><br><a href="https://leetcode.com/problems/network-delay-time/description/" target="_blank" rel="external">1.Network Delay Time</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;Bellman-Ford算法&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Persuingsdu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://Persuingsdu.github.io/2018/03/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://Persuingsdu.github.io/2018/03/27/最小生成树/</id>
    <published>2018-03-27T10:14:14.000Z</published>
    <updated>2018-03-29T14:31:13.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p><strong>Kruscal算法伪代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MST-KRUSCAL(G,w)</div><div class="line">A=Φ</div><div class="line"><span class="keyword">for</span> each vertex v∈G.V</div><div class="line">    MAKE-SET(v)</div><div class="line">sort the edges of G.E into nondecreasing order by weight w</div><div class="line"><span class="keyword">for</span> each edge(u,v)∈G.E,taken in nondereasing order by weight</div><div class="line">   <span class="keyword">if</span> FIND-SET(u)≠FIND-SET(v)</div><div class="line">      A=A∪&#123;(u,v)&#125;</div><div class="line">      UNION(u,v)</div><div class="line"><span class="keyword">return</span> A</div></pre></td></tr></table></figure></p><p><img src="/img/kruscal.gif" alt="Kruscal"><br><strong>代码实现：</strong><br>使用<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">并查集</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></div><div class="line"><span class="keyword">int</span> src, dest, weight;</div><div class="line">Edge(<span class="keyword">int</span> src, <span class="keyword">int</span> dest, <span class="keyword">int</span> weight) &#123;</div><div class="line"><span class="keyword">this</span>-&gt;src = src;</div><div class="line"><span class="keyword">this</span>-&gt;dest = dest;</div><div class="line"><span class="keyword">this</span>-&gt;weight = weight;</div><div class="line">&#125;</div><div class="line">Edge()&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></div><div class="line"><span class="keyword">int</span> V;</div><div class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</div><div class="line">&#125;;</div><div class="line"><span class="function">Graph* <span class="title">creatGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</div><div class="line">Graph* graph = <span class="keyword">new</span> Graph;</div><div class="line">graph-&gt;V = V;</div><div class="line"><span class="keyword">return</span> graph;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subset</span> &#123;</span></div><div class="line"><span class="keyword">int</span> parent, rank;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(subset subsets[], <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (subsets[i].parent != i)</div><div class="line">subsets[i].parent = find(subsets, subsets[i].parent);</div><div class="line"><span class="keyword">return</span> subsets[i].parent;</div><div class="line">&#125;</div><div class="line"><span class="comment">//按rank合并</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(subset subsets[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> xRoot = find(subsets, x);</div><div class="line"><span class="keyword">int</span> yRoot = find(subsets, y);</div><div class="line"><span class="keyword">if</span> (subsets[xRoot].rank &lt; subsets[yRoot].rank)</div><div class="line">subsets[xRoot].parent = yRoot;</div><div class="line"><span class="keyword">else</span> </div><div class="line"><span class="keyword">if</span> (subsets[xRoot].rank &gt; subsets[yRoot].rank)</div><div class="line">    subsets[yRoot].parent = xRoot;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">    subsets[yRoot].parent = xRoot;</div><div class="line">    subsets[xRoot].rank++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Edge&amp; a, Edge&amp; b)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> a.weight &lt; b.weight;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Graph* graph, <span class="keyword">int</span> src, <span class="keyword">int</span> dest, <span class="keyword">int</span> weight)</span> </span>&#123;</div><div class="line">graph-&gt;edges.push_back(Edge(src, dest, weight));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruscal</span><span class="params">(Graph* graph)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> V = graph-&gt;V;</div><div class="line">Edge* res = <span class="keyword">new</span> Edge[V];<span class="comment">//最小生成树的边</span></div><div class="line"><span class="keyword">int</span> e = <span class="number">0</span>;<span class="comment">//边</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">sort(graph-&gt;edges.begin(), graph-&gt;edges.end(), compare);<span class="comment">//按照权值进行排序</span></div><div class="line">subset* subsets = <span class="keyword">new</span> subset[V];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</div><div class="line">subsets[v].parent = v;</div><div class="line">subsets[v].rank = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (e &lt; V - <span class="number">1</span>) &#123;</div><div class="line">Edge next_Edge = graph-&gt;edges[i++];</div><div class="line"><span class="keyword">int</span> x = find(subsets, next_Edge.src);</div><div class="line"><span class="keyword">int</span> y = find(subsets, next_Edge.dest);</div><div class="line"><span class="keyword">if</span> (x != y) &#123;</div><div class="line">res[e++] = next_Edge;</div><div class="line">Union(subsets, x, y);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Following are the edges in the constructed MST\n"</span>;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e; i++)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; res[i].src &lt;&lt; <span class="string">"----"</span> &lt;&lt; res[i].dest &lt;&lt; <span class="string">" == "</span> &lt;&lt; res[i].weight &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">/* </span></div><div class="line"><span class="comment">    10</span></div><div class="line"><span class="comment">0--------1</span></div><div class="line"><span class="comment">|  \     |</span></div><div class="line"><span class="comment">   6|   5\   |15</span></div><div class="line"><span class="comment">|      \ |</span></div><div class="line"><span class="comment">2--------3</span></div><div class="line"><span class="comment">    4       */</span></div><div class="line">Graph* graph = creatGraph(<span class="number">4</span>);</div><div class="line">addEdge(graph, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</div><div class="line">addEdge(graph, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>);</div><div class="line">addEdge(graph, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>);</div><div class="line">addEdge(graph, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>);</div><div class="line">addEdge(graph, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line">Kruscal(graph);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Prim算法伪代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MST-PRIM(G,w,r)</div><div class="line"><span class="number">1</span> <span class="keyword">for</span> each u∈G.V</div><div class="line"><span class="number">2</span>     u:key=∞</div><div class="line"><span class="number">3</span>     u:π=NIL</div><div class="line"><span class="number">4</span> r:key=<span class="number">0</span></div><div class="line"><span class="number">5</span> Q=G.V</div><div class="line"><span class="number">6</span> <span class="keyword">while</span> Q≠Φ</div><div class="line"><span class="number">7</span>     u=EXTRACT-MIN(Q)</div><div class="line"><span class="number">8</span>     <span class="keyword">for</span> each vertex v∈G.Adj[u]</div><div class="line"><span class="number">9</span>     <span class="keyword">if</span> v∈Q <span class="keyword">and</span> w(u,v) &lt; v.key</div><div class="line"><span class="number">10</span>     v.π=u</div><div class="line"><span class="number">11</span>     v.key=w(u,v)</div></pre></td></tr></table></figure></p><p><img src="/img/prim.gif" alt="Prim"><br>Prim算法的运行时间取决于最小优先队列Q的实现方式。<br>若将Q实现为一个二叉最小优先队列，那么建立最小堆的时间为O(V)。<br>while循环中的语句一共要执行|V|次，每个EXTRACT-MIN的操作时间为O(lgV)，<br>则该操作的总时间为O(VlgV)。<br>所有邻接链表的长度为2|E|，8-11行总执行次数为O(E)，删除操作需要O(lgV)，<br>所以Prim算法总时间代价为O(VlgV+ElgV)=O(ElgV)。<br>从渐进意义上来说，它与Kruscal算法的运行时间相同。</p><p><strong>并查集的应用</strong><br><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="external">1. Redundant Connection</a><br>使用并查集<a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="external">判断形成环</a>的最后一条边<br><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="external">2. Redundant Connection II</a><br><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="external">3. Friend Circles</a><br>DFS求连通分量的个数或者使用并查集。<br><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="external">4. Number of Islands</a><br><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="external">5. Longest Consecutive Sequence</a><br>使用并查集，遍历其中元素，设当前数值为M，判断M+1或者M-1是否在前面出现过，若出现过，则进行合并。<br><strong>算法导论答案</strong><br><a href="http://sites.math.rutgers.edu/~ajl213/CLRS/CLRS.html" target="_blank" rel="external">CLRS Solutions</a><br><a href="https://sites.google.com/site/clrssolutions/home" target="_blank" rel="external">Solutions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;p&gt;&lt;strong&gt;Kruscal算法伪代码&lt;/stro
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Persuingsdu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基本的图算法</title>
    <link href="http://Persuingsdu.github.io/2018/03/22/%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://Persuingsdu.github.io/2018/03/22/基本的图算法/</id>
    <published>2018-03-22T06:27:01.000Z</published>
    <updated>2018-03-26T08:11:33.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>算法伪代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">BFS(G)</div><div class="line"><span class="keyword">for</span> each vertex u ∈G.V-&#123;s&#125;</div><div class="line">   u.color=WHITE</div><div class="line">   u.d= ∞</div><div class="line">   u.π=NIL</div><div class="line">s.color=GRAY</div><div class="line">s.d=<span class="number">0</span></div><div class="line">s.π=NIL</div><div class="line">Q≠ф</div><div class="line">ENQUEUE(G,s)</div><div class="line"><span class="keyword">while</span> Q≠ф</div><div class="line">u=DEQUEUE(Q)</div><div class="line"><span class="keyword">for</span> each v∈G.Adj[u]</div><div class="line">   <span class="keyword">if</span>(v.color==WHITE)</div><div class="line">      v.color=GRAY</div><div class="line">      v.d=u.d+<span class="number">1</span></div><div class="line">      v.π=u</div><div class="line">      ENQUEUE(Q,v)</div><div class="line">u.color=BLACK</div></pre></td></tr></table></figure></p><p>时间复杂度为O(V+E)，广度优先搜索的运行时间是邻接链表大小的一个线性函数。<br>下面的伪代码输出从源结点s到结点v的一条最短路径上的所有结点：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">PRINT-PATH(G,s,v)</div><div class="line"><span class="keyword">if</span> v==s</div><div class="line">   print s</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> v.π==NIL</div><div class="line">   print <span class="string">"no path from"</span>s<span class="string">"to"</span>v<span class="string">"exits"</span></div><div class="line"><span class="keyword">else</span> PRINT-PATH(G,s,v.π)</div><div class="line">   print v</div></pre></td></tr></table></figure></p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>算法伪代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">DFS(G)</div><div class="line"><span class="keyword">for</span> each vertex u ∈ G.V</div><div class="line">   u.color=WHITE</div><div class="line">   u.π=NIL</div><div class="line">time=<span class="number">0</span></div><div class="line"><span class="keyword">for</span> each vertex u ∈ G.V</div><div class="line">   <span class="keyword">if</span> u.color==WHITE</div><div class="line">   DFS-VISIT(G,u)</div><div class="line"></div><div class="line">DFS-VISIT(G,u)</div><div class="line">time=time+<span class="number">1</span>         <span class="comment">//white vertex u has just been discovered</span></div><div class="line">u.d=time</div><div class="line">u.color=GRAY</div><div class="line"><span class="keyword">for</span> each vertex v ∈ G:Adj[u]</div><div class="line">   <span class="keyword">if</span> v.color==WHITE</div><div class="line">      v.π=u</div><div class="line">      DFS-VISIT(G,v)</div><div class="line">u.color=BLACK       <span class="comment">//blacken u;it is finished</span></div><div class="line">time=time+<span class="number">1</span></div><div class="line">u.f=time</div></pre></td></tr></table></figure></p><p>1.括号定理<br>2.白色路径定理：在有向或无向图G=(V,E)的深度优先森林中，结点v是结点u的后代当且仅当在发现结点u的时间u.d，存在一条从结点u到结点v的全部由白色结点所构成的路径。<br>边的分类：<br>1.树边 2.后向边(back) 3.前向边(forward) 4.横向边(cross)<br>当第一次探索边(u,v)时：<br>1.结点v为白色表明该边是一条树边。<br>2.结点v为灰色表明该边是一条后向边。<br>3.结点v为黑色表明该边是一条前向边或横向边。</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">TOPOLOGICAL-SORT(G)</div><div class="line">call DFS(G) to compute finishing time v.f for each vertex v</div><div class="line">as each vertex is finished,insert it onto the front of a linked <span class="built_in">list</span></div><div class="line"><span class="keyword">return</span> the linked <span class="built_in">list</span> of vertices</div></pre></td></tr></table></figure></p><p><strong>引理：一个有向图G=(V,E)是无环的，当且仅当对其进行的深度优先搜索不产生后向边。</strong><br><strong>定理：拓扑排序算法生成的是有向无环图的拓扑排序。</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">证明：</div><div class="line">在有向无环图G=(V,E)上运行DFS来计算结点的完成时间。</div><div class="line">只需要证明，对于任意一对不同的结点u,v∈V,如果图G包含一条从结点u到结点v的边，则v.f &lt; u.f。</div><div class="line">考虑算法DFS(G)所探索的边(u,v)。当这条边被探索时，结点v不可能是灰色。</div><div class="line">若为灰色，则结点v是结点u的祖先，所以(u,v)是一条后向边，与之前的引理矛盾。</div><div class="line">所以结点v为白色或者黑色。若为白色，v是u的后代，则v.f &lt; u.f</div><div class="line">若为黑色，则对其全部的处理已经完成，v.f已经被设置。还需对u进行探索，最终一定有v.f &lt; u.f。</div></pre></td></tr></table></figure></p><p>拓扑排序的另外一种实现方式：<br>Another way to perform topological sorting on a directed acyclic graph G = (V, E) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time O(V + E). What happens to this algorithm if G has cycles?<br>General idea:<br>Run BFS or DFS to calculate in-degree of each vertex. O(V+E)<br>For each vertex that in-degree is 0, print it and update the in-degree of its neighbors accordingly, then there will be new in-degree=0 vertexes. Repeat this step until all vertex got printed. The entire process is also O(V+E)<br>If G has cycles, then after several iterations there will be no in-degree=0 vertexes. But original topological sorting algorithm is also only applied to directed acyclic graph.<br>判断一个有向图是否存在环，只要判断是否有<strong>backedge</strong>。<br><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="external">题目Course Schedule</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> res=<span class="literal">true</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_visited</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites, </span></span></div><div class="line"><span class="function"><span class="params"><span class="keyword">int</span> s,<span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; adj)</span></span>&#123;</div><div class="line">visited[s] = <span class="number">0</span>;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</div><div class="line"><span class="keyword">for</span> (i = adj[s].begin(); i != adj[s].end(); i++) &#123;</div><div class="line"><span class="keyword">if</span> (visited[*i] == <span class="number">-1</span>) </div><div class="line">dfs_visited(visited, prerequisites, *i, adj);</div><div class="line"><span class="keyword">if</span> (visited[*i] == <span class="number">0</span>) &#123;</div><div class="line">res = <span class="literal">false</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">visited[s] = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(numCourses, <span class="number">-1</span>);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</div><div class="line"><span class="keyword">int</span> u = prerequisites[i].second;</div><div class="line"><span class="keyword">int</span> v = prerequisites[i].first;</div><div class="line">adj[u].push_back(v);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numCourses; j++)</div><div class="line">dfs_visited(visited, prerequisites, j, adj);</div><div class="line"><span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>创建GT的时间为O(V+E)<br>下面的线性时间算法使用两次深度优先搜索计算有向图G=(V,E)的强连通分量。<br>这两次深度优先搜索一次运行在G上，一次运行在转置图GT上。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">call DFS(G) to compute finishing times u.f for each vertex u</div><div class="line">compute GT</div><div class="line">call DFS(GT),but in the main loop of DFS,consider the vertices</div><div class="line">   in order of decreasing u.f(as computed in line 1)</div><div class="line">output the vertices of each tree in the depth-first forest formed</div><div class="line">   in line 3 as a separated connected component</div></pre></td></tr></table></figure></p><p>分量图的关键性质：分量图是一个有向无环图。<br>定义：d(U)=min(u∈U){u.d},f(U)=max(u∈U){u.f}<br>即d(U)和f(U)分别是结点集合U中所有结点里最早发现的时间和最晚的结束时间。</p><p><strong>引理：设C和C’为有向图G=(V,E)的两个不同的强连通分量。假如存在一条边(u,v)∈E，这里u∈C，v∈C’。则：f(C)&gt;f(C’)</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">证明:</div><div class="line"><span class="number">1.</span>第一种情况：若d(C) &lt; d(C')，设x为C中最早被发现的结点。则在x.d时，所有C和C'中的结点都是白色。</div><div class="line">在该时刻，图G中包含一条从结点x到C中每个结点的仅有包含白色结点的路径。因为(u,v)∈E，对于任意结点</div><div class="line">w∈C'，在时刻x.d时，G中存在一条只包含白色结点的路径：x~u-v~w，所以根据白色路径定理，连通分量C'中</div><div class="line">的所有结点都成为深度优先搜索树中x的的后代，则根据<span class="number">22.8</span>，结点x的完成时间比其它所有的后代都晚，</div><div class="line">则x.f=f(C)&gt;f(C')。</div><div class="line"><span class="number">2.</span>第二种情况：如果d(C) &gt; d(C')，设y为C'中最早被发现的结点。则在y.d时，所有C'中的结点都是白色。</div><div class="line">且图C'包含一条从结点y到C'中每个结点的仅包含白色结点的路径。根据白色路径定理，C'中的所有结点都将成为</div><div class="line">深度优先搜索树中y的后代，有f(C')=y.f。在时刻y.d，所有C中的结点都为白色，有(u,v)，所以不可能存在</div><div class="line">从C'到C的路径，所以C中的结点不可能从y到达。在时刻y.f，所有C中的结点都为白色。因此对任意结点w∈C来说</div><div class="line">有w.f&gt;y.f，所以f(C)&gt;f(C')。</div></pre></td></tr></table></figure></p><p><strong>推论：设C和C’为有向图G=(V,E)两个不同的强连通分量，加入存在一条边(u,v)属于ET，这里u∈C，v∈C’则有f(C)&lt; f(C’)</strong><br>第二次深度优先搜索运行在GT上，我们从完成时间最晚的强连通分量C开始。搜索算法从C中的某个结点x开始，访问C<br>中的所有结点。根据该推论，GT中不可能包含从C到其它任何强连通分量的边。<br><strong>定理：算法STRONGLY-CONNECTED-COMPONENTS能够正确地计算出有向图G的强连通分量</strong><br>利用归纳法证明。<br>给定有向图G=(V,E)，如果对所有结点对u，v∈V，我们都有u~v或者v~u，则G是半连通的。给出一个有效的算法来判断图G是否是半连通的。<br>先求出所有的强连通分量，然后利用拓扑排序，若存在链条式的结构则说明该图是半连通的。<br><strong>3/23更新</strong></p><h2 id="衔接点、桥和双连通分量"><a href="#衔接点、桥和双连通分量" class="headerlink" title="衔接点、桥和双连通分量"></a>衔接点、桥和双连通分量</h2><p><a href="https://en.wikipedia.org/wiki/Biconnected_component" target="_blank" rel="external">Biconnected component</a><br><a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/articulation-points-and-bridges/tutorial/" target="_blank" rel="external">参考一</a><br><a href="https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/" target="_blank" rel="external">参考二</a><br>求Articulation Points算法伪代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">GetArticulationPoints(i, d)</div><div class="line">    visited[i] = <span class="literal">true</span></div><div class="line">    dis[i] = d</div><div class="line">    low[i] = d  <span class="comment">//定义u.low=MIN(u.d,w.d:(v,w)是结点u的某个后代v的一个backedge)</span></div><div class="line">    childCount = <span class="number">0</span></div><div class="line">    isArticulation = <span class="literal">false</span></div><div class="line">    <span class="keyword">for</span> each ni in adj[i]</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[ni]<span class="comment">//没有访问过</span></div><div class="line">            parent[ni] = i  </div><div class="line">            GetArticulationPoints(ni, d + <span class="number">1</span>)</div><div class="line">            childCount = childCount + <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> low[ni] &gt;= dis[i] </div><div class="line">                isArticulation = <span class="literal">true</span></div><div class="line">            low[i] = Min(low[i], low[ni]) </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ni &lt;&gt; parent[i] <span class="comment">//访问过</span></div><div class="line">            low[i] = Min(low[i], dis[ni])   <span class="comment">//较小者 ni为i能到达的结点，也就是backedge</span></div><div class="line">    <span class="keyword">if</span> (parent[i] &lt;&gt; null <span class="keyword">and</span> isArticulation) <span class="keyword">or</span> (parent[i] == null <span class="keyword">and</span> childCount &gt; <span class="number">1</span>)</div><div class="line">        Output i as articulation point</div></pre></td></tr></table></figure></p><p>Reason：<br><img src="/img/ac.png" alt="解释"><br><strong><em>Biconnected graph</em></strong>: A graph with no articulation point called biconnected. In other words, a graph is biconnected if and only if any vertex is deleted, the graph remains connected.<br>判断一个图是否是<strong>Biconnected</strong>只需要判断图中是否存在<strong>articulation point</strong></p><p><strong><em>Biconnected component</em></strong>: A biconnected component of a graph is a maximal biconnected subgraph- a biconnected subgraph that is not properly contained in a larger biconnected subgraph.<br><a href="https://www.geeksforgeeks.org/biconnected-components/" target="_blank" rel="external">参考一</a><br><a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/biconnected-components/tutorial/" target="_blank" rel="external">参考二</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;广度优先搜索&quot;&gt;&lt;a href=&quot;#广度优
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Persuingsdu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
