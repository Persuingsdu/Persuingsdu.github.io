<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Persuing</title>
  
  <subtitle>study &amp; life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Persuingsdu.github.io/"/>
  <updated>2018-02-06T12:53:28.382Z</updated>
  <id>http://Persuingsdu.github.io/</id>
  
  <author>
    <name>Persuing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://Persuingsdu.github.io/2018/02/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://Persuingsdu.github.io/2018/02/06/正则表达式/</id>
    <published>2018-02-06T14:33:30.000Z</published>
    <updated>2018-02-06T12:53:28.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>正则表达式（regular expression）是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，<code>String</code>和<code>RegExp</code>都定义了方法，后者使用正则表达式进行更强大的<code>模式匹配</code>和<code>文本检索</code>和<code>替换功能</code>。<br><strong>直接字符量</strong><br><code>字母和数字字符 \o \t \n \v \f \r</code><br><strong>字符类</strong><br>将直接量字符直接放进方括号内就组成了字符类（character class）<br><code>[...] [^...] . \w \W \s \S \d \D</code><br><strong>重复</strong><br><code>{n,m} {n,} {n} ? + *</code><br>一些例子：<br><code>/\d{2,4}/</code> 匹配2~4个数字<br><code>/\w{3}\d/</code> 精确匹配三个单词和一个可选的数字<br><code>/\s+java\s+/</code> 匹配前后带有一个或者多个空格的字符串“java”<br><code>/[^(]*/</code> 匹配一个或多个非左括号的符号<br><strong>非贪婪的重复</strong><br><code>?? +? *? {1,5}?</code><br><code>/a+/</code>匹配<code>aaa</code>三个字符，不过<code>/a+?/</code>只匹配第一个。<br><code>/a+b/</code>和<code>/a+?b/</code>匹配<code>aaab</code>时都会匹配整个字符串，因为正则表达式的模式匹配总会寻找字符串中第一个可能匹配的位置。<br><strong>选择、分组和引用</strong><br>字符<code>|</code>用于分隔供选择的字符，<code>/d{3}|[a-z]{4}/</code>匹配的是三个数字或者四个小写字母。<br>从左到右匹配，如果左边的匹配就忽略右边的匹配项。<br>正则表达式中圆括号的作用：</p><ul><li>把单独的项组合成子表达式 <code>/java(script)?/</code></li><li>在完整的模式中定义子模式 <code>/[a-z]+(\d+)/</code></li><li>允许同一正则表达式的后部引用前面的表达式 <code>/([&#39;&quot;][^&#39;&quot;]*\1)/</code></li></ul><p><strong>指定匹配位置</strong><br><code>^ $ \b \B (?=p) (?!p)</code><br><strong>修饰符</strong><br><code>i g m</code></p><h2 id="用于模式匹配的String方法"><a href="#用于模式匹配的String方法" class="headerlink" title="用于模式匹配的String方法"></a>用于模式匹配的String方法</h2><p>String对象的一些用以执行正则表达式模式匹配和检索和替换操作的方法。<br>1.<code>search()</code>接受一个正则表达式，返回第一个与之匹配的字串的起始位置，若找不到匹配的字串，它将返回-1.<br>下面的调用返回值为4 <code>&quot;JavaScript&quot;.search(/script/i)</code><br>2.<code>replace()</code>方法用以执行检索和替换操作。接受两个参数：第一个是正则表达式，第二个为参数要进行替换的字符串。<br><code>txt.replace(/javascript/gi,&quot;JavaScript&quot;)</code><br>替换字符中出现了<code>$</code>加数字<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> txt=<span class="string">"\"javaScripT i jAvaScriPt\""</span>;</div><div class="line"><span class="keyword">var</span> quote=<span class="regexp">/"([^"]*)"/g</span>;</div><div class="line"><span class="built_in">console</span>.log(txt);<span class="comment">//"javaScripT i jAvaScriPt"</span></div><div class="line">txt=txt.replace(quote,<span class="string">'\'$1\''</span>);</div><div class="line"><span class="built_in">console</span>.log(txt);<span class="comment">//'javaScripT i jAvaScriPt'</span></div></pre></td></tr></table></figure></p><p>并且<code>replace()</code>的第二个参数可以是函数，该函数能够动态地计算替换字符串。<br>3.<code>match()</code>唯一的参数为正则表达式，返回的是一个由匹配结果组成的数组，如果正则表达式设置了修饰符<code>g</code>，则该方法返回的数组中包含字符中的所有匹配的结果。如果没有修饰符<code>g</code>，它只检索第一个匹配。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> url=<span class="regexp">/(\w+):\/\/([\w.]+)\/(\S*)/</span>;</div><div class="line"><span class="keyword">var</span> text=<span class="string">"Visit my blog at http://www.example.com/~david"</span>;</div><div class="line"><span class="keyword">var</span> result=text.match(url);</div><div class="line"><span class="keyword">if</span>(result)&#123;</div><div class="line">    <span class="keyword">var</span> fullurl=result[<span class="number">0</span>];<span class="comment">//http://www.example.com/~david</span></div><div class="line">    <span class="keyword">var</span> protocol=result[<span class="number">1</span>];<span class="comment">//http </span></div><div class="line">    <span class="keyword">var</span> host=result[<span class="number">2</span>];<span class="comment">//www.example.com</span></div><div class="line">    <span class="keyword">var</span> path=result[<span class="number">3</span>];<span class="comment">//~david</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>a[0]</code>存放的是完整的匹配，<code>a[n]</code>存放的是<code>$n</code>的内容。<br>4.<code>splict()</code>这个方法用以调用它的字符串拆分为一个字串组成的数组。</p><h2 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h2><p>除了RegExp()构造函数之外，RegExp对象还支持三个方法和一个属性。<br>RegExp()构造函数带有两个字符串参数，其中第二个参数是可选的。<br><code>var zipcode=new RegExp(&quot;\\d{5}&quot;,&quot;g&quot;)</code>全局匹配字符串中的5个数字，注意这里用了<code>\\</code>,而不是<code>\</code>。<br><strong>属性</strong><br>1.<code>source</code>包含正则表达式的文本，只读。<br>2.<code>global</code>说明正则表达式是否带有修饰符g<br>3.<code>ignoreCase</code>说明正则表达式是否都带有修饰符i<br>4.<code>multiline</code>说明正则表达式是否带有修饰符m<br>5.<code>lastIndex</code>是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一个检索的开始位置，这个属性会被<code>exec()</code>和<code>test()</code>方法用到。</p><h2 id="RegExp方法"><a href="#RegExp方法" class="headerlink" title="RegExp方法"></a>RegExp方法</h2><p><code>exec()</code>返回一个数组，属性<code>index</code>包含了发生匹配的字符位置，属性<code>input</code>引用的是正在检索的字符串。<br>当同一个正则表达式第二次调用<code>exec()</code>时，它将从<code>lastIndex</code>属性所指示的字符串处开始检索。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern=<span class="regexp">/Java/g</span></div><div class="line"><span class="keyword">var</span> text=<span class="string">"JavaScript is more fun than Java!"</span>;</div><div class="line"><span class="keyword">var</span> result;</div><div class="line"><span class="keyword">while</span>((result=pattern.exec(text))!=<span class="literal">null</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Matched'"</span>+result[<span class="number">0</span>]+<span class="string">"'"</span>+<span class="string">" at position "</span>+result.index+</div><div class="line">    <span class="string">"; next search at "</span>+pattern.lastIndex);</div><div class="line">    <span class="built_in">console</span>.log(result.input);<span class="comment">//JavaScript is more fun than Java!</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//Matched'Java' at position 0; next search at 4</span></div><div class="line"><span class="comment">//Matched'Java' at position 28; next search at 32</span></div></pre></td></tr></table></figure></p><p><code>test()</code>使用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern=<span class="regexp">/java/i</span>;</div><div class="line">patter.test(<span class="string">"JavaScript"</span>);</div></pre></td></tr></table></figure></p><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="external">更多参考</a><br>以上内容源于《JavaScript权威指南》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式的定义&quot;&gt;&lt;a href=&quot;#正则表达式的定义&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的定义&quot;&gt;&lt;/a&gt;正则表达式的定义&lt;/h2&gt;&lt;p&gt;正则表达式（regular expression）是一个描述字符模式的对象。JavaScri
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://Persuingsdu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>面向对象程序设计</title>
    <link href="http://Persuingsdu.github.io/2018/02/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://Persuingsdu.github.io/2018/02/05/面向对象程序设计/</id>
    <published>2018-02-05T06:44:12.000Z</published>
    <updated>2018-02-05T13:19:43.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>ECMA-262把对象定义为“<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>”，严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都一个名字，而每个名字都映射到一个值。<br>1.常用<code>对象字面量</code>创建这种使用Object来创建自定义对象的方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    age:<span class="number">29</span>,</div><div class="line">    job:<span class="string">"Software Engineer"</span></div><div class="line">    sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>属性类型</strong><br>ECMAScript中有两种属性：<strong>数据属性</strong>和<strong>访问器属性</strong><br>1.数据属性<br><code>[[Configurable]]</code>,<code>[[Enumerble]]</code>,<code>[[Writable]]</code>,<code>[[Value]]</code><br>直接在对象上定义的属性，它们的前三种特性都被设置为<code>true</code>，而<code>[[Value]]</code>特性被设置为指定的值。<br>使用<code>Obejct.defineProperty()</code>修改属性默认的特性，接受三个参数属性所在的对象、属性的名字和一个描述符对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    writable:<span class="literal">false</span>,</div><div class="line">    value:<span class="string">"Nicholas"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>一旦把<code>configurable</code>设置为false之后就会有限制了。<br>在调用<code>Obejct.defineProperty()</code>方法创建一个新的属性时，如果不指定，其三种特定都被设置为false。<br>2.访问器属性<br><code>[[Configurable]]</code>,<code>[[Enumerable]]</code>,<code>[[Get]]</code>,<code>[[Set]]</code><br>访问器属性不能够直接定义，必须使用<code>Obejct.defineProperty()</code>来定义。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> book=&#123;</div><div class="line">    _year:<span class="number">2004</span>,</div><div class="line">    edition:<span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</div><div class="line">            <span class="keyword">this</span>._year=newValue;</div><div class="line">            <span class="keyword">this</span>.edition+=newValue<span class="number">-2004</span>;<span class="comment">//设置一个属性的值会导致其它属性的值发生变化</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line"><span class="built_in">console</span>.log(book.edition);<span class="comment">//2</span></div></pre></td></tr></table></figure></p><p>定义多个属性的值，使用<code>Object.defineProperties</code>，接受两个对象参数：一个对象是要添加或者修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。<br>读取属性的特性<code>Object.getOwnPropertyDescriptor();</code>,接受两个参数：属性所在的对象和要读取其描述符的属性名称。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><strong>构造函数模式</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div></pre></td></tr></table></figure></p><p>存在的问题：每个方法在每个实例上都要重新创建一遍。<br><strong>原型模式</strong><br>我们创建的每个函数都一个<code>prototype(原型)</code>属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>每当代码读取某个对象的某个属性时，都会执行一次搜索，首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值。如果没有这个值，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。当为对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。<br>使用<code>delete</code>操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。<br>使用<code>hasOwnProperty()</code>方法可以检测一个属性是否存在于实例中，还是存在于原型中。<br><strong>更简单的原型语法</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    name:"Nicholas",</div><div class="line">    age:29,</div><div class="line">    job:"Software Engineer",</div><div class="line">    sayName:function()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>原型的动态性</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> friend=<span class="keyword">new</span> Person();</div><div class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>)</div><div class="line">&#125;</div><div class="line">friend.sayHi();<span class="comment">//Hi</span></div></pre></td></tr></table></figure></p><p>原型对象存在数据共享的问题。<br><strong>组合使用构造函数和原型模式</strong><br>避免构造函数和原型对象产生的问题。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.friends=[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    sayName:function()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"Grey"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div><div class="line">person1.friends.push(<span class="string">"Van"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.friends);<span class="comment">//"Shelby,Court,Van"</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//"Shelby,Court"</span></div></pre></td></tr></table></figure></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。<br><strong>调用构造函数时会为实例添加一个指向最初原型的<code>[[Prototype]]</code>指针</strong><br>1.实现原型链的基本模式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.propery=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propery;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty=<span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了SuperType</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>关系图示<br><img src="/img/原型链继承.png" alt="图示"><br>原型链存在的问题：1.包含引用类型值的原型。2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。<br><strong>使用构造函数</strong><br>传递参数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//继承了SuperType,同时还传递了参数</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,<span class="string">"Nicholas"</span>);</div><div class="line">    <span class="keyword">this</span>.age=<span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.name);</div><div class="line"><span class="built_in">console</span>.log(instance.age);</div></pre></td></tr></table></figure></p><p><strong>组合继承</strong><br>组合继承（combination inheritance）：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="comment">//继承属性</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line">SubType.constructor=SubType;</div><div class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance1=<span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></div><div class="line">instance1.sayName();<span class="comment">//Nichaolas</span></div><div class="line">instance1.sayAge();<span class="comment">//29</span></div><div class="line"><span class="keyword">var</span> instance2=<span class="keyword">new</span> SubType(<span class="string">"Grey"</span>,<span class="number">27</span>);</div><div class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green"</span></div><div class="line">instance2.sayName();<span class="comment">//Grey</span></div><div class="line">instance2.sayAge();<span class="comment">//27</span></div></pre></td></tr></table></figure></p><p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，称为JavaScript中最常用的继承模式。<br><strong>原型式继承</strong><br>要求必须有一个对象作为另一个对象的基础。<br>ECMAScript5通过新增<code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义的额外的属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    friends:[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>,<span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson=<span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name=<span class="string">"Grey"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="keyword">var</span> yetAnotherPerson=<span class="built_in">Object</span>.create(person);</div><div class="line">yetAnotherPerson.name=<span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure></p><p><strong>寄生式继承</strong><br>寄生式（parasitic）即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> clone=<span class="built_in">Object</span>(original);</div><div class="line">    clone.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    friends:[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>,<span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson=createAnother(person);</div><div class="line">anotherPerson.sayHi();<span class="comment">//Hi</span></div></pre></td></tr></table></figure></p><p>包含引用类型的值始终会共享相应的值。<br><strong>寄生组合式继承</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype=<span class="built_in">Object</span>(superType.prototype);</div><div class="line">    prototype.constructor=subType;</div><div class="line">    subType.prototype=prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象程序设计&quot;&gt;&lt;a href=&quot;#面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;面向对象程序设计&quot;&gt;&lt;/a&gt;面向对象程序设计&lt;/h2&gt;&lt;p&gt;ECMA-262把对象定义为“&lt;strong&gt;无序属性的集合，其属性可以包含基本值、对象或者
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://Persuingsdu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>引用类型</title>
    <link href="http://Persuingsdu.github.io/2018/01/31/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://Persuingsdu.github.io/2018/01/31/引用类型/</id>
    <published>2018-01-31T14:50:30.000Z</published>
    <updated>2018-02-02T15:25:38.786Z</updated>
    
    <content type="html"><![CDATA[<p><strong>引用类型</strong><br>引用类型的值（对象）是引用类型的一个实例。引用类型有时候也被称为对象定义，因为它们描述的是一类对象具有的属性和方法；<br>新对象是使用<code>new</code>操作符和一个<strong>构造函数</strong>来创建。</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>创建Object实例的方法：<br>1.使用<code>new</code>操作符后跟<code>Object</code>构造函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">29</span>;</div></pre></td></tr></table></figure></p><p>2.使用<code>对象字面量</code>表示方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">"Nicolas"</span>,<span class="attr">age</span>:<span class="number">29</span>&#125;</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;&#125;;<span class="comment">//与new Object()相同</span></div><div class="line">person.name=<span class="string">"Nicholas"</span>;</div><div class="line">person.age=<span class="number">29</span>;</div></pre></td></tr></table></figure><p>开发人员更青睐于使用<code>对象字面量</code>语法，因为语法要求的代码量少，并且有封装数据的感觉，同时，也是向函数传递大量可选参数的首选方式，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> output=<span class="string">""</span>;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> args.name==<span class="string">"string"</span>)&#123;</div><div class="line">        output+=<span class="string">"Name:"</span>+args.name+<span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> args.age==<span class="string">"number"</span>)&#123;</div><div class="line">        output+=<span class="string">"Age:"</span>+args.age+<span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(output);</div><div class="line">&#125;</div><div class="line">displayInfo(&#123;<span class="attr">name</span>:<span class="string">"Nicholas"</span>,<span class="attr">age</span>:<span class="number">29</span>&#125;);</div><div class="line">displayInfo(&#123;<span class="attr">name</span>:<span class="string">"Grey"</span>&#125;);</div></pre></td></tr></table></figure></p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p><strong>创建数组的基本方式</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> Arry(<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p><p>第二种使用<code>数组字面量表示法</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> names=[];<span class="comment">//创建一个空数组</span></div></pre></td></tr></table></figure></p><p>可以通过索引来访问元素，如果设置某个值的索引超过了该数组的现有项数，数组就会自动添加到该索引的值加1<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line">colors[<span class="number">99</span>]=<span class="string">"black"</span>;</div><div class="line">alert(colors.length);<span class="comment">//100</span></div><div class="line"><span class="comment">//数组大小为100，位置3-98实际上是不存在的，所有访问它们，都将返回undefined</span></div></pre></td></tr></table></figure></p><p>另外，可以通过修改数组的<code>length</code>属性，可以从数组的末尾移除项或者向数组中添加新项；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line">colors.length=<span class="number">2</span>;</div><div class="line">alert(colors[<span class="number">2</span>]);<span class="comment">//undefined</span></div></pre></td></tr></table></figure></p><p><strong>检测数组</strong><br><code>if(Array.isArray(value))</code>确定某个对象是不是数组<br><strong>栈方法</strong><br>ECMAScript专门提供了<code>push()</code>和<code>pop()</code>方法，以便实现类似栈的行为。<br><code>push()</code>方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后的数组的长度。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> count=colors.push(<span class="string">"red"</span>,<span class="string">"green"</span>);<span class="comment">//2</span></div></pre></td></tr></table></figure></p><p><code>pop()</code>方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> item=colors.pop();<span class="comment">//item="green"</span></div></pre></td></tr></table></figure></p><p><strong>队列方法</strong><br><code>shift()</code>移除数组中的第一项并且返回该项，同时数组的长度减1。<br><code>unshift()</code>可以在数组的前端添加任意个项并返回新数组的长度。<br><strong>重排序方法</strong><br><code>reverse()</code>反转数组项的顺序<br><code>sort()</code>会调用每个数据项的<code>toString()</code>方法，然后比较字符串来排序，即便是数组中的每一项都是数值。<br>利用比较函数排序<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value1-value2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> values=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</div><div class="line">values.sort();<span class="comment">//0,1,10,15,5</span></div><div class="line">values.sort(compare);<span class="comment">//15,10,5,1,0</span></div></pre></td></tr></table></figure></p><p><strong>操作方法</strong><br><code>concat()</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> colors2=colors.concat(<span class="string">"yello"</span>,[<span class="string">"black"</span>,<span class="string">"brown"</span>]);</div></pre></td></tr></table></figure></p><p><code>slice()</code>方法接受一个参数或者两个参数，接受一个参数，返回该位置到数组末尾的所有项。两个参数，返回起始位置和结束位置之间的项，但不包括结束项。<br><code>splice()</code><br><strong>1.删除：</strong>指定两个参数，第一项的位置和要删除的项数。<code>splice(0,2)</code><br><strong>2.插入：</strong>指定三个参数，起始位置，0，要插入的项<code>splice(0,2,&quot;red&quot;,&quot;green&quot;)</code><br><strong>3.替换：</strong>指定三个参数，起始位置，要删除的项数，要插入的任意数量的项。<code>splice(2,1,&quot;red&quot;,&quot;greem)</code><br><strong>位置方法</strong><br><code>indexOf()</code>和<code>lastIndexOf()</code>接受两个参数：要查找的项和（可选的）表示查找起点位置索引。<br><strong>迭代方法</strong><br>每个方法接受2个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象。<br>传入这些方法中的函数会接受三个参数：数据项的值，该项在数组中的位置和数组对象本身。<br>1.<code>every()</code>每一项都返回true，返回true。<br>2.<code>filter()</code>返回函数会返回true的项组成的数组。<br>3.<code>forEach()</code>无返回值。<br>4.<code>map()</code>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>5.<code>some()</code>如果函数的任一项返回true，则返回true。<br><code>every()</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyResult=numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span>(item&gt;<span class="number">2</span>);</div><div class="line">&#125;);<span class="comment">//false</span></div><div class="line"><span class="keyword">var</span> someResult=numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span>(item&gt;<span class="number">2</span>);</div><div class="line">&#125;);<span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> filterResult=numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span>(item&gt;<span class="number">2</span>);</div><div class="line">&#125;);<span class="comment">//3,4,5,4,3</span></div><div class="line"><span class="keyword">var</span> mapResult=numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">&#125;);<span class="comment">//2,4,6,8,10,8,6,4,2</span></div></pre></td></tr></table></figure></p><p><strong>归并方法</strong><br>两个归并数组的方法<code>reduce()</code>和<code>reduceRight</code>,这两个方法都会迭代数组的所有项，然后构建一个最终的返回值。<br>这两个方法接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。<br>其中函数接受四个参数：前一个值，当前值，项的索引，数组对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> value=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum=value.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> pre+cur;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>创建日期对象<code>var now=new Date();</code></p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="external">正则表达式</a>，又称<strong>正规表示式</strong>、<strong>正规表示法</strong>、<strong>正规表达式</strong>、<strong>规则表达式</strong>、<strong>常规表示法</strong>（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">其它参考</a></p></blockquote><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>函数是对象，函数名是指针。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;<span class="comment">//函数声明</span></div><div class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;;<span class="comment">//函数表达式</span></div></pre></td></tr></table></figure></p><p>一个函数可能有多个名字<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;</div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//20</span></div><div class="line"><span class="keyword">var</span> anotherSum=sum;</div><div class="line">sum=<span class="literal">null</span>;</div><div class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>));<span class="comment">//20</span></div></pre></td></tr></table></figure></p><p><strong>没有重载</strong><br><strong>作为值的函数</strong><br>将一个函数像传递参数一样传递给另一个函数。<br>也可以作为一个函数的结果返回：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1,object2</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> value1=object1[propertyName];</div><div class="line">        <span class="keyword">var</span> value2=object2[propertyName];</div><div class="line">        <span class="keyword">if</span>(value1&gt;value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1&lt;value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> data=[&#123;<span class="attr">name</span>:<span class="string">"Zachary"</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"Nicholas"</span>,<span class="attr">age</span>:<span class="number">29</span>&#125;];</div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));<span class="comment">//data[0].name=Nicholas</span></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));<span class="comment">//data[0].name=Zachary</span></div></pre></td></tr></table></figure></p><p><strong>函数属性和方法</strong><br><code>apply()</code>和<code>call()</code>用途为在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。<br><code>apply()</code>接受两个参数：1.运行函数的作用域 2.参数数组（可以是<code>Array</code>实例或者是<code>argument</code>对象）<br><code>call()</code>传递给函数的参数必须逐个列举出来。<br>事实上，它们真正强大的地方在于扩充函数赖以运行的作用域。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">window</span>.color=<span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o=&#123;<span class="attr">color</span>:<span class="string">"blue"</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor.call(<span class="keyword">this</span>);<span class="comment">//red</span></div><div class="line">sayColor.call(o);<span class="comment">//blue</span></div><div class="line">sayColor.call(<span class="built_in">window</span>);<span class="comment">//red</span></div></pre></td></tr></table></figure></p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript还提供了三个特殊的引用类型<code>Boolean</code>，<code>Number</code>,<code>String</code>。<br>引用类型和基本包装类型的主要区别就是对象的生存周期。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> s1=<span class="string">"some text"</span>;</div><div class="line">s1.color=<span class="string">"red"</span>;</div><div class="line">alert(s1.color);<span class="comment">//undefined</span></div></pre></td></tr></table></figure></p><p><strong>String类型</strong><br>创建String对象<code>var stringObject=new String(&quot;hello world&quot;);</code><br>1.字符方法<br><code>charAt()</code>,<code>charCodeAt()</code><br>2.字符串操作方法<br><code>concat()</code>(实践中更多使用+)<br><code>slice()</code>和<code>substring()</code>根据<code>start</code>和<code>end</code>的值，截取子串，只有一个参数，默认<code>end</code>为结尾。<br><code>substr()</code>根据<code>start</code>和<code>numbers</code>的值，截取字串，只有一个参数，默认截取到字符串尾部。<br>3.字符串位置方法<br><code>indexOf()</code>和<code>lastIndexOf()</code>,接受一个参数，表示起始搜索点。<br>4.<code>trim()</code>方法<br>删除前置和后缀的所有空格。<br>5.字符串大小写转换方法<br><code>toLowerCase()</code>和<code>toUpperCase()</code><br>6.字符串模式匹配<br><code>match()</code>接受一个参数：要么是一个正则表达式，要么是一个RegExp对象。<br><code>search()</code>唯一的参数与<code>match()</code>相同，返回字符串中第一个匹配项的索引。<br><code>replace()</code>第一个参数可以是字符串或者是一个RegExp对象，第二个参数可以是一个字符串或者一个函数。<br><code>split()</code>基于指定的分隔符将一个字符串分割成多个字串，并将结果放在一个数组中。<br>7.<code>localCompare()</code>方法<br>这个方法比较两个字符串。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue=<span class="string">"yellow"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"brick"</span>));<span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"yellow"</span>));<span class="comment">//0</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"zoo"</span>));<span class="comment">//-1</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;引用类型&lt;/strong&gt;&lt;br&gt;引用类型的值（对象）是引用类型的一个实例。引用类型有时候也被称为对象定义，因为它们描述的是一类对象具有的属性和方法；&lt;br&gt;新对象是使用&lt;code&gt;new&lt;/code&gt;操作符和一个&lt;strong&gt;构造函数&lt;/strong&gt;来
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://Persuingsdu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://Persuingsdu.github.io/2018/01/26/%E9%9A%8F%E7%AC%94%E2%80%9D/"/>
    <id>http://Persuingsdu.github.io/2018/01/26/随笔”/</id>
    <published>2018-01-26T15:53:23.000Z</published>
    <updated>2018-01-26T16:24:06.970Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=493911&auto=0&height=66"></iframe><br>我住的城市从不下雪<br>记忆却堆满冷的感觉<br>思念的旺季<br>霓虹扫过喧哗的街<br>把快乐赶得好远<br>落单的恋人最怕过节<br>只能独自庆祝尽量喝醉<br>我爱过的人<br>没有一个留在身边<br>寂寞它陪我过夜<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>落单的恋人最怕过节<br>只能独自庆祝尽量喝醉<br>我爱过的人<br>没有一个留在身边<br>寂寞它陪我过夜<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>电话不接不要被人发现<br>我整夜都关在房间<br>狂欢的笑声<br>听来像哀悼的音乐<br>眼眶的泪 温热冻结<br>望着电视里的无聊节目<br>躺在沙发上<br>变成没知觉的植物<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>Merry christmas<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>谁来陪我过这圣诞节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://Persuingsdu.github.io/2017/12/24/Trie/"/>
    <id>http://Persuingsdu.github.io/2017/12/24/Trie/</id>
    <published>2017-12-24T07:12:34.000Z</published>
    <updated>2017-12-29T09:01:48.036Z</updated>
    
    <content type="html"><![CDATA[<p><strong>字典樹</strong><br><a id="more"></a><br>學習了一下字典樹的簡單實現方式<br><a href="http://blog.csdn.net/sunnyyoona/article/details/43900425" target="_blank" rel="external">Reference</a><br><strong>节点的定义</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn 26</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> &#123;</span></div><div class="line"><span class="keyword">int</span> count;<span class="comment">//以该节点为结尾的单词的个数</span></div><div class="line">trieNode* next[Maxn];</div><div class="line">trieNode(<span class="keyword">int</span> x) &#123;</div><div class="line">count = x;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; i++)</div><div class="line">next[i] = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>在字典中插入新的字符串</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(trieNode* &amp;root, <span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">trieNode* p = root;<span class="comment">//根节点</span></div><div class="line"><span class="comment">//一个一个字符插入</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;<span class="comment">//26个字母中的位置</span></div><div class="line"><span class="keyword">if</span> (p-&gt;next[index]==<span class="literal">NULL</span>) </div><div class="line">p-&gt;next[index] = <span class="keyword">new</span> trieNode(<span class="number">0</span>);<span class="comment">//创建</span></div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line"><span class="comment">//以该字符为结尾的单词</span></div><div class="line">p-&gt;count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>刪除字典中的元素</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(trieNode* &amp;root, <span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">trieNode* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span>;</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line">p-&gt;count--;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>查找字典中是否存在某個字符串</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(trieNode* root, <span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line">trieNode *p = root;</div><div class="line"><span class="keyword">int</span> index;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;</div><div class="line"><span class="comment">// 无法转移到下一个字符</span></div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;<span class="comment">//if</span></div><div class="line"> <span class="comment">// 继续下一个字符</span></div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> p-&gt;count &gt; <span class="number">0</span>;<span class="comment">//是否有</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>遍曆輸出整個字典</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//利用递归程序查询整个字典</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDic</span><span class="params">(trieNode* root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;word)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (root-&gt;count &gt; <span class="number">0</span>) &#123;</div><div class="line">words.push_back(word);</div><div class="line">&#125;<span class="comment">//到了根且有值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</div><div class="line"><span class="keyword">if</span> (root-&gt;next[i]) &#123;<span class="comment">//26个循环</span></div><div class="line">word.push_back(<span class="string">'a'</span> + i);</div><div class="line">printDic(root-&gt;next[i], words, word);</div><div class="line">word.pop_back();<span class="comment">//回溯</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>LeetCode上的相關題目</strong><br><a href="https://leetcode.com/problems/map-sum-pairs/description/" target="_blank" rel="external">一.題目鏈接</a><br>使用字典樹的解法<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn 26</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></div><div class="line"><span class="keyword">int</span> count;</div><div class="line"><span class="keyword">int</span> value;</div><div class="line">node* next[Maxn];</div><div class="line">node(<span class="keyword">int</span> x) &#123;</div><div class="line">count = x;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; i++)</div><div class="line">next[i] = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    MapSum() &#123;</div><div class="line">root = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = key.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">node* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = key[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line">p-&gt;next[index] = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line">p-&gt;count++;</div><div class="line">p-&gt;value = val;</div><div class="line">&#125;</div><div class="line"><span class="function">node* <span class="title">help</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = prefix.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">node* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = prefix[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> p;<span class="comment">//有该前缀</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span>&amp; res)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="comment">//空</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span> (root-&gt;count &gt; <span class="number">0</span>)</div><div class="line">res += root-&gt;value;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; i++)</div><div class="line"><span class="keyword">if</span> (root-&gt;next[i])</div><div class="line">search(root-&gt;next[i], res);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">node* current = help(prefix);</div><div class="line">search(current,res);</div><div class="line"><span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">node* root;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><a href="https://leetcode.com/problems/replace-words/description/" target="_blank" rel="external">二.題目鏈接</a><br><img src="/img/leetcode.png" alt="Runtime"><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 26</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></div><div class="line"><span class="keyword">int</span> count;</div><div class="line">node* next[maxn];</div><div class="line">node(<span class="keyword">int</span> x) &#123;</div><div class="line">count = x;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</div><div class="line">next[i] = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* root,<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">node* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line">p-&gt;next[index] = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line">p-&gt;count++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(node* &amp;root, <span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> index = c - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (root-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在</span></div><div class="line">root = root-&gt;next[index];</div><div class="line"><span class="keyword">if</span> (root-&gt;count &gt; <span class="number">0</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//存在</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//可能存在</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict, <span class="built_in">string</span> sentence)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = dict.size();</div><div class="line">node* root = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line"><span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">insert(root, dict[i]);</div><div class="line"><span class="keyword">int</span> keysize = sentence.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; keysize; ) &#123;</div><div class="line">node* p = root;</div><div class="line"><span class="built_in">string</span> element = <span class="string">""</span>;</div><div class="line"><span class="keyword">bool</span> tag = <span class="literal">false</span>;</div><div class="line"><span class="keyword">while</span> (j &lt; keysize &amp;&amp; sentence[j] != <span class="string">' '</span>) &#123;</div><div class="line">element += sentence[j];</div><div class="line"><span class="keyword">int</span> com = search(p, sentence[j]);</div><div class="line"><span class="keyword">if</span> (com==<span class="number">-1</span>) &#123;</div><div class="line">j++;</div><div class="line"><span class="keyword">while</span> (j&lt;keysize &amp;&amp; sentence[j] != <span class="string">' '</span>) &#123;</div><div class="line">element += sentence[j];</div><div class="line">j++;</div><div class="line">&#125;</div><div class="line">res += element;</div><div class="line">res += <span class="string">" "</span>;</div><div class="line">tag = <span class="literal">true</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (com == <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//do noing</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (com == <span class="number">1</span>) &#123;</div><div class="line">res += element;</div><div class="line">res += <span class="string">" "</span>;</div><div class="line">tag = <span class="literal">true</span>;</div><div class="line"><span class="keyword">while</span> (j&lt;keysize &amp;&amp; sentence[j] != <span class="string">' '</span>)</div><div class="line">j++;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">j++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!tag) &#123;</div><div class="line">res += element;</div><div class="line">res += <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line">j++;</div><div class="line">&#125;</div><div class="line">res.pop_back();</div><div class="line"><span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;字典樹&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://Persuingsdu.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://Persuingsdu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
