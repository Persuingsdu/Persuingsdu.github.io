<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Persuing</title>
  
  <subtitle>study &amp; life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Persuingsdu.github.io/"/>
  <updated>2018-04-01T09:29:50.205Z</updated>
  <id>http://Persuingsdu.github.io/</id>
  
  <author>
    <name>Persuing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机图形学实验集</title>
    <link href="http://Persuingsdu.github.io/2018/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <id>http://Persuingsdu.github.io/2018/04/01/计算机图形学实验一/</id>
    <published>2018-04-01T09:18:08.000Z</published>
    <updated>2018-04-01T09:29:50.205Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.实验一：</strong>在窗口画三个不同的图形（平面图形即可），通过鼠标选择能分别进行交互，控制它们平移缩放旋转。<br>需要解决的问题：<br>1.利用鼠标、键盘进行交互。<br>2.<a href="https://blog.csdn.net/hgl868/article/details/7947272" target="_blank" rel="external">如何判断点在多边形内。</a><br>3.如何计算出平移、缩放、旋转之后点的坐标。<br>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gl\glut.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PLOY 3</span></div><div class="line"><span class="keyword">int</span> clickX, clickY;</div><div class="line"><span class="keyword">int</span> moveNum = <span class="number">-1</span>;<span class="comment">//定义移动的哪个</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polygon</span> &#123;</span></div><div class="line"><span class="keyword">int</span> x[MAX_VERTEX];</div><div class="line"><span class="keyword">int</span> y[MAX_VERTEX];</div><div class="line"><span class="keyword">int</span> verNum;</div><div class="line">GLubyte color[<span class="number">3</span>];</div><div class="line">&#125;;</div><div class="line">polygon* polygons = <span class="keyword">new</span> polygon[MAX_PLOY];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">polygons[<span class="number">0</span>].x[<span class="number">0</span>] = <span class="number">6</span>; polygons[<span class="number">0</span>].y[<span class="number">0</span>] = <span class="number">63</span>;</div><div class="line">polygons[<span class="number">0</span>].x[<span class="number">1</span>] = <span class="number">119</span>; polygons[<span class="number">0</span>].y[<span class="number">1</span>] = <span class="number">95</span>;</div><div class="line">polygons[<span class="number">0</span>].x[<span class="number">2</span>] = <span class="number">37</span>; polygons[<span class="number">0</span>].y[<span class="number">2</span>] = <span class="number">6</span>;</div><div class="line">polygons[<span class="number">0</span>].verNum = <span class="number">3</span>;</div><div class="line">polygons[<span class="number">1</span>].x[<span class="number">0</span>] = <span class="number">350</span>; polygons[<span class="number">1</span>].y[<span class="number">0</span>] = <span class="number">95</span>;</div><div class="line">polygons[<span class="number">1</span>].x[<span class="number">1</span>] = <span class="number">190</span>; polygons[<span class="number">1</span>].y[<span class="number">1</span>] = <span class="number">100</span>;</div><div class="line">polygons[<span class="number">1</span>].x[<span class="number">2</span>] = <span class="number">200</span>; polygons[<span class="number">1</span>].y[<span class="number">2</span>] = <span class="number">150</span>;</div><div class="line">polygons[<span class="number">1</span>].x[<span class="number">3</span>] = <span class="number">380</span>; polygons[<span class="number">1</span>].y[<span class="number">3</span>] = <span class="number">200</span>;</div><div class="line">polygons[<span class="number">1</span>].verNum = <span class="number">4</span>;</div><div class="line">polygons[<span class="number">2</span>].x[<span class="number">0</span>] = <span class="number">200</span>; polygons[<span class="number">2</span>].y[<span class="number">0</span>] = <span class="number">200</span>;</div><div class="line">polygons[<span class="number">2</span>].x[<span class="number">1</span>] = <span class="number">180</span>; polygons[<span class="number">2</span>].y[<span class="number">1</span>] = <span class="number">300</span>;</div><div class="line">polygons[<span class="number">2</span>].x[<span class="number">2</span>] = <span class="number">300</span>; polygons[<span class="number">2</span>].y[<span class="number">2</span>] = <span class="number">260</span>;</div><div class="line">polygons[<span class="number">2</span>].verNum = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">glPolygons</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_PLOY; i++) &#123;</div><div class="line">polygon poly = polygons[i];</div><div class="line">glBegin(GL_LINE_LOOP);</div><div class="line"><span class="keyword">int</span> num = poly.verNum;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) </div><div class="line">glVertex2d(poly.x[j] , <span class="number">400</span> - poly.y[j]);</div><div class="line">glEnd();</div><div class="line">glFlush();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//判断多边形是否在内部</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pointInPoly</span><span class="params">(polygon poly, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> nCross = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poly.verNum; i++) &#123;</div><div class="line"><span class="keyword">int</span> p1x = poly.x[i];</div><div class="line"><span class="keyword">int</span> p1y = poly.y[i];</div><div class="line"><span class="keyword">int</span> p2x = poly.x[(i + <span class="number">1</span>) % poly.verNum];</div><div class="line"><span class="keyword">int</span> p2y = poly.y[(i + <span class="number">1</span>) % poly.verNum];</div><div class="line"><span class="comment">// 平行或在延长线上，忽略 </span></div><div class="line"><span class="keyword">if</span> (p1y == p2y || y &lt; min(p1y, p2y) || y &gt; max(p1y, p2y)) &#123;</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 计算交点横坐标 </span></div><div class="line"><span class="keyword">double</span> m = (<span class="keyword">double</span>)(y - p1y) * (<span class="keyword">double</span>)(p2x - p1x) / (<span class="keyword">double</span>)(p2y - p1y) + p1x;</div><div class="line"><span class="keyword">if</span> (m &gt; x) nCross++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> (nCross % <span class="number">2</span> == <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//移动多边形</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">movePoly</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="comment">// 取到要移动的图形 </span></div><div class="line"><span class="keyword">int</span> verNum = polygons[moveNum].verNum;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</div><div class="line">polygons[moveNum].x[i] += (x - clickX);</div><div class="line">polygons[moveNum].y[i] += (y - clickY);</div><div class="line">&#125;</div><div class="line">clickX = x;</div><div class="line">clickY = y;</div><div class="line">glutPostRedisplay();<span class="comment">//更新</span></div><div class="line"><span class="comment">//glPolygons(); //拖动带有阴影效果</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//绕定点(Rx,Ry)旋转theate角度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotatePoly</span><span class="params">(<span class="keyword">int</span> Rx, <span class="keyword">int</span> Ry, <span class="keyword">double</span> theate)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> verNum = polygons[moveNum].verNum;</div><div class="line">GLfloat tempt;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</div><div class="line">tempt = Rx + (polygons[moveNum].x[i] - Rx)*<span class="built_in">cos</span>(theate) - (polygons[moveNum].y[i] - Ry)*<span class="built_in">sin</span>(theate);</div><div class="line">polygons[moveNum].y[i] = Ry + (polygons[moveNum].x[i] - Rx)*<span class="built_in">sin</span>(theate) + (polygons[moveNum].y[i] - Ry)*<span class="built_in">cos</span>(theate);</div><div class="line">polygons[moveNum].x[i] = tempt;</div><div class="line">&#125;</div><div class="line"><span class="comment">//glPolygons();</span></div><div class="line">glutPostRedisplay();</div><div class="line">&#125;</div><div class="line"><span class="comment">//按定点(Rx,Ry)进行缩放</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scalePoly</span><span class="params">(<span class="keyword">int</span> Rx, <span class="keyword">int</span> Ry, <span class="keyword">double</span> sx, <span class="keyword">double</span> sy)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> verNum = polygons[moveNum].verNum;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</div><div class="line">polygons[moveNum].x[i] = polygons[moveNum].x[i] * sx + Rx*(<span class="number">1</span> - sx);</div><div class="line">polygons[moveNum].y[i] = polygons[moveNum].y[i] * sy + Ry*(<span class="number">1</span> - sy);</div><div class="line">&#125;</div><div class="line">glutPostRedisplay();</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标点击事件</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnMouse</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">clickX = x;</div><div class="line">clickY = y;</div><div class="line"><span class="keyword">if</span> (button == GLUT_LEFT_BUTTON&amp;&amp;state == GLUT_DOWN) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_PLOY; i++)</div><div class="line"><span class="keyword">if</span> (pointInPoly(polygons[i], x, y)) </div><div class="line">moveNum = i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标移动事件</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveMouse</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (moveNum != <span class="number">-1</span>)</div><div class="line">movePoly(x, y);</div><div class="line">&#125;</div><div class="line"><span class="comment">//键盘事件</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">switch</span> (key) &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</div><div class="line">rotatePoly(polygons[moveNum].x[<span class="number">0</span>], polygons[moveNum].y[<span class="number">0</span>], <span class="number">6</span>);<span class="comment">//逆时针旋转</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">'d'</span>:</div><div class="line">rotatePoly(polygons[moveNum].x[<span class="number">0</span>], polygons[moveNum].y[<span class="number">0</span>], <span class="number">-6</span>);<span class="comment">//顺时针旋转</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">'w'</span>:</div><div class="line">scalePoly(polygons[moveNum].x[<span class="number">0</span>], polygons[moveNum].y[<span class="number">0</span>], <span class="number">1.1</span>, <span class="number">1.1</span>);<span class="comment">//放大</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line">scalePoly(polygons[moveNum].x[<span class="number">0</span>], polygons[moveNum].y[<span class="number">0</span>], <span class="number">0.9</span>, <span class="number">0.9</span>);<span class="comment">//缩小</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">glutPostRedisplay();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitEnvironment</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">glClearColor(<span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0</span>);</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">glPointSize(<span class="number">6</span>);</div><div class="line">glMatrixMode(GL_MODELVIEW);</div><div class="line">glLoadIdentity();</div><div class="line">gluOrtho2D(<span class="number">0</span>, <span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">glPolygons();</div><div class="line">glFlush();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">glutInit(&amp;argc, argv);   <span class="comment">//初始化GLUT</span></div><div class="line">glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);</div><div class="line">glutInitWindowPosition(<span class="number">500</span>, <span class="number">200</span>);</div><div class="line">glutInitWindowSize(<span class="number">400</span>, <span class="number">400</span>);</div><div class="line">glutCreateWindow(<span class="string">"LB"</span>);</div><div class="line">glutMouseFunc(&amp;OnMouse);  <span class="comment">//注册鼠标事件</span></div><div class="line">glutMotionFunc(&amp;moveMouse);</div><div class="line">glutKeyboardFunc(&amp;keyPressed);</div><div class="line">draw();</div><div class="line">InitEnvironment();   <span class="comment">//初始化</span></div><div class="line">glutDisplayFunc(&amp;display);   <span class="comment">//回调函数 </span></div><div class="line">glutMainLoop();    <span class="comment">//持续显示，当窗口改变会重新绘制图形</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>主要参考：<br><a href="https://cuiqingcai.com/?s=OpenGL" target="_blank" rel="external">R1</a><br><a href="https://wenku.baidu.com/view/027513c55fbfc77da269b19b.html" target="_blank" rel="external">R2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.实验一：&lt;/strong&gt;在窗口画三个不同的图形（平面图形即可），通过鼠标选择能分别进行交互，控制它们平移缩放旋转。&lt;br&gt;需要解决的问题：&lt;br&gt;1.利用鼠标、键盘进行交互。&lt;br&gt;2.&lt;a href=&quot;https://blog.csdn.net/hg
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单源最短路径</title>
    <link href="http://Persuingsdu.github.io/2018/03/31/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://Persuingsdu.github.io/2018/03/31/单源最短路径/</id>
    <published>2018-03-31T04:25:05.000Z</published>
    <updated>2018-03-31T08:22:37.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="external">Bellman-Ford算法</a><br>解决的是一般情况下的单源最短路径问题，在这里，边的权重可以为负值。<br>算法返回一个布尔值，以表明是否存在一个从源结点可以到达的权重为负值的环路。如果存在这样一个环路，则算法将返回False，以表明不存在解决方案。反之，算法将给出最短路径和它们的权重。<br><img src="/img/bf.png" alt="bf"><br><strong>Bellman-Ford算法伪代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">BELLMAN-FORD(G,w,s)</div><div class="line"> INITIALIZE-SIGLE-SOURCE(G,s)</div><div class="line"> <span class="keyword">for</span> i=<span class="number">1</span> to|G.V|<span class="number">-1</span>      <span class="comment">//重复对每一边进行松弛操作</span></div><div class="line">   <span class="keyword">for</span> each egde(u,v)∈G.E</div><div class="line">     RELAX(u,v,w)</div><div class="line"> <span class="keyword">for</span> each edge(u,v)∈G.E <span class="comment">//检查负权环</span></div><div class="line">   <span class="keyword">if</span> v.d&gt;u.d+w(u,v)</div><div class="line">     <span class="keyword">return</span> FALSE</div><div class="line"> <span class="keyword">return</span> TRUE</div></pre></td></tr></table></figure></p><p><strong>松弛</strong>操作实际上是对相邻结点的访问，第n次松弛操作保证了所有深度为n的路径最短。由于图的最短路径最长不会经过超过V-1条边，所以可知该算法所得为最短路径。<br><strong>循环的提前跳出：</strong>若没有边进行松弛操作，则可以直接跳出。<br><strong>算法复杂度：</strong>O(VE)<br><strong>代码实现：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//只放核心代码</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">relase</span><span class="params">(Edge E)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (dis[E.src]!=INT_MAX&amp;&amp;dis[E.dest] &gt; dis[E.src] + E.weight) &#123;</div><div class="line">dis[E.dest] = dis[E.src] + E.weight;</div><div class="line">parent[E.dest] = E.src;</div><div class="line">t = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">dis = <span class="keyword">new</span> <span class="keyword">int</span>[graph-&gt;V];</div><div class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[graph-&gt;V];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</div><div class="line">dis[i] = INT_MAX;</div><div class="line">parent[i] = <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">dis[s] = <span class="number">0</span>;</div><div class="line">parent[s] = s;</div><div class="line">&#125;</div><div class="line"><span class="comment">//寻找路径</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (s == t) </div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="keyword">if</span> (t == <span class="number">-1</span>) </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"No path"</span>;</div><div class="line">   <span class="keyword">else</span> &#123;</div><div class="line">   findPath(s, parent[t]);</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman_ford</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">initialize(graph, s);</div><div class="line"><span class="keyword">int</span> E = graph-&gt;edges.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V - <span class="number">1</span>; i++) &#123; <span class="comment">//n-1次对每条边松弛</span></div><div class="line">t = <span class="literal">false</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</div><div class="line">relase(graph-&gt;edges[j]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!t)</div><div class="line"><span class="keyword">break</span>;<span class="comment">//未有松弛，及时终止</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123; <span class="comment">//判断是否有环</span></div><div class="line">Edge E = graph-&gt;edges[j];</div><div class="line"><span class="keyword">if</span> (dis[E.dest] &gt; dis[E.src] + E.weight)</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank" rel="external">Dijkstra算法</a>解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为<strong>非负值</strong>。<br><img src="/img/dj.png" alt="dj"><br><strong>伪代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">DIJKSTRA(G,w,s)</div><div class="line"> INITIALIZE-SINGAL-SOURCE(G,s)</div><div class="line"> S=ф</div><div class="line"> Q=G.V</div><div class="line"> <span class="keyword">while</span> Q≠ф</div><div class="line">    u=EXTRACT-MIN(Q)</div><div class="line">    S=S∪&#123;u&#125;</div><div class="line">    <span class="keyword">for</span> each vertex v∈G.Adj[u]</div><div class="line">      RELAX(u,v,w)</div></pre></td></tr></table></figure></p><p><strong>代码实现：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Graph* graph, <span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">init(graph, s); <span class="comment">//初始化</span></div><div class="line">Q.push(make_pair(<span class="number">0</span>, s));</div><div class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</div><div class="line">P x = Q.top(); Q.pop();</div><div class="line"><span class="keyword">int</span> u = x.second;</div><div class="line"><span class="keyword">if</span> (done[u]) <span class="keyword">continue</span>;</div><div class="line">done[u] = <span class="number">1</span>;    <span class="comment">//该点已经加入S</span></div><div class="line"><span class="built_in">list</span>&lt;Edge&gt;::iterator iter;</div><div class="line"><span class="keyword">for</span> (iter = graph-&gt;adj[u].begin();</div><div class="line">iter != graph-&gt;adj[u].end(); iter++) &#123;</div><div class="line"><span class="keyword">int</span> v = iter-&gt;dest;</div><div class="line"><span class="keyword">if</span> (dis[v] &gt; dis[u] + iter-&gt;weight) &#123;</div><div class="line">dis[v] = dis[u] + iter-&gt;weight;</div><div class="line">Q.push(make_pair(dis[v], v));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为Dijkstra算法总是选择V-S中“最轻”或“最近”的结点来加入到集合S中，该算法使用的是贪心策略。这里的关键是证明这样的一个事实：该算法每次选择结点u来加入到集合S时，有u.d=min{w(p):s-p-u}。<br><strong>相关问题：</strong><br><a href="https://leetcode.com/problems/network-delay-time/description/" target="_blank" rel="external">1.Network Delay Time</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bellman-Ford算法&quot;&gt;&lt;a href=&quot;#Bellman-Ford算法&quot; class=&quot;headerlink&quot; title=&quot;Bellman-Ford算法&quot;&gt;&lt;/a&gt;Bellman-Ford算法&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wi
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Persuingsdu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://Persuingsdu.github.io/2018/03/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://Persuingsdu.github.io/2018/03/27/最小生成树/</id>
    <published>2018-03-27T10:14:14.000Z</published>
    <updated>2018-03-29T14:31:13.234Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Kruscal算法伪代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MST-KRUSCAL(G,w)</div><div class="line">A=Φ</div><div class="line"><span class="keyword">for</span> each vertex v∈G.V</div><div class="line">    MAKE-SET(v)</div><div class="line">sort the edges of G.E into nondecreasing order by weight w</div><div class="line"><span class="keyword">for</span> each edge(u,v)∈G.E,taken in nondereasing order by weight</div><div class="line">   <span class="keyword">if</span> FIND-SET(u)≠FIND-SET(v)</div><div class="line">      A=A∪&#123;(u,v)&#125;</div><div class="line">      UNION(u,v)</div><div class="line"><span class="keyword">return</span> A</div></pre></td></tr></table></figure></p><p><img src="/img/kruscal.gif" alt="Kruscal"><br><strong>代码实现：</strong><br>使用<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">并查集</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></div><div class="line"><span class="keyword">int</span> src, dest, weight;</div><div class="line">Edge(<span class="keyword">int</span> src, <span class="keyword">int</span> dest, <span class="keyword">int</span> weight) &#123;</div><div class="line"><span class="keyword">this</span>-&gt;src = src;</div><div class="line"><span class="keyword">this</span>-&gt;dest = dest;</div><div class="line"><span class="keyword">this</span>-&gt;weight = weight;</div><div class="line">&#125;</div><div class="line">Edge()&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></div><div class="line"><span class="keyword">int</span> V;</div><div class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</div><div class="line">&#125;;</div><div class="line"><span class="function">Graph* <span class="title">creatGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</div><div class="line">Graph* graph = <span class="keyword">new</span> Graph;</div><div class="line">graph-&gt;V = V;</div><div class="line"><span class="keyword">return</span> graph;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subset</span> &#123;</span></div><div class="line"><span class="keyword">int</span> parent, rank;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(subset subsets[], <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (subsets[i].parent != i)</div><div class="line">subsets[i].parent = find(subsets, subsets[i].parent);</div><div class="line"><span class="keyword">return</span> subsets[i].parent;</div><div class="line">&#125;</div><div class="line"><span class="comment">//按rank合并</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(subset subsets[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> xRoot = find(subsets, x);</div><div class="line"><span class="keyword">int</span> yRoot = find(subsets, y);</div><div class="line"><span class="keyword">if</span> (subsets[xRoot].rank &lt; subsets[yRoot].rank)</div><div class="line">subsets[xRoot].parent = yRoot;</div><div class="line"><span class="keyword">else</span> </div><div class="line"><span class="keyword">if</span> (subsets[xRoot].rank &gt; subsets[yRoot].rank)</div><div class="line">    subsets[yRoot].parent = xRoot;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">    subsets[yRoot].parent = xRoot;</div><div class="line">    subsets[xRoot].rank++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Edge&amp; a, Edge&amp; b)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> a.weight &lt; b.weight;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Graph* graph, <span class="keyword">int</span> src, <span class="keyword">int</span> dest, <span class="keyword">int</span> weight)</span> </span>&#123;</div><div class="line">graph-&gt;edges.push_back(Edge(src, dest, weight));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruscal</span><span class="params">(Graph* graph)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> V = graph-&gt;V;</div><div class="line">Edge* res = <span class="keyword">new</span> Edge[V];<span class="comment">//最小生成树的边</span></div><div class="line"><span class="keyword">int</span> e = <span class="number">0</span>;<span class="comment">//边</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">sort(graph-&gt;edges.begin(), graph-&gt;edges.end(), compare);<span class="comment">//按照权值进行排序</span></div><div class="line">subset* subsets = <span class="keyword">new</span> subset[V];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</div><div class="line">subsets[v].parent = v;</div><div class="line">subsets[v].rank = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (e &lt; V - <span class="number">1</span>) &#123;</div><div class="line">Edge next_Edge = graph-&gt;edges[i++];</div><div class="line"><span class="keyword">int</span> x = find(subsets, next_Edge.src);</div><div class="line"><span class="keyword">int</span> y = find(subsets, next_Edge.dest);</div><div class="line"><span class="keyword">if</span> (x != y) &#123;</div><div class="line">res[e++] = next_Edge;</div><div class="line">Union(subsets, x, y);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Following are the edges in the constructed MST\n"</span>;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e; i++)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; res[i].src &lt;&lt; <span class="string">"----"</span> &lt;&lt; res[i].dest &lt;&lt; <span class="string">" == "</span> &lt;&lt; res[i].weight &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">/* </span></div><div class="line"><span class="comment">    10</span></div><div class="line"><span class="comment">0--------1</span></div><div class="line"><span class="comment">|  \     |</span></div><div class="line"><span class="comment">   6|   5\   |15</span></div><div class="line"><span class="comment">|      \ |</span></div><div class="line"><span class="comment">2--------3</span></div><div class="line"><span class="comment">    4       */</span></div><div class="line">Graph* graph = creatGraph(<span class="number">4</span>);</div><div class="line">addEdge(graph, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</div><div class="line">addEdge(graph, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>);</div><div class="line">addEdge(graph, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>);</div><div class="line">addEdge(graph, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>);</div><div class="line">addEdge(graph, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line">Kruscal(graph);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Prim算法伪代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">MST-PRIM(G,w,r)</div><div class="line"><span class="number">1</span> <span class="keyword">for</span> each u∈G.V</div><div class="line"><span class="number">2</span>     u:key=∞</div><div class="line"><span class="number">3</span>     u:π=NIL</div><div class="line"><span class="number">4</span> r:key=<span class="number">0</span></div><div class="line"><span class="number">5</span> Q=G.V</div><div class="line"><span class="number">6</span> <span class="keyword">while</span> Q≠Φ</div><div class="line"><span class="number">7</span>     u=EXTRACT-MIN(Q)</div><div class="line"><span class="number">8</span>     <span class="keyword">for</span> each vertex v∈G.Adj[u]</div><div class="line"><span class="number">9</span>     <span class="keyword">if</span> v∈Q <span class="keyword">and</span> w(u,v) &lt; v.key</div><div class="line"><span class="number">10</span>     v.π=u</div><div class="line"><span class="number">11</span>     v.key=w(u,v)</div></pre></td></tr></table></figure></p><p><img src="/img/prim.gif" alt="Prim"><br>Prim算法的运行时间取决于最小优先队列Q的实现方式。<br>若将Q实现为一个二叉最小优先队列，那么建立最小堆的时间为O(V)。<br>while循环中的语句一共要执行|V|次，每个EXTRACT-MIN的操作时间为O(lgV)，<br>则该操作的总时间为O(VlgV)。<br>所有邻接链表的长度为2|E|，8-11行总执行次数为O(E)，删除操作需要O(lgV)，<br>所以Prim算法总时间代价为O(VlgV+ElgV)=O(ElgV)。<br>从渐进意义上来说，它与Kruscal算法的运行时间相同。</p><p><strong>并查集的应用</strong><br><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="external">1. Redundant Connection</a><br>使用并查集<a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="external">判断形成环</a>的最后一条边<br><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="external">2. Redundant Connection II</a><br><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="external">3. Friend Circles</a><br>DFS求连通分量的个数或者使用并查集。<br><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="external">4. Number of Islands</a><br><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="external">5. Longest Consecutive Sequence</a><br>使用并查集，遍历其中元素，设当前数值为M，判断M+1或者M-1是否在前面出现过，若出现过，则进行合并。<br><strong>算法导论答案</strong><br><a href="http://sites.math.rutgers.edu/~ajl213/CLRS/CLRS.html" target="_blank" rel="external">CLRS Solutions</a><br><a href="https://sites.google.com/site/clrssolutions/home" target="_blank" rel="external">Solutions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Kruscal算法伪代码&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;MST-KRUSCAL(G,w)&lt;/div&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Persuingsdu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基本的图算法</title>
    <link href="http://Persuingsdu.github.io/2018/03/22/%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://Persuingsdu.github.io/2018/03/22/基本的图算法/</id>
    <published>2018-03-22T06:27:01.000Z</published>
    <updated>2018-03-26T08:11:33.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>算法伪代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">BFS(G)</div><div class="line"><span class="keyword">for</span> each vertex u ∈G.V-&#123;s&#125;</div><div class="line">   u.color=WHITE</div><div class="line">   u.d= ∞</div><div class="line">   u.π=NIL</div><div class="line">s.color=GRAY</div><div class="line">s.d=<span class="number">0</span></div><div class="line">s.π=NIL</div><div class="line">Q≠ф</div><div class="line">ENQUEUE(G,s)</div><div class="line"><span class="keyword">while</span> Q≠ф</div><div class="line">u=DEQUEUE(Q)</div><div class="line"><span class="keyword">for</span> each v∈G.Adj[u]</div><div class="line">   <span class="keyword">if</span>(v.color==WHITE)</div><div class="line">      v.color=GRAY</div><div class="line">      v.d=u.d+<span class="number">1</span></div><div class="line">      v.π=u</div><div class="line">      ENQUEUE(Q,v)</div><div class="line">u.color=BLACK</div></pre></td></tr></table></figure></p><p>时间复杂度为O(V+E)，广度优先搜索的运行时间是邻接链表大小的一个线性函数。<br>下面的伪代码输出从源结点s到结点v的一条最短路径上的所有结点：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">PRINT-PATH(G,s,v)</div><div class="line"><span class="keyword">if</span> v==s</div><div class="line">   print s</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> v.π==NIL</div><div class="line">   print <span class="string">"no path from"</span>s<span class="string">"to"</span>v<span class="string">"exits"</span></div><div class="line"><span class="keyword">else</span> PRINT-PATH(G,s,v.π)</div><div class="line">   print v</div></pre></td></tr></table></figure></p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>算法伪代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">DFS(G)</div><div class="line"><span class="keyword">for</span> each vertex u ∈ G.V</div><div class="line">   u.color=WHITE</div><div class="line">   u.π=NIL</div><div class="line">time=<span class="number">0</span></div><div class="line"><span class="keyword">for</span> each vertex u ∈ G.V</div><div class="line">   <span class="keyword">if</span> u.color==WHITE</div><div class="line">   DFS-VISIT(G,u)</div><div class="line"></div><div class="line">DFS-VISIT(G,u)</div><div class="line">time=time+<span class="number">1</span>         <span class="comment">//white vertex u has just been discovered</span></div><div class="line">u.d=time</div><div class="line">u.color=GRAY</div><div class="line"><span class="keyword">for</span> each vertex v ∈ G:Adj[u]</div><div class="line">   <span class="keyword">if</span> v.color==WHITE</div><div class="line">      v.π=u</div><div class="line">      DFS-VISIT(G,v)</div><div class="line">u.color=BLACK       <span class="comment">//blacken u;it is finished</span></div><div class="line">time=time+<span class="number">1</span></div><div class="line">u.f=time</div></pre></td></tr></table></figure></p><p>1.括号定理<br>2.白色路径定理：在有向或无向图G=(V,E)的深度优先森林中，结点v是结点u的后代当且仅当在发现结点u的时间u.d，存在一条从结点u到结点v的全部由白色结点所构成的路径。<br>边的分类：<br>1.树边 2.后向边(back) 3.前向边(forward) 4.横向边(cross)<br>当第一次探索边(u,v)时：<br>1.结点v为白色表明该边是一条树边。<br>2.结点v为灰色表明该边是一条后向边。<br>3.结点v为黑色表明该边是一条前向边或横向边。</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">TOPOLOGICAL-SORT(G)</div><div class="line">call DFS(G) to compute finishing time v.f for each vertex v</div><div class="line">as each vertex is finished,insert it onto the front of a linked <span class="built_in">list</span></div><div class="line"><span class="keyword">return</span> the linked <span class="built_in">list</span> of vertices</div></pre></td></tr></table></figure></p><p><strong>引理：一个有向图G=(V,E)是无环的，当且仅当对其进行的深度优先搜索不产生后向边。</strong><br><strong>定理：拓扑排序算法生成的是有向无环图的拓扑排序。</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">证明：</div><div class="line">在有向无环图G=(V,E)上运行DFS来计算结点的完成时间。</div><div class="line">只需要证明，对于任意一对不同的结点u,v∈V,如果图G包含一条从结点u到结点v的边，则v.f &lt; u.f。</div><div class="line">考虑算法DFS(G)所探索的边(u,v)。当这条边被探索时，结点v不可能是灰色。</div><div class="line">若为灰色，则结点v是结点u的祖先，所以(u,v)是一条后向边，与之前的引理矛盾。</div><div class="line">所以结点v为白色或者黑色。若为白色，v是u的后代，则v.f &lt; u.f</div><div class="line">若为黑色，则对其全部的处理已经完成，v.f已经被设置。还需对u进行探索，最终一定有v.f &lt; u.f。</div></pre></td></tr></table></figure></p><p>拓扑排序的另外一种实现方式：<br>Another way to perform topological sorting on a directed acyclic graph G = (V, E) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time O(V + E). What happens to this algorithm if G has cycles?<br>General idea:<br>Run BFS or DFS to calculate in-degree of each vertex. O(V+E)<br>For each vertex that in-degree is 0, print it and update the in-degree of its neighbors accordingly, then there will be new in-degree=0 vertexes. Repeat this step until all vertex got printed. The entire process is also O(V+E)<br>If G has cycles, then after several iterations there will be no in-degree=0 vertexes. But original topological sorting algorithm is also only applied to directed acyclic graph.<br>判断一个有向图是否存在环，只要判断是否有<strong>backedge</strong>。<br><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="external">题目Course Schedule</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> res=<span class="literal">true</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_visited</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites, </span></span></div><div class="line"><span class="function"><span class="params"><span class="keyword">int</span> s,<span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; adj)</span></span>&#123;</div><div class="line">visited[s] = <span class="number">0</span>;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</div><div class="line"><span class="keyword">for</span> (i = adj[s].begin(); i != adj[s].end(); i++) &#123;</div><div class="line"><span class="keyword">if</span> (visited[*i] == <span class="number">-1</span>) </div><div class="line">dfs_visited(visited, prerequisites, *i, adj);</div><div class="line"><span class="keyword">if</span> (visited[*i] == <span class="number">0</span>) &#123;</div><div class="line">res = <span class="literal">false</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">visited[s] = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(numCourses, <span class="number">-1</span>);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</div><div class="line"><span class="keyword">int</span> u = prerequisites[i].second;</div><div class="line"><span class="keyword">int</span> v = prerequisites[i].first;</div><div class="line">adj[u].push_back(v);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numCourses; j++)</div><div class="line">dfs_visited(visited, prerequisites, j, adj);</div><div class="line"><span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>创建GT的时间为O(V+E)<br>下面的线性时间算法使用两次深度优先搜索计算有向图G=(V,E)的强连通分量。<br>这两次深度优先搜索一次运行在G上，一次运行在转置图GT上。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">call DFS(G) to compute finishing times u.f for each vertex u</div><div class="line">compute GT</div><div class="line">call DFS(GT),but in the main loop of DFS,consider the vertices</div><div class="line">   in order of decreasing u.f(as computed in line 1)</div><div class="line">output the vertices of each tree in the depth-first forest formed</div><div class="line">   in line 3 as a separated connected component</div></pre></td></tr></table></figure></p><p>分量图的关键性质：分量图是一个有向无环图。<br>定义：d(U)=min(u∈U){u.d},f(U)=max(u∈U){u.f}<br>即d(U)和f(U)分别是结点集合U中所有结点里最早发现的时间和最晚的结束时间。</p><p><strong>引理：设C和C’为有向图G=(V,E)的两个不同的强连通分量。假如存在一条边(u,v)∈E，这里u∈C，v∈C’。则：f(C)&gt;f(C’)</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">证明:</div><div class="line"><span class="number">1.</span>第一种情况：若d(C) &lt; d(C')，设x为C中最早被发现的结点。则在x.d时，所有C和C'中的结点都是白色。</div><div class="line">在该时刻，图G中包含一条从结点x到C中每个结点的仅有包含白色结点的路径。因为(u,v)∈E，对于任意结点</div><div class="line">w∈C'，在时刻x.d时，G中存在一条只包含白色结点的路径：x~u-v~w，所以根据白色路径定理，连通分量C'中</div><div class="line">的所有结点都成为深度优先搜索树中x的的后代，则根据<span class="number">22.8</span>，结点x的完成时间比其它所有的后代都晚，</div><div class="line">则x.f=f(C)&gt;f(C')。</div><div class="line"><span class="number">2.</span>第二种情况：如果d(C) &gt; d(C')，设y为C'中最早被发现的结点。则在y.d时，所有C'中的结点都是白色。</div><div class="line">且图C'包含一条从结点y到C'中每个结点的仅包含白色结点的路径。根据白色路径定理，C'中的所有结点都将成为</div><div class="line">深度优先搜索树中y的后代，有f(C')=y.f。在时刻y.d，所有C中的结点都为白色，有(u,v)，所以不可能存在</div><div class="line">从C'到C的路径，所以C中的结点不可能从y到达。在时刻y.f，所有C中的结点都为白色。因此对任意结点w∈C来说</div><div class="line">有w.f&gt;y.f，所以f(C)&gt;f(C')。</div></pre></td></tr></table></figure></p><p><strong>推论：设C和C’为有向图G=(V,E)两个不同的强连通分量，加入存在一条边(u,v)属于ET，这里u∈C，v∈C’则有f(C)&lt; f(C’)</strong><br>第二次深度优先搜索运行在GT上，我们从完成时间最晚的强连通分量C开始。搜索算法从C中的某个结点x开始，访问C<br>中的所有结点。根据该推论，GT中不可能包含从C到其它任何强连通分量的边。<br><strong>定理：算法STRONGLY-CONNECTED-COMPONENTS能够正确地计算出有向图G的强连通分量</strong><br>利用归纳法证明。<br>给定有向图G=(V,E)，如果对所有结点对u，v∈V，我们都有u~v或者v~u，则G是半连通的。给出一个有效的算法来判断图G是否是半连通的。<br>先求出所有的强连通分量，然后利用拓扑排序，若存在链条式的结构则说明该图是半连通的。<br><strong>3/23更新</strong></p><h2 id="衔接点、桥和双连通分量"><a href="#衔接点、桥和双连通分量" class="headerlink" title="衔接点、桥和双连通分量"></a>衔接点、桥和双连通分量</h2><p><a href="https://en.wikipedia.org/wiki/Biconnected_component" target="_blank" rel="external">Biconnected component</a><br><a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/articulation-points-and-bridges/tutorial/" target="_blank" rel="external">参考一</a><br><a href="https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/" target="_blank" rel="external">参考二</a><br>求Articulation Points算法伪代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">GetArticulationPoints(i, d)</div><div class="line">    visited[i] = <span class="literal">true</span></div><div class="line">    dis[i] = d</div><div class="line">    low[i] = d  <span class="comment">//定义u.low=MIN(u.d,w.d:(v,w)是结点u的某个后代v的一个backedge)</span></div><div class="line">    childCount = <span class="number">0</span></div><div class="line">    isArticulation = <span class="literal">false</span></div><div class="line">    <span class="keyword">for</span> each ni in adj[i]</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[ni]<span class="comment">//没有访问过</span></div><div class="line">            parent[ni] = i  </div><div class="line">            GetArticulationPoints(ni, d + <span class="number">1</span>)</div><div class="line">            childCount = childCount + <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> low[ni] &gt;= dis[i] </div><div class="line">                isArticulation = <span class="literal">true</span></div><div class="line">            low[i] = Min(low[i], low[ni]) </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ni &lt;&gt; parent[i] <span class="comment">//访问过</span></div><div class="line">            low[i] = Min(low[i], dis[ni])   <span class="comment">//较小者 ni为i能到达的结点，也就是backedge</span></div><div class="line">    <span class="keyword">if</span> (parent[i] &lt;&gt; null <span class="keyword">and</span> isArticulation) <span class="keyword">or</span> (parent[i] == null <span class="keyword">and</span> childCount &gt; <span class="number">1</span>)</div><div class="line">        Output i as articulation point</div></pre></td></tr></table></figure></p><p>Reason：<br><img src="/img/ac.png" alt="解释"><br><strong><em>Biconnected graph</em></strong>: A graph with no articulation point called biconnected. In other words, a graph is biconnected if and only if any vertex is deleted, the graph remains connected.<br>判断一个图是否是<strong>Biconnected</strong>只需要判断图中是否存在<strong>articulation point</strong></p><p><strong><em>Biconnected component</em></strong>: A biconnected component of a graph is a maximal biconnected subgraph- a biconnected subgraph that is not properly contained in a larger biconnected subgraph.<br><a href="https://www.geeksforgeeks.org/biconnected-components/" target="_blank" rel="external">参考一</a><br><a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/biconnected-components/tutorial/" target="_blank" rel="external">参考二</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;广度优先搜索&quot;&gt;&lt;a href=&quot;#广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;广度优先搜索&quot;&gt;&lt;/a&gt;广度优先搜索&lt;/h2&gt;&lt;p&gt;算法伪代码：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="算法" scheme="http://Persuingsdu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学</title>
    <link href="http://Persuingsdu.github.io/2018/03/11/B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    <id>http://Persuingsdu.github.io/2018/03/11/B计算机图形学/</id>
    <published>2018-03-11T05:37:48.000Z</published>
    <updated>2018-03-11T10:32:38.038Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Bresenham算法</strong><br><a href="https://segmentfault.com/a/1190000002700500#articleHeader1" target="_blank" rel="external">主要参考</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> GLfloat d = <span class="number">0.04</span>;</div><div class="line"><span class="comment">//布局网格线 25*25</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_line</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">-25</span>; i &lt; <span class="number">25</span>; i++) &#123;</div><div class="line"><span class="comment">//垂线</span></div><div class="line">glBegin(GL_LINES);</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">glColor3f(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</div><div class="line">glLineWidth(<span class="number">2</span>);</div><div class="line">glVertex2f(i*d, <span class="number">-25</span>); </div><div class="line">glVertex2f(i*d, <span class="number">25</span>);</div><div class="line">glEnd();</div><div class="line"><span class="comment">//水平</span></div><div class="line">glBegin(GL_LINES);</div><div class="line">glLineWidth(<span class="number">2</span>);</div><div class="line">glVertex2f(<span class="number">-25</span>, i*d); </div><div class="line">glVertex2f(<span class="number">25</span>, i*d);</div><div class="line">glEnd();</div><div class="line">glFlush();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//涂色</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_rect</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">glRectf(x*d, y*d, (x + <span class="number">1</span>)*d, (y + <span class="number">1</span>)*d);</div><div class="line">&#125;</div><div class="line"><span class="comment">//画线</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bresenham</span><span class="params">(<span class="keyword">int</span> xf,<span class="keyword">int</span> yf,<span class="keyword">int</span> xt,<span class="keyword">int</span> yt)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i, j;</div><div class="line"><span class="comment">//根据坐标画出直线</span></div><div class="line">glBegin(GL_LINES);</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">glLineWidth(<span class="number">2</span>);</div><div class="line">glVertex2f(xf*d, yf*d); <span class="comment">//定点坐标范围</span></div><div class="line">glVertex2f(xt*d, yt*d);</div><div class="line">glEnd();</div><div class="line">draw_line();<span class="comment">//网格</span></div><div class="line"><span class="comment">//Bresenham算法进行涂色</span></div><div class="line"><span class="keyword">if</span> (xf &gt; xt) &#123;</div><div class="line"><span class="keyword">int</span> t;</div><div class="line">t = xf; xf = xt; xt = t;</div><div class="line">t = yf; yf = yt; yt = t;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> dx = xt - xf;</div><div class="line"><span class="keyword">int</span> dy = yt - yf;</div><div class="line"><span class="keyword">int</span> f = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt;= dx) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = xf, y = yf; x &lt;= xt; x++) &#123;</div><div class="line">put_rect(x, y);</div><div class="line"><span class="keyword">if</span> ((f + dy) + (f + dy - dx) &lt; <span class="number">0</span>)</div><div class="line">f += dy;</div><div class="line"><span class="keyword">else</span> &#123; f += dy - dx; y++; &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dy &gt;= <span class="number">0</span> &amp;&amp; dy &gt; dx) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = xf, y = yf; y &lt;= yt; y++) &#123;</div><div class="line">put_rect(x, y);</div><div class="line"><span class="keyword">if</span> ((f - dx) + (f - dx + dy) &gt; <span class="number">0</span>)</div><div class="line">f += -dx;</div><div class="line"><span class="keyword">else</span> &#123; f += -dx + dy; x++; &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dy &lt;= <span class="number">0</span> &amp;&amp; -dy &lt;= dx) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = xf, y = yf; x &lt;= xt; x++) &#123;</div><div class="line">put_rect(x, y);</div><div class="line"><span class="keyword">if</span> ((f + dy) + (f + dy + dx) &gt; <span class="number">0</span>)</div><div class="line">f += dy;</div><div class="line"><span class="keyword">else</span> &#123; f += dy + dx; y--; &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dy &lt;= <span class="number">0</span> &amp;&amp; -dy &gt; dx) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = xf, y = yf; y &gt;= yt; y--) &#123;</div><div class="line">put_rect(x, y);</div><div class="line"><span class="keyword">if</span> ((f + dx) + (f + dy + dx) &lt; <span class="number">0</span>)</div><div class="line">f += dx;</div><div class="line"><span class="keyword">else</span> &#123; f += dy + dx; x++; &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">bresenham(<span class="number">-10</span>,<span class="number">-18</span>,<span class="number">20</span>, <span class="number">18</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">//初始化opengl工具箱函数库</span></div><div class="line">glutInit(&amp;argc, argv);</div><div class="line"><span class="comment">//设置RGB色彩模式与单缓冲绘图模式</span></div><div class="line">glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);</div><div class="line"><span class="comment">//设置图像显示窗口的左上角位置(0,0)</span></div><div class="line">glutInitWindowPosition(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">//设置窗口大小(600,600)</span></div><div class="line">glutInitWindowSize(<span class="number">600</span>, <span class="number">600</span>);</div><div class="line"><span class="comment">//设置窗口标题</span></div><div class="line">glutCreateWindow(<span class="string">"Bressenham"</span>);</div><div class="line">glClearColor(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</div><div class="line"><span class="comment">//设置当前清除颜色</span></div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line"><span class="comment">//设置主程序循环显示过程中所调用的显示函数</span></div><div class="line"><span class="comment">//dispaly，表示取得函数名所对应的地址（函数地址）</span></div><div class="line">glutDisplayFunc(&amp;display);</div><div class="line"><span class="comment">//程序主循环</span></div><div class="line">glutMainLoop();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/img/画线.png" alt="画线"><br><strong>Liang-Barsky剪裁算法</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"GL\glut.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Height 100</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Width 200</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> StartX 100</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> StartY 150</span></div><div class="line">GLint S[<span class="number">4</span>], f, N[<span class="number">4</span>];</div><div class="line"><span class="keyword">float</span> u1 = <span class="number">0</span>, u2 = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawRect</span><span class="params">()</span> </span>&#123;</div><div class="line">glColor3f(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</div><div class="line">glBegin(GL_QUADS);</div><div class="line">glVertex2f(StartX, StartY);</div><div class="line">glVertex2f(StartX + Width, StartY);</div><div class="line">glVertex2f(StartX + Width, StartY + Height);</div><div class="line">glVertex2f(StartX, StartY + Height);</div><div class="line">glEnd();</div><div class="line">glFlush();</div><div class="line">&#125;</div><div class="line"><span class="comment">//布局</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitEnvironment</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">glClearColor(<span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0</span>);</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">glPointSize(<span class="number">6</span>);</div><div class="line">glMatrixMode(GL_MODELVIEW);</div><div class="line">glLoadIdentity();</div><div class="line">gluOrtho2D(<span class="number">0</span>, <span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hilight</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</div><div class="line">glColor3f(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</div><div class="line">glBegin(GL_LINES);</div><div class="line">glLineWidth(<span class="number">2</span>);</div><div class="line">glVertex2f(x1, <span class="number">400</span> - y1);</div><div class="line">glVertex2f(x2, <span class="number">400</span> - y2);</div><div class="line">glEnd();</div><div class="line">glFlush();</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LBLineClipTest</span><span class="params">(<span class="keyword">float</span> p, <span class="keyword">float</span> q, <span class="keyword">float</span> &amp;umax, <span class="keyword">float</span> &amp;umin)</span> </span>&#123;</div><div class="line"><span class="keyword">float</span> r = <span class="number">0.0</span>;</div><div class="line"><span class="keyword">if</span> (p &lt; <span class="number">0.0</span>) &#123;</div><div class="line">r = q / p;</div><div class="line"><span class="keyword">if</span> (r &gt; umin) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &gt; umax) &#123;</div><div class="line">umax = r;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p &gt; <span class="number">0.0</span>) &#123;</div><div class="line">r = q / p;</div><div class="line"><span class="keyword">if</span> (r &lt; umax) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; umin) &#123;</div><div class="line">umin = r;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (q &lt; <span class="number">0.0</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LBLineClip</span><span class="params">(<span class="keyword">float</span> xwl, <span class="keyword">float</span> xwr, <span class="keyword">float</span> ywb, <span class="keyword">float</span> ywt, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2)</span> </span>&#123;</div><div class="line"><span class="keyword">float</span> umax, umin, deltax, deltay, xx2, yy2, xx1, yy1;</div><div class="line">deltax = x2 - x1;</div><div class="line">deltay = y2 - y1;</div><div class="line">umax = <span class="number">0.0</span>;</div><div class="line">umin = <span class="number">1.0</span>;</div><div class="line"><span class="keyword">if</span> (LBLineClipTest(-deltax, x1 - xwl, umax, umin)) &#123;</div><div class="line"><span class="keyword">if</span> (LBLineClipTest(deltax, xwr - x1, umax, umin)) &#123;</div><div class="line"><span class="keyword">if</span> (LBLineClipTest(-deltay, y1 - ywb, umax, umin)) &#123;</div><div class="line"><span class="keyword">if</span> (LBLineClipTest(deltay, ywt - y1, umax, umin)) &#123;</div><div class="line">xx1 = <span class="keyword">int</span>(x1 + umax*deltax + <span class="number">0.5</span>);</div><div class="line">yy1 = <span class="keyword">int</span>(y1 + umax*deltay + <span class="number">0.5</span>);</div><div class="line">xx2 = <span class="keyword">int</span>(x1 + umin*deltax + <span class="number">0.5</span>);</div><div class="line">yy2 = <span class="keyword">int</span>(y1 + umin*deltay + <span class="number">0.5</span>);</div><div class="line">&#125;</div><div class="line">hilight(xx1, yy1, xx2, yy2);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDisplay</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">glFlush();</div><div class="line">&#125;</div><div class="line"><span class="comment">//鼠标事件</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnMouse</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">drawRect();</div><div class="line"><span class="keyword">if</span> (button == GLUT_LEFT_BUTTON&amp;&amp;state == GLUT_DOWN) &#123;</div><div class="line"><span class="keyword">if</span> (f % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">f++;</div><div class="line">S[<span class="number">0</span>] = x; S[<span class="number">1</span>] = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">f++;</div><div class="line">S[<span class="number">2</span>] = x; S[<span class="number">3</span>] = y;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">glBegin(GL_POINTS);<span class="comment">//画点  </span></div><div class="line">glVertex2f(S[<span class="number">0</span>], <span class="number">400</span> - S[<span class="number">1</span>]);</div><div class="line">glEnd();</div><div class="line">glBegin(GL_POINTS);<span class="comment">//画点  </span></div><div class="line">glVertex2f(S[<span class="number">2</span>], <span class="number">400</span> - S[<span class="number">3</span>]);</div><div class="line">glEnd();</div><div class="line"><span class="comment">//画线</span></div><div class="line">glColor3f(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">glBegin(GL_LINES);</div><div class="line">glLineWidth(<span class="number">2</span>);</div><div class="line">glVertex2f(S[<span class="number">0</span>], <span class="number">400</span> - S[<span class="number">1</span>]);</div><div class="line">glVertex2f(S[<span class="number">2</span>], <span class="number">400</span> - S[<span class="number">3</span>]);</div><div class="line">glEnd();</div><div class="line">glFlush();</div><div class="line">LBLineClip(StartX, StartX + Width, StartY, StartY + Height, S[<span class="number">0</span>], S[<span class="number">1</span>], S[<span class="number">2</span>], S[<span class="number">3</span>]);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">glutInit(&amp;argc, argv);   <span class="comment">//初始化GLUT</span></div><div class="line">glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);</div><div class="line">glutInitWindowPosition(<span class="number">500</span>, <span class="number">200</span>);</div><div class="line">glutInitWindowSize(<span class="number">400</span>, <span class="number">400</span>);</div><div class="line">glutCreateWindow(<span class="string">"LB"</span>);</div><div class="line">drawRect();</div><div class="line">InitEnvironment();   <span class="comment">//初始化</span></div><div class="line">glutMouseFunc(&amp;OnMouse);  <span class="comment">//注册鼠标事件</span></div><div class="line">glutDisplayFunc(&amp;myDisplay);   <span class="comment">//回调函数 </span></div><div class="line">glutMainLoop();    <span class="comment">//持续显示，当窗口改变会重新绘制图形</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/img/LB.png" alt="LB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Bresenham算法&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002700500#articleHeader1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主要参考&lt;
      
    
    </summary>
    
    
      <category term="CG" scheme="http://Persuingsdu.github.io/tags/CG/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://Persuingsdu.github.io/2018/02/18/%E5%87%BD%E6%95%B0/"/>
    <id>http://Persuingsdu.github.io/2018/02/18/函数/</id>
    <published>2018-02-18T05:10:10.000Z</published>
    <updated>2018-02-18T05:10:10.163Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM扩展</title>
    <link href="http://Persuingsdu.github.io/2018/02/14/DOM%E6%89%A9%E5%B1%95/"/>
    <id>http://Persuingsdu.github.io/2018/02/14/DOM扩展/</id>
    <published>2018-02-14T09:33:46.000Z</published>
    <updated>2018-02-14T11:43:11.228Z</updated>
    
    <content type="html"><![CDATA[<p>尽管DOM作为API已经非常完善了，但为了实现更多的功能，仍然会有一些标准的或专有的扩展。<br>对DOM的两个主要的扩展是<code>Selection API</code>(选择符API)和<code>HTML5</code>。这两个扩展都源自开发社区。</p><h3 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h3><p>众多JavaScript库中最常用的一项功能，就是根据CSS选择符选择与某个模式匹配的DOM元素。<br>实际上，jQuery的核心就是通过CSS选择符查询DOM文档取得元素的引用.<br>SelectionAPILevel1的两个核心是两个方法：<code>querySelector()</code>，<code>querySelectorAll()</code>。<br>在兼容的浏览器中，可以通过Document及Element类型的实例调用他们。<br>1.<strong>querySelector()方法</strong><br>该方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有匹配的元素，返回null。<br>例如：取得ID为”myDiv”的元素，<code>var myDiv=document.querySelector(&quot;#myDiv&quot;);</code><br>2.<strong>querySelectorAll()方法</strong><br>接收一个CSS选择符，返回的是一个NodeList的实例。<br>能够调用该方法的类型包括Document，DocumentFragment和Element。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//取得某&lt;div&gt;中的所有&lt;em&gt;元素</span></div><div class="line"><span class="keyword">var</span> ems=<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>);</div><div class="line"><span class="comment">//取得类为"selected"的所有元素</span></div><div class="line"><span class="keyword">var</span> selected=<span class="built_in">document</span>.querySelectorAll(<span class="string">".selected"</span>);</div><div class="line"><span class="comment">//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素</span></div><div class="line"><span class="keyword">var</span> strong=<span class="built_in">document</span>.querySelectorAll(<span class="string">"p strong"</span>);</div></pre></td></tr></table></figure></p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>HTML5规范围绕如何使用新增标记定义了大量JavaScript API,其中一些API与DOM重叠，定义了浏览器应该支持的DOM扩展。<br><strong>1.与类相关的扩充</strong><br>1.<code>getElementByClassName()</code>接收一个包含一个多个类名的字符串，返回带有指定类的所有元素的NodeList。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//取得所有类中包含"username"和"current"的元素，类名的先后顺序无所谓</span></div><div class="line"><span class="keyword">var</span> allCurrentUsernames=<span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</div><div class="line"><span class="comment">//取得ID为"myDiv"的元素中带有类名"selected"的所有元素</span></div><div class="line"><span class="keyword">var</span> selected=<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</div></pre></td></tr></table></figure></p><p>2.<code>classList</code>属性<br>支持该属性的浏览器有Firefox3.6+和Chrome。<br>方法如下：<br>1.<code>add(value)</code>2.<code>contain(value)</code><br>3.<code>remove(value)</code>4.<code>toggle(value)</code>如果列表中已经存在指定的值，删除它。如果列表中没有给定的值，添加它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尽管DOM作为API已经非常完善了，但为了实现更多的功能，仍然会有一些标准的或专有的扩展。&lt;br&gt;对DOM的两个主要的扩展是&lt;code&gt;Selection API&lt;/code&gt;(选择符API)和&lt;code&gt;HTML5&lt;/code&gt;。这两个扩展都源自开发社区。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://Persuingsdu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://Persuingsdu.github.io/2018/02/07/DOM/"/>
    <id>http://Persuingsdu.github.io/2018/02/07/DOM/</id>
    <published>2018-02-07T06:36:26.000Z</published>
    <updated>2018-02-14T11:48:57.199Z</updated>
    
    <content type="html"><![CDATA[<p><code>DOM</code>可以将任何<code>HTML</code>或<code>XML</code>文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外与其它节点存在某种关系，节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的HTML为例子:<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<html>元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其它所有元素都包含在这个文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是<html>元素。<br>将上述HTML文档表示为一个层次结构<br><img src="/img/文档层次结构.png" alt="文档层次结构"></html></html></p><h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p><strong>节点关系</strong><br>每个节点都有一个<code>childNodes</code>属性，其中保存着一个<code>NodeList</code>对象，可以用<code>[]</code>来访问NodeList的值，而且有<code>length</code>属性，并且它是基于DOM结构动态执行查询的结果，而不是在访问某一瞬间拍摄下来的快照。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> firstChild=someNode.childNodes[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> secondChild=someNode.childNodes.item(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> count=someNode.childNodes.length;</div></pre></td></tr></table></figure></p><p>将NodeList对象转换为数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> array=<span class="literal">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        array=<span class="built_in">Array</span>.prototype.slice.call(nodes,<span class="number">0</span>);<span class="comment">//针对非ie浏览器</span></div><div class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</div><div class="line">        array=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=nodes.length;i&lt;len;i++)&#123;</div><div class="line">            array.push(nodes[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每个节点都有一个<code>parentNode</code>属性，该属性指向文档树中的父节点。包含在childNodes列表中所有节点都具有相同的父节点。此外，包含在其中的每个节点相互之间都是同胞节点。<br>使用<code>previousSibling</code>和<code>nextSibling</code>属性，可以访问同一列表中的其他节点。并且第一个节点的previousSibling和最后一个节点的nextSibling为null。<br>父节点的<code>firstChild</code>和<code>lastChild</code>属性分别指向childNodes列表中的第一个节点和最后一个节点。<br><code>hasChildNodes()</code>方法在节点包含一个或多个节点的情况下返回true。<br>所有节点都有的一个属性是<code>ownerDocument</code>，该属性指向表示整个文档的文档节点。<br><img src="/img/节点关系.png" alt="节点关系"><br><strong>操作节点</strong><br>因为关系指针都是只读的，所以DOM提供了一些操作节点的方法。<br><code>appendChild()</code>，用于向childNodes列表的末尾添加一个节点，如果该节点已经是文档的一部分，就将该节点从原来位置转移到新位置。<br><code>insertBefore()</code>放到childNodes列表中某个特定的位置上，接受两个参数：要插入的节点和作为参照的节点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//插入后成为最后一个节点</span></div><div class="line"><span class="keyword">var</span> returnNode=someNode.insertBefore(newNode,<span class="literal">null</span>);</div><div class="line">alert(returnNode==someNode.lastChild);<span class="comment">//true;</span></div><div class="line"><span class="comment">//插入后成为第一个节点</span></div><div class="line">returnNode=someNode.insertBefore(newNode,someNode.firstChild);</div><div class="line">alert(returnNode==newNode);<span class="comment">//true</span></div><div class="line">alert(newNode=someNode.firstChild);<span class="comment">//true</span></div></pre></td></tr></table></figure></p><p><code>replaceChild()</code>接受两个参数：要插入的节点和要替换的节点。<br>要替换的节点将由这个方法返回并从文档中移除，同时由要插入的节点占据其位置。<br>被替换的节点仍然还在文档中，但它在文档中已经没有自己的位置<br><code>removeChild()</code>也是类似。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//替换第一个节点</span></div><div class="line"><span class="keyword">var</span> returnNode=someNode.replaceChild(newNode,someNode.firstChild);</div><div class="line"><span class="comment">//移除第一个节点</span></div><div class="line"><span class="keyword">var</span> formerFirstChild=someNode.removeChild(someNode.firstChild);</div></pre></td></tr></table></figure></p><p><code>cloneNode()</code>接受一个布尔值，表示是否执行深复制。</p><h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>JavaScript通过Document类型表示文档。在浏览器中，<code>document</code>对象是<code>HTMLDocument</code>（继承自Document类型）的一个<code>实例</code>，表示整个HTML页面。而且Document对象是window对象的一个属性，因此可以将其作为全局对象访问。<br>Document类型可以表示HTML页面或者其它基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以获得与页面有关的信息，而且还能操作页面的外观及其底层结构。<br>1.<strong>文档的子节点</strong></p><ul><li><code>documentElement</code>，该属性始终指向HTML页面中的<html>元素<br><code>var html=document.documentElement;</code></html></li><li><code>body</code>属性直接指向body元素<br><code>var body=document.body;</code></li></ul><p>2.<strong>文档信息</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//取得文档标题</span></div><div class="line"><span class="keyword">var</span> oringinalTitle=<span class="built_in">document</span>.title;</div><div class="line"><span class="comment">//设置文档</span></div><div class="line"><span class="built_in">document</span>.title=<span class="string">"New Page title"</span>;</div><div class="line"><span class="comment">//取得完整的URL</span></div><div class="line"><span class="keyword">var</span> url=<span class="built_in">document</span>.URL;</div><div class="line"><span class="comment">//取得域名</span></div><div class="line"><span class="keyword">var</span> domain=<span class="built_in">document</span>.domain;</div><div class="line"><span class="comment">//取得来源页面的URL</span></div><div class="line"><span class="keyword">var</span> referrer=<span class="built_in">document</span>.referrer;</div></pre></td></tr></table></figure></p><p>3.<strong>查找元素</strong><br>1.<code>getElementById()</code><br>如果页面中多个元素的ID值相同，只返回文档中第一次出现的元素<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;div id=<span class="string">"myDiv"</span>&gt;Some text&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">var div=document.getElementById("myDiv");/</span><span class="regexp">/获得&lt;div&gt;元素的引用</span></div></pre></td></tr></table></figure></p><p>由于IE7特性，最好不要让表单字段的name值与其它元素的id值相同。<br>2.<code>getElementByTagName()</code><br>在HTML文档中，这个方法会返回一个<code>HTMLCollection</code>对象，使用方括号或者item()方法来访问该对象中的项，通过length属性获得该对象中元素的个数,使用namedItem()通过元素的name特性取得集合中的项。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;img src=<span class="string">"myimage.gif"</span> name=<span class="string">"myImage"</span>&gt;</div><div class="line"><span class="keyword">var</span> images=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</div><div class="line">alert(images.length);<span class="comment">//输出图像的数量</span></div><div class="line">alert(images[<span class="number">0</span>].src);<span class="comment">//输出第一个图像元素的src特性</span></div><div class="line">alert(images.item(<span class="number">0</span>).src);</div><div class="line"><span class="comment">//通过如下方式从images变量中获得&lt;img&gt;元素</span></div><div class="line"><span class="keyword">var</span> myImg=images.namedItem(<span class="string">"myImage"</span>);</div><div class="line"><span class="keyword">var</span> myImg=images[<span class="string">"myImage"</span>]</div></pre></td></tr></table></figure></p><p>4.<strong>特殊集合</strong><br><code>document.images document.links</code><br><code>document.anchors document.forms</code><br>5.<strong>文档写入</strong><br><code>write()</code>和<code>writel()</code>(字符串末尾添加一个换行\n符号)方法都会接受一个字符串参数，即要写入到输出流中的文本。<br>并且在文档加载结束后再调用document.write(),那么输出的内容将会重写整个页面。<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The current data and time is:</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;strong&gt;"</span>+(<span class="keyword">new</span> <span class="built_in">Date</span>()).toString()+<span class="string">"&lt;/strong&gt;"</span>)</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>效果如下:<br><img src="/img/time.png" alt="time"></p><h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>除了Document类型之外，Element类型就算是Web编程中最常用的类型了。<br>Element类型用于表现XML或HXML元素，提供了对元素<code>标签名</code>、<code>子节点</code>及<code>特性</code>的访问。<br>使用<code>nodeName</code>或者<code>tagName</code>属性来访问元素的标签名。<br><code>&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</code><br>可以像下面这样取得这个元素及其标签名<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">alert(div.tagName);<span class="comment">//DIV</span></div><div class="line">alert(div.tagName==div.nodeName);<span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>1.<strong>HTML元素</strong><br>所有HTML元素都由<code>HTMLElement</code>类型表示。<br>HTMLElement类型都直接继承自Element并添加了一些如下属性<br><code>id</code>,<code>title</code>,<code>lang</code>(元素内容的语言代码，很少使用)<br><code>dir</code>(语言的方向，值为ltr或者rtl，很少使用),<code>className</code><br>2.<strong>取得特性</strong><br>每个元素都有一或多个特性，用途是给出相应元素或其内容的附加信息。<br>操作特性的DOM方法主要有三个，<code>getAttribute()</code>,<code>setAttribute()</code>,<code>removeAttribute()</code><br>以上方法可以针对任何特性使用，包括那些以HTMLElement类型属性的形式定义的特性。<br>开发人员不常用<code>getAttribute()</code>,而是只使用对象的属性，只有在取得自定义特性值的情况下，才会使用该方法。<br>3.<strong>设置属性</strong><br><code>setAttribute()</code>接受两个参数：要设置的特性名和值。<br><code>div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;);</code><br>4.<strong>attribues属性</strong><br><code>Element</code>类型是使用<code>attribute</code>属性的唯一一个DOM方法。<br><code>attribute</code>属性中包含一个<code>NamedNodeMap</code>，是一个“动态”的集合。<br>元素的每一个特性都由一个<code>Attr</code>节点表示，每个节点都保存在NamedNodeMap对象中。<br>NamedNodeMap拥有以下方法:<br><code>getNamedItem(name)</code>,<code>removedNamedItem(name)</code>,<code>setNamedItem(node)</code>,<code>item(pos)</code><br>attributes属性包含一系列节点，每个节点的<code>nodeName</code>就是特性的名称，<code>nodeValue</code>就是特性的值。<br>例如取得元素的id特性：<code>var id=element.attributes.getNamedItem(&quot;id&quot;).nodeValue;</code><br>5.<strong>创建元素</strong><br>使用<code>document.createElement();</code>可以创建新元素。<br>可以操作元素的特性，为它添加更多的子节点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">div.id=<span class="string">"myNewDiv"</span>;</div><div class="line">div.className=<span class="string">"box"</span>;</div></pre></td></tr></table></figure></p><p>使用<code>appendChild()</code>,<code>insertBefore()</code>,<code>replaceChild()</code>可以把新元素添加到文档树中。<br>下面的代码会把新创建的元素添加到文档的<body>元素中：<br><code>document.body.appendChild(div);</code></body></p><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>文本节点由Text类型，包含的可以是按照字面解释的纯文本内容。纯文本中可以包含转义的HTML字符，但不能包含HTML代码。<br>可以通过<code>nodeValue</code>属性或者<code>data</code>属性访问Text节点中包含的文本。<br>使用下列方法可以操作节点中的文本：<br><code>appendData(text)</code>,<code>deleteData(offset,count)</code>,<code>insertData(offset,text)</code>,<br><code>replaceData(offset,count,text)</code>,<code>splitText(offset)</code>,<code>substringData(offset,count)</code>。<br><code>length</code>属性保存着节点中字符的数目。<br>1.<strong>创建文本节点</strong><br>使用<code>createTextNode()</code>,例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> element=<span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className=<span class="string">"message"</span>;</div><div class="line"><span class="keyword">var</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">"HelloWorld"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div></pre></td></tr></table></figure></p><p>2.<strong>规范化文本节点</strong><br><code>normalize()</code>能够将相邻文本节点合并成一个节点。<br>3.<strong>分割文本节点</strong><br><code>splitText()</code>,这个会将 一个文本节点分成两个文本节点，即按照指定的位置分割<code>nodeValue</code>值。</p><h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><p>注释在DOM中是通过<code>Comment</code>类型来表示的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="keyword">var</span> comment=div.firstChild;</div><div class="line">alert(comment.nodeValue);</div></pre></td></tr></table></figure></p><p>开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。<br>其余几种类型：<code>CDATASection</code>类型，<code>DocumentType</code>类型，<code>DocumentFragment</code>类型，<code>Attr</code>类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;DOM&lt;/code&gt;可以将任何&lt;code&gt;HTML&lt;/code&gt;或&lt;code&gt;XML&lt;/code&gt;文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外与其它节点存在某
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://Persuingsdu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://Persuingsdu.github.io/2018/02/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://Persuingsdu.github.io/2018/02/06/正则表达式/</id>
    <published>2018-02-06T14:33:30.000Z</published>
    <updated>2018-02-06T12:53:28.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>正则表达式（regular expression）是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，<code>String</code>和<code>RegExp</code>都定义了方法，后者使用正则表达式进行更强大的<code>模式匹配</code>和<code>文本检索</code>和<code>替换功能</code>。<br><strong>直接字符量</strong><br><code>字母和数字字符 \o \t \n \v \f \r</code><br><strong>字符类</strong><br>将直接量字符直接放进方括号内就组成了字符类（character class）<br><code>[...] [^...] . \w \W \s \S \d \D</code><br><strong>重复</strong><br><code>{n,m} {n,} {n} ? + *</code><br>一些例子：<br><code>/\d{2,4}/</code> 匹配2~4个数字<br><code>/\w{3}\d/</code> 精确匹配三个单词和一个可选的数字<br><code>/\s+java\s+/</code> 匹配前后带有一个或者多个空格的字符串“java”<br><code>/[^(]*/</code> 匹配一个或多个非左括号的符号<br><strong>非贪婪的重复</strong><br><code>?? +? *? {1,5}?</code><br><code>/a+/</code>匹配<code>aaa</code>三个字符，不过<code>/a+?/</code>只匹配第一个。<br><code>/a+b/</code>和<code>/a+?b/</code>匹配<code>aaab</code>时都会匹配整个字符串，因为正则表达式的模式匹配总会寻找字符串中第一个可能匹配的位置。<br><strong>选择、分组和引用</strong><br>字符<code>|</code>用于分隔供选择的字符，<code>/d{3}|[a-z]{4}/</code>匹配的是三个数字或者四个小写字母。<br>从左到右匹配，如果左边的匹配就忽略右边的匹配项。<br>正则表达式中圆括号的作用：</p><ul><li>把单独的项组合成子表达式 <code>/java(script)?/</code></li><li>在完整的模式中定义子模式 <code>/[a-z]+(\d+)/</code></li><li>允许同一正则表达式的后部引用前面的表达式 <code>/([&#39;&quot;][^&#39;&quot;]*\1)/</code></li></ul><p><strong>指定匹配位置</strong><br><code>^ $ \b \B (?=p) (?!p)</code><br><strong>修饰符</strong><br><code>i g m</code></p><h2 id="用于模式匹配的String方法"><a href="#用于模式匹配的String方法" class="headerlink" title="用于模式匹配的String方法"></a>用于模式匹配的String方法</h2><p>String对象的一些用以执行正则表达式模式匹配和检索和替换操作的方法。<br>1.<code>search()</code>接受一个正则表达式，返回第一个与之匹配的字串的起始位置，若找不到匹配的字串，它将返回-1.<br>下面的调用返回值为4 <code>&quot;JavaScript&quot;.search(/script/i)</code><br>2.<code>replace()</code>方法用以执行检索和替换操作。接受两个参数：第一个是正则表达式，第二个为参数要进行替换的字符串。<br><code>txt.replace(/javascript/gi,&quot;JavaScript&quot;)</code><br>替换字符中出现了<code>$</code>加数字<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> txt=<span class="string">"\"javaScripT i jAvaScriPt\""</span>;</div><div class="line"><span class="keyword">var</span> quote=<span class="regexp">/"([^"]*)"/g</span>;</div><div class="line"><span class="built_in">console</span>.log(txt);<span class="comment">//"javaScripT i jAvaScriPt"</span></div><div class="line">txt=txt.replace(quote,<span class="string">'\'$1\''</span>);</div><div class="line"><span class="built_in">console</span>.log(txt);<span class="comment">//'javaScripT i jAvaScriPt'</span></div></pre></td></tr></table></figure></p><p>并且<code>replace()</code>的第二个参数可以是函数，该函数能够动态地计算替换字符串。<br>3.<code>match()</code>唯一的参数为正则表达式，返回的是一个由匹配结果组成的数组，如果正则表达式设置了修饰符<code>g</code>，则该方法返回的数组中包含字符中的所有匹配的结果。如果没有修饰符<code>g</code>，它只检索第一个匹配。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> url=<span class="regexp">/(\w+):\/\/([\w.]+)\/(\S*)/</span>;</div><div class="line"><span class="keyword">var</span> text=<span class="string">"Visit my blog at http://www.example.com/~david"</span>;</div><div class="line"><span class="keyword">var</span> result=text.match(url);</div><div class="line"><span class="keyword">if</span>(result)&#123;</div><div class="line">    <span class="keyword">var</span> fullurl=result[<span class="number">0</span>];<span class="comment">//http://www.example.com/~david</span></div><div class="line">    <span class="keyword">var</span> protocol=result[<span class="number">1</span>];<span class="comment">//http </span></div><div class="line">    <span class="keyword">var</span> host=result[<span class="number">2</span>];<span class="comment">//www.example.com</span></div><div class="line">    <span class="keyword">var</span> path=result[<span class="number">3</span>];<span class="comment">//~david</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>a[0]</code>存放的是完整的匹配，<code>a[n]</code>存放的是<code>$n</code>的内容。<br>4.<code>splict()</code>这个方法用以调用它的字符串拆分为一个字串组成的数组。</p><h2 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h2><p>除了RegExp()构造函数之外，RegExp对象还支持三个方法和一个属性。<br>RegExp()构造函数带有两个字符串参数，其中第二个参数是可选的。<br><code>var zipcode=new RegExp(&quot;\\d{5}&quot;,&quot;g&quot;)</code>全局匹配字符串中的5个数字，注意这里用了<code>\\</code>,而不是<code>\</code>。<br><strong>属性</strong><br>1.<code>source</code>包含正则表达式的文本，只读。<br>2.<code>global</code>说明正则表达式是否带有修饰符g<br>3.<code>ignoreCase</code>说明正则表达式是否都带有修饰符i<br>4.<code>multiline</code>说明正则表达式是否带有修饰符m<br>5.<code>lastIndex</code>是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一个检索的开始位置，这个属性会被<code>exec()</code>和<code>test()</code>方法用到。</p><h2 id="RegExp方法"><a href="#RegExp方法" class="headerlink" title="RegExp方法"></a>RegExp方法</h2><p><code>exec()</code>返回一个数组，属性<code>index</code>包含了发生匹配的字符位置，属性<code>input</code>引用的是正在检索的字符串。<br>当同一个正则表达式第二次调用<code>exec()</code>时，它将从<code>lastIndex</code>属性所指示的字符串处开始检索。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern=<span class="regexp">/Java/g</span></div><div class="line"><span class="keyword">var</span> text=<span class="string">"JavaScript is more fun than Java!"</span>;</div><div class="line"><span class="keyword">var</span> result;</div><div class="line"><span class="keyword">while</span>((result=pattern.exec(text))!=<span class="literal">null</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Matched'"</span>+result[<span class="number">0</span>]+<span class="string">"'"</span>+<span class="string">" at position "</span>+result.index+</div><div class="line">    <span class="string">"; next search at "</span>+pattern.lastIndex);</div><div class="line">    <span class="built_in">console</span>.log(result.input);<span class="comment">//JavaScript is more fun than Java!</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//Matched'Java' at position 0; next search at 4</span></div><div class="line"><span class="comment">//Matched'Java' at position 28; next search at 32</span></div></pre></td></tr></table></figure></p><p><code>test()</code>使用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern=<span class="regexp">/java/i</span>;</div><div class="line">patter.test(<span class="string">"JavaScript"</span>);</div></pre></td></tr></table></figure></p><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="external">更多参考</a><br>以上内容源于《JavaScript权威指南》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式的定义&quot;&gt;&lt;a href=&quot;#正则表达式的定义&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的定义&quot;&gt;&lt;/a&gt;正则表达式的定义&lt;/h2&gt;&lt;p&gt;正则表达式（regular expression）是一个描述字符模式的对象。JavaScri
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://Persuingsdu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>面向对象程序设计</title>
    <link href="http://Persuingsdu.github.io/2018/02/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://Persuingsdu.github.io/2018/02/05/面向对象程序设计/</id>
    <published>2018-02-05T06:44:12.000Z</published>
    <updated>2018-02-05T13:19:43.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>ECMA-262把对象定义为“<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>”，严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都一个名字，而每个名字都映射到一个值。<br>1.常用<code>对象字面量</code>创建这种使用Object来创建自定义对象的方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    age:<span class="number">29</span>,</div><div class="line">    job:<span class="string">"Software Engineer"</span></div><div class="line">    sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>属性类型</strong><br>ECMAScript中有两种属性：<strong>数据属性</strong>和<strong>访问器属性</strong><br>1.数据属性<br><code>[[Configurable]]</code>,<code>[[Enumerble]]</code>,<code>[[Writable]]</code>,<code>[[Value]]</code><br>直接在对象上定义的属性，它们的前三种特性都被设置为<code>true</code>，而<code>[[Value]]</code>特性被设置为指定的值。<br>使用<code>Obejct.defineProperty()</code>修改属性默认的特性，接受三个参数属性所在的对象、属性的名字和一个描述符对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</div><div class="line">    writable:<span class="literal">false</span>,</div><div class="line">    value:<span class="string">"Nicholas"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>一旦把<code>configurable</code>设置为false之后就会有限制了。<br>在调用<code>Obejct.defineProperty()</code>方法创建一个新的属性时，如果不指定，其三种特定都被设置为false。<br>2.访问器属性<br><code>[[Configurable]]</code>,<code>[[Enumerable]]</code>,<code>[[Get]]</code>,<code>[[Set]]</code><br>访问器属性不能够直接定义，必须使用<code>Obejct.defineProperty()</code>来定义。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> book=&#123;</div><div class="line">    _year:<span class="number">2004</span>,</div><div class="line">    edition:<span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</div><div class="line">            <span class="keyword">this</span>._year=newValue;</div><div class="line">            <span class="keyword">this</span>.edition+=newValue<span class="number">-2004</span>;<span class="comment">//设置一个属性的值会导致其它属性的值发生变化</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line"><span class="built_in">console</span>.log(book.edition);<span class="comment">//2</span></div></pre></td></tr></table></figure></p><p>定义多个属性的值，使用<code>Object.defineProperties</code>，接受两个对象参数：一个对象是要添加或者修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。<br>读取属性的特性<code>Object.getOwnPropertyDescriptor();</code>,接受两个参数：属性所在的对象和要读取其描述符的属性名称。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><strong>构造函数模式</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div></pre></td></tr></table></figure></p><p>存在的问题：每个方法在每个实例上都要重新创建一遍。<br><strong>原型模式</strong><br>我们创建的每个函数都一个<code>prototype(原型)</code>属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>每当代码读取某个对象的某个属性时，都会执行一次搜索，首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值。如果没有这个值，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。当为对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。<br>使用<code>delete</code>操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。<br>使用<code>hasOwnProperty()</code>方法可以检测一个属性是否存在于实例中，还是存在于原型中。<br><strong>更简单的原型语法</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    name:"Nicholas",</div><div class="line">    age:29,</div><div class="line">    job:"Software Engineer",</div><div class="line">    sayName:function()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>原型的动态性</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> friend=<span class="keyword">new</span> Person();</div><div class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>)</div><div class="line">&#125;</div><div class="line">friend.sayHi();<span class="comment">//Hi</span></div></pre></td></tr></table></figure></p><p>原型对象存在数据共享的问题。<br><strong>组合使用构造函数和原型模式</strong><br>避免构造函数和原型对象产生的问题。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.friends=[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    sayName:function()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"Grey"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div><div class="line">person1.friends.push(<span class="string">"Van"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.friends);<span class="comment">//"Shelby,Court,Van"</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//"Shelby,Court"</span></div></pre></td></tr></table></figure></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。<br><strong>调用构造函数时会为实例添加一个指向最初原型的<code>[[Prototype]]</code>指针</strong><br>1.实现原型链的基本模式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.propery=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propery;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty=<span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了SuperType</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>关系图示<br><img src="/img/原型链继承.png" alt="图示"><br>原型链存在的问题：1.包含引用类型值的原型。2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。<br><strong>使用构造函数</strong><br>传递参数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//继承了SuperType,同时还传递了参数</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,<span class="string">"Nicholas"</span>);</div><div class="line">    <span class="keyword">this</span>.age=<span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.name);</div><div class="line"><span class="built_in">console</span>.log(instance.age);</div></pre></td></tr></table></figure></p><p><strong>组合继承</strong><br>组合继承（combination inheritance）：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="comment">//继承属性</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line">SubType.constructor=SubType;</div><div class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance1=<span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></div><div class="line">instance1.sayName();<span class="comment">//Nichaolas</span></div><div class="line">instance1.sayAge();<span class="comment">//29</span></div><div class="line"><span class="keyword">var</span> instance2=<span class="keyword">new</span> SubType(<span class="string">"Grey"</span>,<span class="number">27</span>);</div><div class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green"</span></div><div class="line">instance2.sayName();<span class="comment">//Grey</span></div><div class="line">instance2.sayAge();<span class="comment">//27</span></div></pre></td></tr></table></figure></p><p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，称为JavaScript中最常用的继承模式。<br><strong>原型式继承</strong><br>要求必须有一个对象作为另一个对象的基础。<br>ECMAScript5通过新增<code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义的额外的属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    friends:[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>,<span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson=<span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name=<span class="string">"Grey"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="keyword">var</span> yetAnotherPerson=<span class="built_in">Object</span>.create(person);</div><div class="line">yetAnotherPerson.name=<span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure></p><p><strong>寄生式继承</strong><br>寄生式（parasitic）即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> clone=<span class="built_in">Object</span>(original);</div><div class="line">    clone.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">    name:<span class="string">"Nicholas"</span>,</div><div class="line">    friends:[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>,<span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson=createAnother(person);</div><div class="line">anotherPerson.sayHi();<span class="comment">//Hi</span></div></pre></td></tr></table></figure></p><p>包含引用类型的值始终会共享相应的值。<br><strong>寄生组合式继承</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype=<span class="built_in">Object</span>(superType.prototype);</div><div class="line">    prototype.constructor=subType;</div><div class="line">    subType.prototype=prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象程序设计&quot;&gt;&lt;a href=&quot;#面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;面向对象程序设计&quot;&gt;&lt;/a&gt;面向对象程序设计&lt;/h2&gt;&lt;p&gt;ECMA-262把对象定义为“&lt;strong&gt;无序属性的集合，其属性可以包含基本值、对象或者
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://Persuingsdu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>引用类型</title>
    <link href="http://Persuingsdu.github.io/2018/01/31/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://Persuingsdu.github.io/2018/01/31/引用类型/</id>
    <published>2018-01-31T14:50:30.000Z</published>
    <updated>2018-02-02T15:25:38.786Z</updated>
    
    <content type="html"><![CDATA[<p><strong>引用类型</strong><br>引用类型的值（对象）是引用类型的一个实例。引用类型有时候也被称为对象定义，因为它们描述的是一类对象具有的属性和方法；<br>新对象是使用<code>new</code>操作符和一个<strong>构造函数</strong>来创建。</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>创建Object实例的方法：<br>1.使用<code>new</code>操作符后跟<code>Object</code>构造函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">29</span>;</div></pre></td></tr></table></figure></p><p>2.使用<code>对象字面量</code>表示方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">"Nicolas"</span>,<span class="attr">age</span>:<span class="number">29</span>&#125;</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;&#125;;<span class="comment">//与new Object()相同</span></div><div class="line">person.name=<span class="string">"Nicholas"</span>;</div><div class="line">person.age=<span class="number">29</span>;</div></pre></td></tr></table></figure><p>开发人员更青睐于使用<code>对象字面量</code>语法，因为语法要求的代码量少，并且有封装数据的感觉，同时，也是向函数传递大量可选参数的首选方式，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> output=<span class="string">""</span>;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> args.name==<span class="string">"string"</span>)&#123;</div><div class="line">        output+=<span class="string">"Name:"</span>+args.name+<span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> args.age==<span class="string">"number"</span>)&#123;</div><div class="line">        output+=<span class="string">"Age:"</span>+args.age+<span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(output);</div><div class="line">&#125;</div><div class="line">displayInfo(&#123;<span class="attr">name</span>:<span class="string">"Nicholas"</span>,<span class="attr">age</span>:<span class="number">29</span>&#125;);</div><div class="line">displayInfo(&#123;<span class="attr">name</span>:<span class="string">"Grey"</span>&#125;);</div></pre></td></tr></table></figure></p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p><strong>创建数组的基本方式</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> Arry(<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p><p>第二种使用<code>数组字面量表示法</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> names=[];<span class="comment">//创建一个空数组</span></div></pre></td></tr></table></figure></p><p>可以通过索引来访问元素，如果设置某个值的索引超过了该数组的现有项数，数组就会自动添加到该索引的值加1<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line">colors[<span class="number">99</span>]=<span class="string">"black"</span>;</div><div class="line">alert(colors.length);<span class="comment">//100</span></div><div class="line"><span class="comment">//数组大小为100，位置3-98实际上是不存在的，所有访问它们，都将返回undefined</span></div></pre></td></tr></table></figure></p><p>另外，可以通过修改数组的<code>length</code>属性，可以从数组的末尾移除项或者向数组中添加新项；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line">colors.length=<span class="number">2</span>;</div><div class="line">alert(colors[<span class="number">2</span>]);<span class="comment">//undefined</span></div></pre></td></tr></table></figure></p><p><strong>检测数组</strong><br><code>if(Array.isArray(value))</code>确定某个对象是不是数组<br><strong>栈方法</strong><br>ECMAScript专门提供了<code>push()</code>和<code>pop()</code>方法，以便实现类似栈的行为。<br><code>push()</code>方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后的数组的长度。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> count=colors.push(<span class="string">"red"</span>,<span class="string">"green"</span>);<span class="comment">//2</span></div></pre></td></tr></table></figure></p><p><code>pop()</code>方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> item=colors.pop();<span class="comment">//item="green"</span></div></pre></td></tr></table></figure></p><p><strong>队列方法</strong><br><code>shift()</code>移除数组中的第一项并且返回该项，同时数组的长度减1。<br><code>unshift()</code>可以在数组的前端添加任意个项并返回新数组的长度。<br><strong>重排序方法</strong><br><code>reverse()</code>反转数组项的顺序<br><code>sort()</code>会调用每个数据项的<code>toString()</code>方法，然后比较字符串来排序，即便是数组中的每一项都是数值。<br>利用比较函数排序<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value1-value2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> values=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</div><div class="line">values.sort();<span class="comment">//0,1,10,15,5</span></div><div class="line">values.sort(compare);<span class="comment">//15,10,5,1,0</span></div></pre></td></tr></table></figure></p><p><strong>操作方法</strong><br><code>concat()</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> colors2=colors.concat(<span class="string">"yello"</span>,[<span class="string">"black"</span>,<span class="string">"brown"</span>]);</div></pre></td></tr></table></figure></p><p><code>slice()</code>方法接受一个参数或者两个参数，接受一个参数，返回该位置到数组末尾的所有项。两个参数，返回起始位置和结束位置之间的项，但不包括结束项。<br><code>splice()</code><br><strong>1.删除：</strong>指定两个参数，第一项的位置和要删除的项数。<code>splice(0,2)</code><br><strong>2.插入：</strong>指定三个参数，起始位置，0，要插入的项<code>splice(0,2,&quot;red&quot;,&quot;green&quot;)</code><br><strong>3.替换：</strong>指定三个参数，起始位置，要删除的项数，要插入的任意数量的项。<code>splice(2,1,&quot;red&quot;,&quot;greem)</code><br><strong>位置方法</strong><br><code>indexOf()</code>和<code>lastIndexOf()</code>接受两个参数：要查找的项和（可选的）表示查找起点位置索引。<br><strong>迭代方法</strong><br>每个方法接受2个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象。<br>传入这些方法中的函数会接受三个参数：数据项的值，该项在数组中的位置和数组对象本身。<br>1.<code>every()</code>每一项都返回true，返回true。<br>2.<code>filter()</code>返回函数会返回true的项组成的数组。<br>3.<code>forEach()</code>无返回值。<br>4.<code>map()</code>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>5.<code>some()</code>如果函数的任一项返回true，则返回true。<br><code>every()</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyResult=numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span>(item&gt;<span class="number">2</span>);</div><div class="line">&#125;);<span class="comment">//false</span></div><div class="line"><span class="keyword">var</span> someResult=numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span>(item&gt;<span class="number">2</span>);</div><div class="line">&#125;);<span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> filterResult=numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span>(item&gt;<span class="number">2</span>);</div><div class="line">&#125;);<span class="comment">//3,4,5,4,3</span></div><div class="line"><span class="keyword">var</span> mapResult=numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">&#125;);<span class="comment">//2,4,6,8,10,8,6,4,2</span></div></pre></td></tr></table></figure></p><p><strong>归并方法</strong><br>两个归并数组的方法<code>reduce()</code>和<code>reduceRight</code>,这两个方法都会迭代数组的所有项，然后构建一个最终的返回值。<br>这两个方法接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。<br>其中函数接受四个参数：前一个值，当前值，项的索引，数组对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> value=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum=value.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur,index,array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> pre+cur;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>创建日期对象<code>var now=new Date();</code></p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="external">正则表达式</a>，又称<strong>正规表示式</strong>、<strong>正规表示法</strong>、<strong>正规表达式</strong>、<strong>规则表达式</strong>、<strong>常规表示法</strong>（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">其它参考</a></p></blockquote><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>函数是对象，函数名是指针。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;<span class="comment">//函数声明</span></div><div class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;;<span class="comment">//函数表达式</span></div></pre></td></tr></table></figure></p><p>一个函数可能有多个名字<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;</div><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//20</span></div><div class="line"><span class="keyword">var</span> anotherSum=sum;</div><div class="line">sum=<span class="literal">null</span>;</div><div class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>));<span class="comment">//20</span></div></pre></td></tr></table></figure></p><p><strong>没有重载</strong><br><strong>作为值的函数</strong><br>将一个函数像传递参数一样传递给另一个函数。<br>也可以作为一个函数的结果返回：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1,object2</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> value1=object1[propertyName];</div><div class="line">        <span class="keyword">var</span> value2=object2[propertyName];</div><div class="line">        <span class="keyword">if</span>(value1&gt;value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1&lt;value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> data=[&#123;<span class="attr">name</span>:<span class="string">"Zachary"</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"Nicholas"</span>,<span class="attr">age</span>:<span class="number">29</span>&#125;];</div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));<span class="comment">//data[0].name=Nicholas</span></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));<span class="comment">//data[0].name=Zachary</span></div></pre></td></tr></table></figure></p><p><strong>函数属性和方法</strong><br><code>apply()</code>和<code>call()</code>用途为在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。<br><code>apply()</code>接受两个参数：1.运行函数的作用域 2.参数数组（可以是<code>Array</code>实例或者是<code>argument</code>对象）<br><code>call()</code>传递给函数的参数必须逐个列举出来。<br>事实上，它们真正强大的地方在于扩充函数赖以运行的作用域。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">window</span>.color=<span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o=&#123;<span class="attr">color</span>:<span class="string">"blue"</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor.call(<span class="keyword">this</span>);<span class="comment">//red</span></div><div class="line">sayColor.call(o);<span class="comment">//blue</span></div><div class="line">sayColor.call(<span class="built_in">window</span>);<span class="comment">//red</span></div></pre></td></tr></table></figure></p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript还提供了三个特殊的引用类型<code>Boolean</code>，<code>Number</code>,<code>String</code>。<br>引用类型和基本包装类型的主要区别就是对象的生存周期。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> s1=<span class="string">"some text"</span>;</div><div class="line">s1.color=<span class="string">"red"</span>;</div><div class="line">alert(s1.color);<span class="comment">//undefined</span></div></pre></td></tr></table></figure></p><p><strong>String类型</strong><br>创建String对象<code>var stringObject=new String(&quot;hello world&quot;);</code><br>1.字符方法<br><code>charAt()</code>,<code>charCodeAt()</code><br>2.字符串操作方法<br><code>concat()</code>(实践中更多使用+)<br><code>slice()</code>和<code>substring()</code>根据<code>start</code>和<code>end</code>的值，截取子串，只有一个参数，默认<code>end</code>为结尾。<br><code>substr()</code>根据<code>start</code>和<code>numbers</code>的值，截取字串，只有一个参数，默认截取到字符串尾部。<br>3.字符串位置方法<br><code>indexOf()</code>和<code>lastIndexOf()</code>,接受一个参数，表示起始搜索点。<br>4.<code>trim()</code>方法<br>删除前置和后缀的所有空格。<br>5.字符串大小写转换方法<br><code>toLowerCase()</code>和<code>toUpperCase()</code><br>6.字符串模式匹配<br><code>match()</code>接受一个参数：要么是一个正则表达式，要么是一个RegExp对象。<br><code>search()</code>唯一的参数与<code>match()</code>相同，返回字符串中第一个匹配项的索引。<br><code>replace()</code>第一个参数可以是字符串或者是一个RegExp对象，第二个参数可以是一个字符串或者一个函数。<br><code>split()</code>基于指定的分隔符将一个字符串分割成多个字串，并将结果放在一个数组中。<br>7.<code>localCompare()</code>方法<br>这个方法比较两个字符串。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue=<span class="string">"yellow"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"brick"</span>));<span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"yellow"</span>));<span class="comment">//0</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"zoo"</span>));<span class="comment">//-1</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;引用类型&lt;/strong&gt;&lt;br&gt;引用类型的值（对象）是引用类型的一个实例。引用类型有时候也被称为对象定义，因为它们描述的是一类对象具有的属性和方法；&lt;br&gt;新对象是使用&lt;code&gt;new&lt;/code&gt;操作符和一个&lt;strong&gt;构造函数&lt;/strong&gt;来
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://Persuingsdu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://Persuingsdu.github.io/2018/01/26/%E9%9A%8F%E7%AC%94/"/>
    <id>http://Persuingsdu.github.io/2018/01/26/随笔/</id>
    <published>2018-01-26T15:53:23.000Z</published>
    <updated>2018-01-26T16:24:06.970Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=493911&auto=0&height=66"></iframe><br>我住的城市从不下雪<br>记忆却堆满冷的感觉<br>思念的旺季<br>霓虹扫过喧哗的街<br>把快乐赶得好远<br>落单的恋人最怕过节<br>只能独自庆祝尽量喝醉<br>我爱过的人<br>没有一个留在身边<br>寂寞它陪我过夜<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>落单的恋人最怕过节<br>只能独自庆祝尽量喝醉<br>我爱过的人<br>没有一个留在身边<br>寂寞它陪我过夜<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>电话不接不要被人发现<br>我整夜都关在房间<br>狂欢的笑声<br>听来像哀悼的音乐<br>眼眶的泪 温热冻结<br>望着电视里的无聊节目<br>躺在沙发上<br>变成没知觉的植物<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>Merry christmas<br>Merry merry christmas<br>Lonely lonely christmas<br>想祝福不知该给谁<br>爱被我们打了死结<br>Lonely lonely christmas<br>Merry merry christmas<br>写了卡片能寄给谁<br>心碎的像街上的纸屑<br>谁来陪我过这圣诞节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://Persuingsdu.github.io/2017/12/24/Trie/"/>
    <id>http://Persuingsdu.github.io/2017/12/24/Trie/</id>
    <published>2017-12-24T07:12:34.000Z</published>
    <updated>2017-12-29T09:01:48.036Z</updated>
    
    <content type="html"><![CDATA[<p><strong>字典樹</strong><br><a id="more"></a><br>學習了一下字典樹的簡單實現方式<br><a href="http://blog.csdn.net/sunnyyoona/article/details/43900425" target="_blank" rel="external">Reference</a><br><strong>节点的定义</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn 26</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> &#123;</span></div><div class="line"><span class="keyword">int</span> count;<span class="comment">//以该节点为结尾的单词的个数</span></div><div class="line">trieNode* next[Maxn];</div><div class="line">trieNode(<span class="keyword">int</span> x) &#123;</div><div class="line">count = x;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; i++)</div><div class="line">next[i] = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>在字典中插入新的字符串</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(trieNode* &amp;root, <span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">trieNode* p = root;<span class="comment">//根节点</span></div><div class="line"><span class="comment">//一个一个字符插入</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;<span class="comment">//26个字母中的位置</span></div><div class="line"><span class="keyword">if</span> (p-&gt;next[index]==<span class="literal">NULL</span>) </div><div class="line">p-&gt;next[index] = <span class="keyword">new</span> trieNode(<span class="number">0</span>);<span class="comment">//创建</span></div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line"><span class="comment">//以该字符为结尾的单词</span></div><div class="line">p-&gt;count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>刪除字典中的元素</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(trieNode* &amp;root, <span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">trieNode* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span>;</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line">p-&gt;count--;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>查找字典中是否存在某個字符串</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(trieNode* root, <span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line">trieNode *p = root;</div><div class="line"><span class="keyword">int</span> index;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;</div><div class="line"><span class="comment">// 无法转移到下一个字符</span></div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;<span class="comment">//if</span></div><div class="line"> <span class="comment">// 继续下一个字符</span></div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> p-&gt;count &gt; <span class="number">0</span>;<span class="comment">//是否有</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>遍曆輸出整個字典</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//利用递归程序查询整个字典</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDic</span><span class="params">(trieNode* root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;word)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (root-&gt;count &gt; <span class="number">0</span>) &#123;</div><div class="line">words.push_back(word);</div><div class="line">&#125;<span class="comment">//到了根且有值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</div><div class="line"><span class="keyword">if</span> (root-&gt;next[i]) &#123;<span class="comment">//26个循环</span></div><div class="line">word.push_back(<span class="string">'a'</span> + i);</div><div class="line">printDic(root-&gt;next[i], words, word);</div><div class="line">word.pop_back();<span class="comment">//回溯</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>LeetCode上的相關題目</strong><br><a href="https://leetcode.com/problems/map-sum-pairs/description/" target="_blank" rel="external">一.題目鏈接</a><br>使用字典樹的解法<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn 26</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></div><div class="line"><span class="keyword">int</span> count;</div><div class="line"><span class="keyword">int</span> value;</div><div class="line">node* next[Maxn];</div><div class="line">node(<span class="keyword">int</span> x) &#123;</div><div class="line">count = x;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; i++)</div><div class="line">next[i] = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    MapSum() &#123;</div><div class="line">root = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = key.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">node* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = key[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line">p-&gt;next[index] = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line">p-&gt;count++;</div><div class="line">p-&gt;value = val;</div><div class="line">&#125;</div><div class="line"><span class="function">node* <span class="title">help</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = prefix.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">node* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = prefix[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> p;<span class="comment">//有该前缀</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span>&amp; res)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="comment">//空</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span> (root-&gt;count &gt; <span class="number">0</span>)</div><div class="line">res += root-&gt;value;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; i++)</div><div class="line"><span class="keyword">if</span> (root-&gt;next[i])</div><div class="line">search(root-&gt;next[i], res);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">node* current = help(prefix);</div><div class="line">search(current,res);</div><div class="line"><span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">node* root;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><a href="https://leetcode.com/problems/replace-words/description/" target="_blank" rel="external">二.題目鏈接</a><br><img src="/img/leetcode.png" alt="Runtime"><br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 26</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></div><div class="line"><span class="keyword">int</span> count;</div><div class="line">node* next[maxn];</div><div class="line">node(<span class="keyword">int</span> x) &#123;</div><div class="line">count = x;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</div><div class="line">next[i] = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* root,<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line"><span class="keyword">int</span> size = str.size();</div><div class="line"><span class="keyword">int</span> index;</div><div class="line">node* p = root;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">index = str[i] - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line">p-&gt;next[index] = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line">p = p-&gt;next[index];</div><div class="line">&#125;</div><div class="line">p-&gt;count++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(node* &amp;root, <span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> index = c - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (root-&gt;next[index] == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在</span></div><div class="line">root = root-&gt;next[index];</div><div class="line"><span class="keyword">if</span> (root-&gt;count &gt; <span class="number">0</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//存在</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//可能存在</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict, <span class="built_in">string</span> sentence)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = dict.size();</div><div class="line">node* root = <span class="keyword">new</span> node(<span class="number">0</span>);</div><div class="line"><span class="built_in">string</span> res = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">insert(root, dict[i]);</div><div class="line"><span class="keyword">int</span> keysize = sentence.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; keysize; ) &#123;</div><div class="line">node* p = root;</div><div class="line"><span class="built_in">string</span> element = <span class="string">""</span>;</div><div class="line"><span class="keyword">bool</span> tag = <span class="literal">false</span>;</div><div class="line"><span class="keyword">while</span> (j &lt; keysize &amp;&amp; sentence[j] != <span class="string">' '</span>) &#123;</div><div class="line">element += sentence[j];</div><div class="line"><span class="keyword">int</span> com = search(p, sentence[j]);</div><div class="line"><span class="keyword">if</span> (com==<span class="number">-1</span>) &#123;</div><div class="line">j++;</div><div class="line"><span class="keyword">while</span> (j&lt;keysize &amp;&amp; sentence[j] != <span class="string">' '</span>) &#123;</div><div class="line">element += sentence[j];</div><div class="line">j++;</div><div class="line">&#125;</div><div class="line">res += element;</div><div class="line">res += <span class="string">" "</span>;</div><div class="line">tag = <span class="literal">true</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (com == <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//do noing</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (com == <span class="number">1</span>) &#123;</div><div class="line">res += element;</div><div class="line">res += <span class="string">" "</span>;</div><div class="line">tag = <span class="literal">true</span>;</div><div class="line"><span class="keyword">while</span> (j&lt;keysize &amp;&amp; sentence[j] != <span class="string">' '</span>)</div><div class="line">j++;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">j++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!tag) &#123;</div><div class="line">res += element;</div><div class="line">res += <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line">j++;</div><div class="line">&#125;</div><div class="line">res.pop_back();</div><div class="line"><span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;字典樹&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://Persuingsdu.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://Persuingsdu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
