{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"document","date":"2018-01-20T06:05:27.000Z","updated":"2018-01-20T06:05:27.285Z","comments":true,"path":"document/index.html","permalink":"http://Persuingsdu.github.io/document/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Trie","slug":"Trie","date":"2017-12-24T07:12:34.000Z","updated":"2017-12-29T09:01:48.036Z","comments":true,"path":"2017/12/24/Trie/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Trie/","excerpt":"字典樹","text":"字典樹學習了一下字典樹的簡單實現方式Reference节点的定义#define Maxn 26struct trieNode &#123; int count;//以该节点为结尾的单词的个数 trieNode* next[Maxn]; trieNode(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;; 在字典中插入新的字符串void insert(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root;//根节点 //一个一个字符插入 for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a';//26个字母中的位置 if (p-&gt;next[index]==NULL) p-&gt;next[index] = new trieNode(0);//创建 p = p-&gt;next[index]; &#125; //以该字符为结尾的单词 p-&gt;count++;&#125; 刪除字典中的元素void del(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) return; p = p-&gt;next[index]; &#125; p-&gt;count--;&#125; 查找字典中是否存在某個字符串bool search(trieNode* root, string str) &#123; if (root == NULL) &#123; return false; &#125; int size = str.size(); trieNode *p = root; int index; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; // 无法转移到下一个字符 if (p-&gt;next[index] == NULL) &#123; return false; &#125;//if // 继续下一个字符 p = p-&gt;next[index]; &#125; return p-&gt;count &gt; 0;//是否有&#125; 遍曆輸出整個字典//利用递归程序查询整个字典void printDic(trieNode* root, vector&lt;vector&lt;char&gt;&gt; &amp;words, vector&lt;char&gt; &amp;word) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;count &gt; 0) &#123; words.push_back(word); &#125;//到了根且有值 for (int i = 0; i &lt; 26; ++i) &#123; if (root-&gt;next[i]) &#123;//26个循环 word.push_back('a' + i); printDic(root-&gt;next[i], words, word); word.pop_back();//回溯 &#125; &#125;&#125; LeetCode上的相關題目一.題目鏈接使用字典樹的解法#define Maxn 26struct node &#123; int count; int value; node* next[Maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;;class MapSum &#123;public: /** Initialize your data structure here. */ MapSum() &#123; root = new node(0); &#125; void insert(string key, int val) &#123; int size = key.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = key[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++; p-&gt;value = val; &#125; node* help(string prefix) &#123; int size = prefix.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = prefix[i] - 'a'; if (p-&gt;next[index] == NULL) return NULL; p = p-&gt;next[index]; &#125; return p;//有该前缀 &#125; void search(node* root,int&amp; res) &#123; if (root == NULL)//空 return; if (root-&gt;count &gt; 0) res += root-&gt;value; for (int i = 0; i &lt; Maxn; i++) if (root-&gt;next[i]) search(root-&gt;next[i], res); &#125; int sum(string prefix) &#123; int res = 0; node* current = help(prefix); search(current,res); return res; &#125;private: node* root;&#125;; 二.題目鏈接#define maxn 26struct node &#123; int count; node* next[maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; maxn; i++) next[i] = NULL; &#125;&#125;;void insert(node* root,string str)&#123; int size = str.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++;&#125;int search(node* &amp;root, char c) &#123; if (root == NULL) &#123; return -1; &#125; int index = c - 'a'; if (root-&gt;next[index] == NULL) return -1;//不存在 root = root-&gt;next[index]; if (root-&gt;count &gt; 0) return 1;//存在 return 0;//可能存在&#125;string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) &#123; int size = dict.size(); node* root = new node(0); string res = \"\"; for (int i = 0; i &lt; size; i++) insert(root, dict[i]); int keysize = sentence.size(); for (int j = 0; j &lt; keysize; ) &#123; node* p = root; string element = \"\"; bool tag = false; while (j &lt; keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; int com = search(p, sentence[j]); if (com==-1) &#123; j++; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; j++; &#125; res += element; res += \" \"; tag = true; break; &#125; if (com == 0) &#123; //do noing &#125; if (com == 1) &#123; res += element; res += \" \"; tag = true; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') j++; break; &#125; j++; &#125; if (!tag) &#123; res += element; res += \" \"; &#125; j++; &#125; res.pop_back(); return res;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]}]}