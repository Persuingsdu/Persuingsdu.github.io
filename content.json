{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"document","date":"2018-01-20T06:05:27.000Z","updated":"2018-01-20T06:05:27.285Z","comments":true,"path":"document/index.html","permalink":"http://Persuingsdu.github.io/document/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"KMP","slug":"KMP","date":"2017-12-29T06:21:36.000Z","updated":"2017-12-29T08:59:56.113Z","comments":true,"path":"2017/12/29/KMP/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/29/KMP/","excerpt":"字符串問題","text":"字符串問題參考鏈接讀書筆記，大致了解一下。KMP算法的關鍵在于求出next數組，next數組考慮的是除當前字符外的最長相同的前綴和後綴。next數組告訴我們，當模式串中的某個字符跟文本串中的某個字符匹配失配時，模式串下一步應該跳到哪個位置。注意前綴不包含最後一個元素，後綴不包含第一個元素。失配時，模式串向右移動的位數為：失配字符所在位置 - 失配字符對應的next值。問題的關鍵在于如何計算出next數組。遞推計算出next數組void getNext(string p, vector&lt;int&gt;&amp; next) &#123; int size = p.size(); next[0] = -1; int k = -1; int j = 0; while (j &lt; size - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; if (p[j] != p[k]) next[j] = k; else next[j] = next[k]; &#125; else k = next[k]; &#125;&#125; 基于next數組的字符串匹配int KmpSearch(string s, string p,vector&lt;int&gt;&amp; next) &#123; int i = 0; int j = 0; int sLen = s.size(); int pLen = p.size(); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 //移动 j = next[j]; &#125; if (j == pLen) return i - j; else return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/tags/算法/"}]}]}