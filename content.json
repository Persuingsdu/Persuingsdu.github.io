{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[],"posts":[{"title":"DFS","slug":"DFS","date":"2017-10-15T15:58:22.000Z","updated":"2017-10-15T16:00:38.194Z","comments":true,"path":"2017/10/15/DFS/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/15/DFS/","excerpt":"这篇文章用来总结Leetcode上与dfs相关的题目，方法不是最佳，以后更新。因为不太会编写递归程序，故今天在leetcode上，做了三道和dfs的题目，均利用递归解决，总结如下：","text":"这篇文章用来总结Leetcode上与dfs相关的题目，方法不是最佳，以后更新。因为不太会编写递归程序，故今天在leetcode上，做了三道和dfs的题目，均利用递归解决，总结如下：与树相关的struct结构，如下定义struct TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; Path Sumlinkbool ans;bool hasPathSum(TreeNode* root, int sum) { if (root == NULL) return false; if (root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) { if (sum==root-&gt;val) return true; else return false; } if (root-&gt;left != NULL) ans = hasPathSum(root-&gt;left, sum - root-&gt;val); if(ans==true) return ans; if (root-&gt;right != NULL) ans = hasPathSum(root-&gt;right, sum - root-&gt;val); return ans;} Binary Tree Pathslink去掉了多余内容，只保留主要代码string ans = “”;vector s;//前提0-9void help(TreeNode* root) { ans += root-&gt;val + ‘0’; if (root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) { s.push_back(ans); ans.erase(ans.end() - 1); return; } if (root-&gt;left != NULL) help(root-&gt;left); if (root-&gt;right != NULL) help(root-&gt;right); ans.erase(ans.end() - 1);//回溯}","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"并查集","slug":"并查集","date":"2017-10-06T11:41:10.000Z","updated":"2017-10-06T12:29:26.316Z","comments":true,"path":"2017/10/06/并查集/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/06/并查集/","excerpt":"","text":"并查集路径压缩：每次查找时，令查找路径上的每个节点都直接指向根节点合并函数的性能改进：利用重量规则或者高度规则，具体代码见文章 带权并查集 定义两个数组fa和rank，fa用来判断集合关系，rank用来描述其与根节点的关系。因为关系满足传递性，所以可以推导出给出条件下的当前关系，再判断与之前已有关系是否矛盾。 例题：1.食物链2.Find them,Catch them","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://Persuingsdu.github.io/tags/并查集/"}]},{"title":"线段树基本操作(一)","slug":"线段树基本操作-一","date":"2017-10-05T14:44:10.000Z","updated":"2017-10-09T06:57:11.236Z","comments":true,"path":"2017/10/05/线段树基本操作-一/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/05/线段树基本操作-一/","excerpt":"国庆作业的需要，今晚学习了一下线段树的基本操作——建树,区间查询,单点更新后续学习区间更新及更多的知识,此处只放代码。主要参考此文章 数据结构——线段树","text":"国庆作业的需要，今晚学习了一下线段树的基本操作——建树,区间查询,单点更新后续学习区间更新及更多的知识,此处只放代码。主要参考此文章 数据结构——线段树 1.建树首先写一个函数,该函数用来更新父节点,指明父节点与左子树与右子树的关系void pushup(int i) { segTree[i] = max(segTree[2 i],segTree[2 i + 1]);}这里面的关系是可以自定义,可以进行求和,求最小值等等操作,这里选择了最大值作为示例//利用递归建树void build(int i, int l, int r) { if (l == r) segTree[i] = value[l]; else { //递归构造左右子树 build(2 i, l, (l + r) / 2); build(2 i + 1, (l + r) / 2 + 1, r); pushup(i);//回溯更新父节点 }} 2.区间查询i代表查询的结点,(b,e)代表该结点的范围,(l,r)代表查询结点的范围注意该函数的return值要与pushup更新父节点的目的匹配,此处就是返回该区间的最大值int query(int i, int b, int e, int l, int r) { int p1, p2; if (l &gt; e||r &lt; b) return INT_MIN; //无交集 if (b &gt;= l&amp;&amp;e &lt;= r) return segTree[i]; //需要查询的区间大于i存储的区间 p1 = query(2 i, b, (b + e) / 2, l, r); p2 = query(2 i + 1, (b + e) / 2 + 1, e, l, r); return max(p1, p2);} 3.单节点更新i代表结点,(b,e)代表该节点的范围,p代表我们要更新的结点位置,v代表要递增的数值void update_single(int i, int b, int e, int p, int v) { if (b == e) { segTree[i] += v; return; } int m = (b + e) / 2; if (p &lt;= m) update_single(2 i, b, m, p, v); else update_single(2 i + 1, m + 1, e, p, v); pushup(i);//回溯更新}特别注意,在实际用中,空间要开4*N 调试代码const int maxn = 256;int segTree[4 maxn + 10];int value[maxn];int main() { //开的空间为4N value[0] = 1; value[1] = 2; value[2] = 2; value[3] = 4; value[4] = 9; value[5] = 3; build(1, 0, 5); for (int i = 1; i &lt;= 20; i++) cout &lt;&lt; “seg “ &lt;&lt; i &lt;&lt; “=” &lt;&lt; segTree[i] &lt;&lt; endl; //我们定义pushup得到的最终结果便是segTree[1] update_single(1, 0, 5, 3, 8); query(1, 0, 5, 2, 4);} 2017/10/9 于图书馆更新例题 Potted Flowerconst int maxn = 100010;struct node { int sum, maxNow, minNow; int lmax, lmin; int rmax, rmin; int left, right;} T[4 maxn];int value[maxn];int n, m;//点数，修改次数void pushup(int i) { T[i].sum = T[2 i].sum + T[2 i + 1].sum; T[i].lmax = max(T[2 i].lmax, T[2 i].sum + T[2 i + 1].lmax); T[i].lmin = min(T[2 i].lmin, T[2 i].sum + T[2 i + 1].lmin); T[i].rmax = max(T[2 i + 1].rmax, T[2 i + 1].sum + T[2 i].rmax); T[i].rmin = min(T[2 i + 1].rmin, T[2 i + 1].sum + T[2 i].rmin); T[i].maxNow = max(max(T[2 i].maxNow, T[2 i + 1].maxNow), T[2 i].rmax + T[2 i + 1].lmax); T[i].minNow = min(min(T[2 i].minNow, T[2 i + 1].minNow), T[2 i].rmin + T[2 i + 1].lmin);}void build(int i, int l, int r) { T[i].left = l; T[i].right = r; if (l == r) {//叶子结点，将所有数据初始化为data[end],也就是线段树的元线段 T[i].sum = T[i].lmax = T[i].lmin = T[i].rmax = T[i].rmin = T[i].maxNow = T[i].minNow = value[l]; } else {//左右递归进行建树 int mid = (l + r) &gt;&gt; 1; build(2 i, l, mid); build(2 i + 1, mid+1, r); pushup(i); }}//i代表线段树中的节点,k代表要更新的数字的position,v代表valuevoid update_single(int i,int k,int v) { if (T[i].left == T[i].right) {//更新叶子结点 T[i].sum = T[i].lmax = T[i].lmin = T[i].rmax = T[i].rmin = T[i].maxNow = T[i].minNow = v; return; } int mid = (T[i].left + T[i].right) &gt;&gt; 1; if (k &lt;= mid) update_single(2 i, k, v); else update_single(2 * i + 1, k, v); pushup(i);//注意更新线段树}int main() { int ans, k, v; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) scanf_s(“%d”, &amp;value[i]); build(1, 1, n); cin &gt;&gt; m; while (m–) { cin &gt;&gt; k &gt;&gt; v; update_single(1, k, v); if (T[1].sum == T[1].maxNow) ans = T[1].sum - T[1].minNow; else ans = max(T[1].maxNow, T[1].sum - T[1].minNow); cout &lt;&lt; ans &lt;&lt; endl; }}","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"},{"name":"ACM","slug":"ACM","permalink":"http://Persuingsdu.github.io/tags/ACM/"},{"name":"线段树","slug":"线段树","permalink":"http://Persuingsdu.github.io/tags/线段树/"}]},{"title":"关于郑州的记忆","slug":"关于郑州的记忆","date":"2017-10-05T07:33:33.000Z","updated":"2017-10-05T07:55:19.127Z","comments":true,"path":"2017/10/05/关于郑州的记忆/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/05/关于郑州的记忆/","excerpt":"","text":"关于郑州的记忆关于郑州我知道的不多，为了爱情曾经去过那里多少次在火车上路过这城市，一个人悄悄地想起她她说她喜欢郑州冬天的阳光，巷子里飘满煤炉的味道雾气穿过她年轻的脖子，直到今天都没有散去关于郑州我想的全是你，想来想去都是忏悔和委屈关于郑州我爱的全是你，爱来爱去不明白爱的意义关于郑州只是偶尔想起，现在她的味道都在回忆里每次和朋友说起过去的旅行，我不敢说我曾去过那里关于郑州我想的全是你，想来生活无非是痛苦和美丽关于郑州我爱的全是你，爱到最后我们都无路可去似是而非或是世事可畏，有情有义又是有米无炊时间改变了很多又什么都没有让我再一次拥抱你，郑州","categories":[],"tags":[{"name":"伪文艺","slug":"伪文艺","permalink":"http://Persuingsdu.github.io/tags/伪文艺/"}]},{"title":"My first blog","slug":"My-first-blog","date":"2017-10-04T14:00:56.000Z","updated":"2017-10-04T14:01:55.612Z","comments":true,"path":"2017/10/04/My-first-blog/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/04/My-first-blog/","excerpt":"","text":"今天是中秋节，个人的小博客终于搭建起来了😊！","categories":[],"tags":[{"name":"生活杂感","slug":"生活杂感","permalink":"http://Persuingsdu.github.io/tags/生活杂感/"}]}]}