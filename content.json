{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"document","date":"2018-01-20T06:05:27.000Z","updated":"2018-01-20T06:05:27.285Z","comments":true,"path":"document/index.html","permalink":"http://Persuingsdu.github.io/document/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"引用类型","slug":"引用类型","date":"2018-01-31T14:50:30.000Z","updated":"2018-02-02T13:32:40.716Z","comments":true,"path":"2018/01/31/引用类型/","link":"","permalink":"http://Persuingsdu.github.io/2018/01/31/引用类型/","excerpt":"","text":"引用类型引用类型的值（对象）是引用类型的一个实例。引用类型有时候也被称为对象定义，因为它们描述的是一类对象具有的属性和方法；新对象是使用new操作符和一个构造函数来创建。 Object类型创建Object实例的方法：1.使用new操作符后跟Object构造函数var person = new Object();person.name = \"Nicholas\";person.age = 29; 2.使用对象字面量表示方法var person = &#123;name:\"Nicolas\",age:29&#125; var person=&#123;&#125;;//与new Object()相同person.name=\"Nicholas\";person.age=29; 开发人员更青睐于使用对象字面量语法，因为语法要求的代码量少，并且有封装数据的感觉，同时，也是向函数传递大量可选参数的首选方式，例如：function displayInfo(args)&#123; var output=\"\"; if(typeof args.name==\"string\")&#123; output+=\"Name:\"+args.name+\"\\n\"; &#125; if(typeof args.age==\"number\")&#123; output+=\"Age:\"+args.age+\"\\n\"; &#125; console.log(output);&#125;displayInfo(&#123;name:\"Nicholas\",age:29&#125;);displayInfo(&#123;name:\"Grey\"&#125;); Array类型创建数组的基本方式var colors=new Array();var colors=new Array(20);var colors=new Arry(\"red\",\"green\",\"blue\"); 第二种使用数组字面量表示法var colors=[\"red\",\"green\",\"blue\"];var names=[];//创建一个空数组 可以通过索引来访问元素，如果设置某个值的索引超过了该数组的现有项数，数组就会自动添加到该索引的值加1var colors=[\"red\",\"green\",\"blue\"];colors[99]=\"black\";alert(colors.length);//100//数组大小为100，位置3-98实际上是不存在的，所有访问它们，都将返回undefined 另外，可以通过修改数组的length属性，可以从数组的末尾移除项或者向数组中添加新项；var colors=[\"red\",\"green\",\"blue\"];colors.length=2;alert(colors[2]);//undefined 检测数组if(Array.isArray(value))确定某个对象是不是数组栈方法ECMAScript专门提供了push()和pop()方法，以便实现类似栈的行为。push()方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后的数组的长度。var colors=new Array();var count=colors.push(\"red\",\"green\");//2 pop()方法var item=colors.pop();//item=\"green\" 队列方法shift()移除数组中的第一项并且返回该项，同时数组的长度减1。unshift()可以在数组的前端添加任意个项并返回新数组的长度。重排序方法reverse()反转数组项的顺序sort()会调用每个数据项的toString()方法，然后比较字符串来排序，即便是数组中的每一项都是数值。利用比较函数排序function compare(value1,value2)&#123; return value1-value2;&#125;var values=[0,1,5,10,15];values.sort();//0,1,10,15,5values.sort(compare);//15,10,5,1,0 操作方法concat()var colors=[\"red\",\"green\",\"blue\"];var colors2=colors.concat(\"yello\",[\"black\",\"brown\"]); slice()方法接受一个参数或者两个参数，接受一个参数，返回该位置到数组末尾的所有项。两个参数，返回起始位置和结束位置之间的项，但不包括结束项。splice()1.删除：指定两个参数，第一项的位置和要删除的项数。splice(0,2)2.插入：指定三个参数，起始位置，0，要插入的项splice(0,2,&quot;red&quot;,&quot;green&quot;)3.替换：指定三个参数，起始位置，要删除的项数，要插入的任意数量的项。splice(2,1,&quot;red&quot;,&quot;greem)位置方法indexOf()和lastIndexOf()接受两个参数：要查找的项和（可选的）表示查找起点位置索引。迭代方法每个方法接受2个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象。传入这些方法中的函数会接受三个参数：数据项的值，该项在数组中的位置和数组对象本身。1.every()每一项都返回true，返回true。2.filter()返回函数会返回true的项组成的数组。3.forEach()无返回值。4.map()对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。5.some()如果函数的任一项返回true，则返回true。every()var numbers=[1,2,3,4,5,4,3,2,1];var everyResult=numbers.every(function(item,index,array)&#123; return(item&gt;2);&#125;);//falsevar someResult=numbers.some(function(item,index,array)&#123; return(item&gt;2);&#125;);//truevar filterResult=numbers.filter(function(item,index,array)&#123; return(item&gt;2);&#125;);//3,4,5,4,3var mapResult=numbers.map(function(item,index,array)&#123; return item*2;&#125;);//2,4,6,8,10,8,6,4,2 归并方法两个归并数组的方法reduce()和reduceRight,这两个方法都会迭代数组的所有项，然后构建一个最终的返回值。这两个方法接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。其中函数接受四个参数：前一个值，当前值，项的索引，数组对象。var value=[1,2,3,4,5];var sum=value.reduce(function(pre,cur,index,array)&#123; return pre+cur;&#125;); Date类型创建日期对象var now=new Date(); RegExp类型 !正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 Function类型函数是对象，函数名是指针。function sum(num1,num2)&#123; return num1+num2;&#125;//函数声明var sum=function(num1,num2)&#123; return num1+num2;&#125;;//函数表达式 一个函数可能有多个名字function sum(num1,num2)&#123; return num1+num2;&#125;alert(sum(10,10);//20var anotherSum=sum;sum=null;alert(anotherSum(10,10));//20 没有重载作为值的函数将一个函数像传递参数一样传递给另一个函数。也可以作为一个函数的结果返回：function createComparisonFunction(propertyName)&#123; return function(object1,object2)&#123; var value1=object1[propertyName]; var value2=object2[propertyName]; if(value1&gt;value2)&#123; return -1; &#125;else if(value1&lt;value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;;&#125;var data=[&#123;name:\"Zachary\",age:28&#125;,&#123;name:\"Nicholas\",age:29&#125;];data.sort(createComparisonFunction(\"name\"));//data[0].name=Nicholasdata.sort(createComparisonFunction(\"age\"));//data[0].name=Zachary 函数属性和方法apply()和call()用途为在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply()接受两个参数：1.运行函数的作用域 2.参数数组（可以是Array实例或者是argument对象）call()传递给函数的参数必须逐个列举出来。事实上，它们真正强大的地方在于扩充函数赖以运行的作用域。window.color=\"red\";var o=&#123;color:\"blue\"&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor.call(this);//redsayColor.call(o);//bluesayColor.call(window);//red 基本包装类型为了便于操作基本类型值，ECMAScript还提供了三个特殊的引用类型Boolean，Number,String。引用类型和基本包装类型的主要区别就是对象的生存周期。var s1=\"some text\";s1.color=\"red\";alert(s1.color);//undefined String类型创建String对象var stringObject=new String(&quot;hello world&quot;);1.字符方法charAt(),charCodeAt()2.字符串操作方法concat()(实践中更多使用+)slice()和substring()根据start和end的值，截取子串，只有一个参数，默认end为结尾。substr()根据start和numbers的值，截取字串，只有一个参数，默认截取到字符串尾部。3.字符串位置方法indexOf()和lastIndexOf(),接受一个参数，表示起始搜索点。4.trim()方法删除前置和后缀的所有空格。5.字符串大小写转换方法toLowerCase()和toUpperCase()6.字符串模式匹配match()接受一个参数：要么是一个正则表达式，要么是一个RegExp对象。search()唯一的参数与match()相同，返回字符串中第一个匹配项的索引。replace()第一个参数可以是字符串或者是一个RegExp对象，第二个参数可以是一个字符串或者一个函数。split()基于指定的分隔符将一个字符串分割成多个字串，并将结果放在一个数组中。7.localCompare()方法这个方法比较两个字符串。var stringValue=\"yellow\";consloe.log(stringValue.localeCompare(\"brick\"));//1console.log(stringValue.localeCompare(\"yellow\"));//0console.log(stringValue.localeCompare(\"zoo\"));//-1","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://Persuingsdu.github.io/tags/JavaScript/"}]},{"title":"","slug":"随笔”","date":"2018-01-26T15:53:23.000Z","updated":"2018-01-26T16:24:06.970Z","comments":true,"path":"2018/01/26/随笔”/","link":"","permalink":"http://Persuingsdu.github.io/2018/01/26/随笔”/","excerpt":"","text":"我住的城市从不下雪记忆却堆满冷的感觉思念的旺季霓虹扫过喧哗的街把快乐赶得好远落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞它陪我过夜Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞它陪我过夜Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑电话不接不要被人发现我整夜都关在房间狂欢的笑声听来像哀悼的音乐眼眶的泪 温热冻结望着电视里的无聊节目躺在沙发上变成没知觉的植物Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑Merry christmasMerry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑谁来陪我过这圣诞节","categories":[],"tags":[]},{"title":"Trie","slug":"Trie","date":"2017-12-24T07:12:34.000Z","updated":"2017-12-29T09:01:48.036Z","comments":true,"path":"2017/12/24/Trie/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Trie/","excerpt":"字典樹","text":"字典樹學習了一下字典樹的簡單實現方式Reference节点的定义#define Maxn 26struct trieNode &#123; int count;//以该节点为结尾的单词的个数 trieNode* next[Maxn]; trieNode(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;; 在字典中插入新的字符串void insert(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root;//根节点 //一个一个字符插入 for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a';//26个字母中的位置 if (p-&gt;next[index]==NULL) p-&gt;next[index] = new trieNode(0);//创建 p = p-&gt;next[index]; &#125; //以该字符为结尾的单词 p-&gt;count++;&#125; 刪除字典中的元素void del(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) return; p = p-&gt;next[index]; &#125; p-&gt;count--;&#125; 查找字典中是否存在某個字符串bool search(trieNode* root, string str) &#123; if (root == NULL) &#123; return false; &#125; int size = str.size(); trieNode *p = root; int index; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; // 无法转移到下一个字符 if (p-&gt;next[index] == NULL) &#123; return false; &#125;//if // 继续下一个字符 p = p-&gt;next[index]; &#125; return p-&gt;count &gt; 0;//是否有&#125; 遍曆輸出整個字典//利用递归程序查询整个字典void printDic(trieNode* root, vector&lt;vector&lt;char&gt;&gt; &amp;words, vector&lt;char&gt; &amp;word) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;count &gt; 0) &#123; words.push_back(word); &#125;//到了根且有值 for (int i = 0; i &lt; 26; ++i) &#123; if (root-&gt;next[i]) &#123;//26个循环 word.push_back('a' + i); printDic(root-&gt;next[i], words, word); word.pop_back();//回溯 &#125; &#125;&#125; LeetCode上的相關題目一.題目鏈接使用字典樹的解法#define Maxn 26struct node &#123; int count; int value; node* next[Maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;;class MapSum &#123;public: /** Initialize your data structure here. */ MapSum() &#123; root = new node(0); &#125; void insert(string key, int val) &#123; int size = key.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = key[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++; p-&gt;value = val; &#125; node* help(string prefix) &#123; int size = prefix.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = prefix[i] - 'a'; if (p-&gt;next[index] == NULL) return NULL; p = p-&gt;next[index]; &#125; return p;//有该前缀 &#125; void search(node* root,int&amp; res) &#123; if (root == NULL)//空 return; if (root-&gt;count &gt; 0) res += root-&gt;value; for (int i = 0; i &lt; Maxn; i++) if (root-&gt;next[i]) search(root-&gt;next[i], res); &#125; int sum(string prefix) &#123; int res = 0; node* current = help(prefix); search(current,res); return res; &#125;private: node* root;&#125;; 二.題目鏈接#define maxn 26struct node &#123; int count; node* next[maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; maxn; i++) next[i] = NULL; &#125;&#125;;void insert(node* root,string str)&#123; int size = str.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++;&#125;int search(node* &amp;root, char c) &#123; if (root == NULL) &#123; return -1; &#125; int index = c - 'a'; if (root-&gt;next[index] == NULL) return -1;//不存在 root = root-&gt;next[index]; if (root-&gt;count &gt; 0) return 1;//存在 return 0;//可能存在&#125;string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) &#123; int size = dict.size(); node* root = new node(0); string res = \"\"; for (int i = 0; i &lt; size; i++) insert(root, dict[i]); int keysize = sentence.size(); for (int j = 0; j &lt; keysize; ) &#123; node* p = root; string element = \"\"; bool tag = false; while (j &lt; keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; int com = search(p, sentence[j]); if (com==-1) &#123; j++; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; j++; &#125; res += element; res += \" \"; tag = true; break; &#125; if (com == 0) &#123; //do noing &#125; if (com == 1) &#123; res += element; res += \" \"; tag = true; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') j++; break; &#125; j++; &#125; if (!tag) &#123; res += element; res += \" \"; &#125; j++; &#125; res.pop_back(); return res;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]}]}