{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"About","date":"2017-12-31T05:11:17.057Z","updated":"2017-12-31T05:11:17.057Z","comments":true,"path":"about/index.html","permalink":"http://Persuingsdu.github.io/about/index.html","excerpt":"","text":"ä¸€å€‹å°ç™½ï¼Œæ­£åœ¨å­¸ç¿’ä¹‹ä¸­é€™æ˜¯ä¸€å€‹è‡ªè¨€è‡ªèªçš„åœ°æ–¹è¯ç³»ï¼šå¾®ä¿¡ amastaciaQQ 1169284282"},{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Board","date":"2017-12-30T13:24:17.000Z","updated":"2017-12-30T13:38:08.630Z","comments":true,"path":"board/index.html","permalink":"http://Persuingsdu.github.io/board/index.html","excerpt":"","text":"æ¬¢è¿å¤§å®¶çš„åˆ°è®¿ğŸ˜Š"},{"title":"Photo","date":"2017-12-29T09:22:50.000Z","updated":"2017-12-31T05:09:55.278Z","comments":true,"path":"photo/index.html","permalink":"http://Persuingsdu.github.io/photo/index.html","excerpt":"","text":"é€™æ˜¯ä¸€å€‹å‡çš„å¯¦ç¾ç›¸å†Šçš„åŠŸèƒ½ï¼Œç¾åœ¨é‚„ä¸æœƒï¼Œå­¸äº†å‰ç«¯å†èªªï¼ˆä½†é¡˜èƒ½å­¸æœƒ å›¾é›†"},{"title":"Photo","date":"2017-12-29T09:22:50.000Z","updated":"2017-12-31T05:00:15.597Z","comments":true,"path":"photo/æµ·è¾¹æ¸”æ‘.html","permalink":"http://Persuingsdu.github.io/photo/æµ·è¾¹æ¸”æ‘.html","excerpt":"","text":"é€™æ˜¯ä¸€å€‹å‡çš„å¯¦ç¾ç›¸å†Šçš„åŠŸèƒ½ï¼Œç¾åœ¨é‚„ä¸æœƒï¼Œå­¸äº†å‰ç«¯å†èªªï¼ˆä½†é¡˜èƒ½å­¸æœƒ"},{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""},{"title":"Sea","date":"2017-12-31T04:49:58.000Z","updated":"2017-12-31T05:12:43.518Z","comments":true,"path":"photo/Sea/index.html","permalink":"http://Persuingsdu.github.io/photo/Sea/index.html","excerpt":"","text":"æ°´æ·±å±é™© æµ·è¾¹å°å–éƒ¨ æ¸”èˆ¹"}],"posts":[{"title":"å²æœ«","slug":"å²æœ«","date":"2017-12-30T10:40:16.000Z","updated":"2017-12-31T04:32:56.188Z","comments":true,"path":"2017/12/30/å²æœ«/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/30/å²æœ«/","excerpt":"","text":"ä»Šå¤©ä¸­åˆå»äº†ä¸€è¶Ÿæµ·é‚Šï¼Œä¸‹åˆçµ¦åšå®¢å¢åŠ äº†è©•è«–çš„åŠŸèƒ½ã€‚ä¸€é–‹å§‹ç”¨çš„æ˜¯Disqusï¼Œç„¶è€Œç¥–åœ‹çš„é«˜ç‰†å°è‡´ä¸é€šéç§‘å­¸ä¸Šç¶²çš„æ–¹å¼ï¼Œç„¡æ³•åŠ è¼‰å‡ºä¾†ï¼Œäºæ˜¯æ”¾æ£„ã€‚åˆç”¨äº†gitmentï¼Œç„¶è€Œï¼Œåªèƒ½é€šéGitHubç™»é™¸ï¼Œåˆæ”¾æ£„äº†ã€‚æœ€å¾Œé¸æ“‡äº†Hypercommentï¼Œå…è²»çš„Liteç‰ˆæœ¬ï¼Œæœ€çµ‚å¯¦ç¾äº†è©•è«–çš„åŠŸèƒ½ã€‚é¦¬ä¸Šä¸€å¹´åˆéå»äº†ï¼Œæ„Ÿè¦ºè‡ªå·±é‚„æ˜¯å¤ªæ°´äº†ï¼Œä¸‹é¢è¦å¥½å¥½åŠ æ²¹äº†ã€‚å‰›å‰›çœ‹åˆ°ä¸€å€‹å°å¤¥ä¼´çš„åšå®¢ï¼Œæ„Ÿè¦ºå¾ˆä¸éŒ¯å‘¢ã€‚","categories":[{"name":"ç”Ÿæ´»","slug":"ç”Ÿæ´»","permalink":"http://Persuingsdu.github.io/categories/ç”Ÿæ´»/"}],"tags":[]},{"title":"KMP","slug":"KMP","date":"2017-12-29T06:21:36.000Z","updated":"2017-12-29T08:59:56.113Z","comments":true,"path":"2017/12/29/KMP/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/29/KMP/","excerpt":"å­—ç¬¦ä¸²å•é¡Œ","text":"å­—ç¬¦ä¸²å•é¡Œåƒè€ƒéˆæ¥è®€æ›¸ç­†è¨˜ï¼Œå¤§è‡´äº†è§£ä¸€ä¸‹ã€‚KMPç®—æ³•çš„é—œéµåœ¨äºæ±‚å‡ºnextæ•¸çµ„ï¼Œnextæ•¸çµ„è€ƒæ…®çš„æ˜¯é™¤ç•¶å‰å­—ç¬¦å¤–çš„æœ€é•·ç›¸åŒçš„å‰ç¶´å’Œå¾Œç¶´ã€‚nextæ•¸çµ„å‘Šè¨´æˆ‘å€‘ï¼Œç•¶æ¨¡å¼ä¸²ä¸­çš„æŸå€‹å­—ç¬¦è·Ÿæ–‡æœ¬ä¸²ä¸­çš„æŸå€‹å­—ç¬¦åŒ¹é…å¤±é…æ™‚ï¼Œæ¨¡å¼ä¸²ä¸‹ä¸€æ­¥æ‡‰è©²è·³åˆ°å“ªå€‹ä½ç½®ã€‚æ³¨æ„å‰ç¶´ä¸åŒ…å«æœ€å¾Œä¸€å€‹å…ƒç´ ï¼Œå¾Œç¶´ä¸åŒ…å«ç¬¬ä¸€å€‹å…ƒç´ ã€‚å¤±é…æ™‚ï¼Œæ¨¡å¼ä¸²å‘å³ç§»å‹•çš„ä½æ•¸ç‚ºï¼šå¤±é…å­—ç¬¦æ‰€åœ¨ä½ç½® - å¤±é…å­—ç¬¦å°æ‡‰çš„nextå€¼ã€‚å•é¡Œçš„é—œéµåœ¨äºå¦‚ä½•è¨ˆç®—å‡ºnextæ•¸çµ„ã€‚éæ¨è¨ˆç®—å‡ºnextæ•¸çµ„void getNext(string p, vector&lt;int&gt;&amp; next) &#123; int size = p.size(); next[0] = -1; int k = -1; int j = 0; while (j &lt; size - 1) &#123; //p[k]è¡¨ç¤ºå‰ç¼€ï¼Œp[j]è¡¨ç¤ºåç¼€ if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; if (p[j] != p[k]) next[j] = k; else next[j] = next[k]; &#125; else k = next[k]; &#125;&#125; åŸºäºnextæ•¸çµ„çš„å­—ç¬¦ä¸²åŒ¹é…int KmpSearch(string s, string p,vector&lt;int&gt;&amp; next) &#123; int i = 0; int j = 0; int sLen = s.size(); int pLen = p.size(); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //â‘ å¦‚æœj = -1ï¼Œæˆ–è€…å½“å‰å­—ç¬¦åŒ¹é…æˆåŠŸï¼ˆå³S[i] == P[j]ï¼‰ï¼Œéƒ½ä»¤i++ï¼Œj++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else //â‘¡å¦‚æœj != -1ï¼Œä¸”å½“å‰å­—ç¬¦åŒ¹é…å¤±è´¥ï¼ˆå³S[i] != P[j]ï¼‰ï¼Œåˆ™ä»¤ i ä¸å˜ï¼Œj = next[j] //next[j]å³ä¸ºjæ‰€å¯¹åº”çš„nextå€¼ //ç§»åŠ¨ j = next[j]; &#125; if (j == pLen) return i - j; else return -1;&#125;","categories":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://Persuingsdu.github.io/categories/ç®—æ³•/"}],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://Persuingsdu.github.io/tags/ç®—æ³•/"}]},{"title":"Huffman","slug":"Hffuman","date":"2017-12-28T13:22:32.000Z","updated":"2017-12-30T11:10:08.480Z","comments":true,"path":"2017/12/28/Hffuman/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/28/Hffuman/","excerpt":"åˆ©ç”¨Stlä¸­çš„å„ªå…ˆéšŠåˆ—ï¼Œå¯¦ç¾Huffmanæ¨¹å’ŒHuffmanç·¨ç¢¼å•é¡Œ","text":"åˆ©ç”¨Stlä¸­çš„å„ªå…ˆéšŠåˆ—ï¼Œå¯¦ç¾Huffmanæ¨¹å’ŒHuffmanç·¨ç¢¼å•é¡Œæ¨¹çš„å®šç¾©#pragma once#include&lt;iostream&gt;using namespace std;struct treeNode &#123; int element; treeNode* leftChild; treeNode* rightChild; treeNode(const int&amp; theElement, treeNode* left, treeNode* right) &#123; element = theElement; leftChild = left; rightChild = right; &#125;&#125;;class linkedTree &#123;public: linkedTree() &#123; root = NULL; treeSize = 0; &#125; int size() &#123; return treeSize; &#125; treeNode* getRoot() &#123; return root; &#125; void makeTree(const int&amp; , linkedTree&amp;, linkedTree&amp;);private: treeNode* root; int treeSize;&#125;;//åˆå¹¶void linkedTree::makeTree(const int&amp; theElement, linkedTree&amp; left, linkedTree&amp; right) &#123; root = new treeNode(theElement, left.root, right.root);// this-&gt;treeSize = left.size + right.size + 1; left.root = right.root = NULL; left.treeSize = right.treeSize = 0;&#125; Huffmanç¯€é»çš„å®šç¾©ï¼šæ¯å€‹ç¯€é»éƒ½å«æœ‰æŒ‡å‘ä¸€å€‹æ¨¹çš„æŒ‡é‡å’Œæ¬Šå€¼,ä¸¦ä¸”å«æœ‰è‡ªå®šç¾©çš„æ¯”è¼ƒå‡½æ•¸ï¼Œä»¥æœŸåˆ©ç”¨å„ªå…ˆéšŠåˆ—struct huffmanNode &#123; linkedTree* tree;//æ ‘ int weight; huffmanNode() &#123;&#125;; huffmanNode(linkedTree* theTree, int theWeight) &#123; tree = theTree; weight = theWeight; &#125; friend bool operator &lt;(huffmanNode a, huffmanNode b) &#123; return a.weight &gt; b.weight; &#125;&#125;; æ§‹å»ºHuffmanæ¨¹linkedTree* huffmanTree(vector&lt;int&gt;&amp; weight) &#123; priority_queue&lt;huffmanNode&gt; p; int size = weight.size(); huffmanNode* hNode = new huffmanNode[size + 1];//æ•°ç»„ linkedTree emptyTree; for (int i = 1; i &lt;= size; i++) &#123; hNode[i].weight = weight[i - 1]; hNode[i].tree = new linkedTree();//å®ä½“åŒ–æ ‘ hNode[i].tree-&gt;makeTree(weight[i-1], emptyTree, emptyTree); p.push(hNode[i]); &#125; while (p.size() != 1) &#123; huffmanNode a = p.top(); p.pop(); huffmanNode b = p.top(); p.pop(); int newWeight = a.weight + b.weight; linkedTree* newTree = new linkedTree(); newTree-&gt;makeTree(newWeight, *a.tree, *b.tree); huffmanNode c(newTree, newWeight); p.push(c); &#125; return p.top().tree;&#125; å¯¦ç¾Huffmanç·¨ç¢¼void dfs(treeNode* root, vector&lt;int&gt;&amp; e, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (!root-&gt;leftChild &amp;&amp; !root-&gt;rightChild) &#123; e.push_back(root-&gt;element); res.push_back(e);//æ ‡æ˜å…ƒç´  e.pop_back(); &#125; if (root-&gt;leftChild) &#123; e.push_back(0); dfs(root-&gt;leftChild, e, res); &#125; if (root-&gt;rightChild) &#123; e.push_back(1); dfs(root-&gt;rightChild, e, res); &#125; if (!e.empty()) e.pop_back();//å›æº¯&#125;vector&lt;vector&lt;int&gt;&gt; huffmanCode(vector&lt;int&gt;&amp; weight) &#123; linkedTree* tree = huffmanTree(weight); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; e; dfs(tree-&gt;getRoot(), e, res); return res;&#125; æ¸¬è©¦æ•¸æ“šint main() &#123; vector&lt;int&gt; a = &#123; 5,4,3,2,1 &#125;; linkedTree* tree = huffmanTree(a); tree-&gt;dfsTravel(); cout &lt;&lt; endl; vector&lt;vector&lt;int&gt;&gt; res = huffmanCode(a); for (int i = 0; i &lt; res.size(); i++) &#123; for (int j = 0; j &lt; res[i].size(); j++) &#123; if (j == res[i].size() - 1) &#123; cout &lt;&lt; endl; cout &lt;&lt; \"å¯¹åº”çš„ç¼–ç ä¸º: \"; &#125; cout &lt;&lt; res[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125; Huffmanæ¨¹ 15 / \\6 9 / \\ / \\ 3 3 4 5 / \\ 1 2 çµæœè¼¸å‡º","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/categories/æ•°æ®ç»“æ„/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"Graph","slug":"Graph","date":"2017-12-27T04:58:44.000Z","updated":"2017-12-29T09:00:58.665Z","comments":true,"path":"2017/12/27/Graph/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/27/Graph/","excerpt":"åœ–","text":"åœ–ä¸€å€‹é€£é€šåœ–çš„ç”Ÿæˆæ¨¹æ˜¯æŒ‡ä¸€å€‹é€£é€šå­åœ–ï¼Œå®ƒå«æœ‰åœ–ä¸­å…¨éƒ¨nå€‹é ‚é»ï¼Œä½†åªæœ‰è¶³ä»¥æ§‹æˆä¸€æ£µæ¨¹çš„n-1æ¢é‚Šã€‚ä¸€é¡†æœ‰nå€‹é ‚é»çš„ç”Ÿæˆæ¨¹æœ‰ä¸”åƒ…æœ‰n-1æ¢é‚Šï¼Œå¦‚æœç”Ÿæˆæ¨¹ä¸­å†æ·»åŠ ä¸€æ¢é‚Šï¼Œå‰‡å¿…å®šæˆç’°ã€‚æœ€å°ç”Ÿæˆæ¨¹æ˜¯ä¸€å‰¯é€£é€šåŠ æ¬Šç„¡å‘åœ–ä¸­ä¸€æ£µæ¬Šå€¼æœ€å°çš„ç”Ÿæˆæ¨¹ã€‚å…ˆå¯«ä¸€é»ï¼Œå¾Œé¢æ…¢æ…¢æ›´æ–°ã€‚ä»£ç¢¼å’Œåƒè€ƒéˆæ¥ï¼Œæ…¢æ…¢å­¸ç¿’ã€‚å¯è¦–åŒ–å·¥å…·ä¸€äº›ç¯€é»çš„å®šç¾©#pragma once#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define INF 0xfffff//æƒå€¼çš„ä¸Šé™struct node &#123; node(int vertex, int weight, node* next) &#123; this-&gt;vertex = vertex; this-&gt;weight = weight; this-&gt;next = next; &#125; int vertex; int weight;//æƒå€¼ node* next;&#125;;struct head &#123; int data;//å‚¨å­˜å¤´ç»“ç‚¹ä¿¡æ¯ node* first;//ç¬¬ä¸€ä¸ªè¾¹&#125;;struct pNode &#123; int key; int v; friend bool operator&lt;(pNode a, pNode b) &#123; return a.key &gt; b.key;//æƒå€¼å°çš„ä¼˜å…ˆçº§é«˜ &#125;&#125;; é¡çš„å®šç¾©åŠæ–¹æ³•class wuGraph &#123;public: wuGraph(int vertex); int getVertex() &#123; return vertex; &#125; int getArc() &#123; return arc; &#125; void insert(int l, int r, int weight);//å¤´æ’æ³• void printGraph(); void dfs(int start); void dfsTravel(); void bfs(int start); void bfsTravel(); void minTree();private: head* graph; int vertex; int arc; bool* visited;&#125;;wuGraph::wuGraph(int theVertex) &#123; vertex = theVertex; visited = new bool[vertex + 1]; graph = new head[vertex + 1]; //1 - vertex for (int i = 1; i &lt;= vertex; i++) &#123; graph[i].data = i; graph[i].first = NULL; &#125; &#125;//æ’å…¥è¾¹void wuGraph::insert(int l, int r, int weight) &#123;//l - r -weight //l - r node* rNode = new node(r, weight, graph[l].first); graph[l].first = rNode; //r - l node* lNode = new node(l, weight, graph[r].first); graph[r].first = lNode; arc++;&#125;void wuGraph::printGraph() &#123; //1 - vertex cout &lt;&lt; \"é‚»æ¥è¡¨å¦‚ä¸‹æ‰€ç¤ºï¼š\" &lt;&lt; endl; for (int i = 1; i &lt;= vertex; i++) &#123; cout &lt;&lt; graph[i].data&lt;&lt; \" &gt;\"; node* p = graph[i].first; while (p) &#123; cout &lt;&lt; \"---&gt;\"; cout &lt;&lt; \"weight:\" &lt;&lt; p-&gt;weight &lt;&lt; \"-\" &lt;&lt; p-&gt;vertex; p = p-&gt;next; &#125; cout &lt;&lt; endl; &#125;&#125; BFSvoid wuGraph::bfs(int start) &#123; queue&lt;int&gt; q; visited[start] = true; q.push(start); while (!q.empty()) &#123; int index = q.front();//ç¬¬ä¸€ä¸ªå…ƒç´  cout &lt;&lt; index &lt;&lt; \" \"; q.pop(); node* p = graph[index].first; while (p) &#123; if (!visited[p-&gt;vertex]) &#123; visited[p-&gt;vertex] = true;//è®¾ä¸ºè®¿é—®è¿‡ q.push(p-&gt;vertex); &#125; p = p-&gt;next; &#125; &#125;&#125;void wuGraph::bfsTravel() &#123; for (int i = 1; i &lt;= vertex; i++) visited[i] = false; cout &lt;&lt; \"BFSï¼š\" &lt;&lt; endl; for (int i = 1; i &lt;= vertex; i++) &#123; if (!visited[i]) bfs(i); &#125;&#125; DFSvoid wuGraph::dfs(int start) &#123; cout &lt;&lt; graph[start].data &lt;&lt; \" \"; visited[start] = true; node* p = graph[start].first; while (p) &#123; if (!visited[p-&gt;vertex]) dfs(p-&gt;vertex); p = p-&gt;next; &#125;&#125;void wuGraph::dfsTravel() &#123; cout &lt;&lt; \"DFS:\" &lt;&lt; endl; for (int i = 1; i &lt;= vertex; i++) visited[i] = false; for (int i = 1; i &lt;= vertex; i++) if (!visited[i]) dfs(i);&#125; æœ€å°ç”Ÿæˆæ ‘//æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿å­˜åœ¨parentæ•°ç»„ä¸­//ä¸çˆ¶èŠ‚ç‚¹çš„æƒå€¼ä¿å­˜åœ¨vx[i].keyä¸­void wuGraph::minTree() &#123; int* parent = new int[vertex + 1];//æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ bool* pvisited = new bool[vertex + 1];//æ˜¯å¦å·²ç»åŠ å…¥æ ‘ä¸­ pNode* vx = new pNode[vertex + 1];//ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹ä¸çˆ¶èŠ‚ç‚¹è¿æ¥è¾¹çš„æƒå€¼ priority_queue&lt;pNode&gt; p; for (int i = 1; i &lt;= vertex; i++) &#123; vx[i].v = i; vx[i].key = INF;//æƒå€¼ä¸ºæ— ç©·å¤§ parent[i] = -1; pvisited[i] = false;//æ ‘ä¸­æ— è¯¥å…ƒç´  &#125; vx[1].key = 0;//ä½œä¸ºçˆ¶èŠ‚ç‚¹ p.push(vx[1]); while (!p.empty()) &#123; pNode n = p.top(); p.pop(); if (pvisited[n.v])//è®¿é—®è¿‡ continue; pvisited[n.v] = true;//è®¿é—®è¿‡è¯¥èŠ‚ç‚¹ node* current = graph[n.v].first; while (current) &#123; //æ ‘ä¸­æ— è¯¥å…ƒç´  &amp;&amp; æ±‚æŸä¸ªèŠ‚ç‚¹ä¸å…¶æ‰€æœ‰èŠ‚ç‚¹ä¸­æƒå€¼æœ€å°çš„çˆ¶èŠ‚ç‚¹ if (!pvisited[current-&gt;vertex] &amp;&amp; current-&gt;weight &lt; vx[current-&gt;vertex].key) &#123; parent[current-&gt;vertex] = n.v; vx[current-&gt;vertex].key = current-&gt;weight; vx[current-&gt;vertex].v = current-&gt;vertex; p.push(vx[current-&gt;vertex]);//æŒ‰ç…§æƒå€¼æ¥è¿›è¡Œæ’åº &#125; current = current-&gt;next; &#125; &#125;&#125; åƒè€ƒéˆæ¥ä¸€åƒè€ƒéˆæ¥äºŒåƒè€ƒéˆæ¥ä¸‰ å¹¾å€‹ä¸éŒ¯çš„Blogéˆæ¥Blogéˆæ¥ä¸€Blogéˆæ¥äºŒBlogéˆæ¥ä¸‰","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/categories/æ•°æ®ç»“æ„/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"Priority_queue","slug":"Priority-queue","date":"2017-12-26T13:53:51.000Z","updated":"2017-12-29T09:01:19.026Z","comments":true,"path":"2017/12/26/Priority-queue/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/26/Priority-queue/","excerpt":"Stlä¸­å„ªå…ˆéšŠåˆ—çš„ä½¿ç”¨","text":"Stlä¸­å„ªå…ˆéšŠåˆ—çš„ä½¿ç”¨ä¸€.é¡Œç›®éˆæ¥ä½¿ç”¨å„ªå…ˆéšŠåˆ—struct node &#123; int x, y; friend bool operator &lt;(node a, node b) &#123; if (a.y == b.y) return a.x &gt; b.x; else return a.y &lt; b.y; &#125; node(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; priority_queue&lt;node&gt; p; unordered_map&lt;int, int&gt; mp; int size = nums.size(); for (int i = 0; i &lt; size; i++) mp[nums[i]]++; auto iter = mp.begin(); int pos = mp.size() - k; while (iter != mp.end()) &#123; p.push(node(iter-&gt;first, iter-&gt;second)); if (p.size() &gt; pos) &#123; res.push_back(p.top().x); p.pop(); &#125; iter++; &#125; return res;&#125; ç›´æ¥åˆ©ç”¨map,æ²’æƒ³åˆ°Runtimeå¾ˆå¿«You are here! Your runtime beats 92.96 % of cpp submissions.äºŒ.é¡Œç›®éˆæ¥ä»¿ç…§å‰é¢å®šç¾©çµæ§‹é«”nodestruct node &#123; string x; int y; friend bool operator &lt;(node a, node b) &#123; //yä¸ºæ•°é‡ if (a.y == b.y)//æ•°é‡ç›¸åŒ return a.x[0] &lt; b.x[0];//å‡åº else return a.y &lt; b.y; &#125; node(string x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) &#123; vector&lt;string&gt; res; priority_queue&lt;node&gt; p; unordered_map&lt;string, int&gt; mp; int size = words.size(); for (int i = 0; i &lt; size; i++) mp[words[i]]++; auto iter = mp.begin(); int pos = mp.size() - k; while (iter != mp.end()) &#123; p.push(node(iter-&gt;first, iter-&gt;second)); if (p.size() &gt; pos) &#123; res.push_back(p.top().x); p.pop(); &#125; iter++; &#125; return res;&#125; è‡ªå®šç¾©æ¯”è¼ƒå‡½æ•¸vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) &#123; unordered_map&lt;string, int&gt; freq; for (auto w : words) &#123; freq[w]++; &#125; auto comp = [&amp;](const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp; b) &#123; return a.second &gt; b.second || (a.second == b.second &amp;&amp; a.first &lt; b.first); &#125;; typedef priority_queue&lt; pair&lt;string, int&gt;, vector&lt;pair&lt;string, int&gt;&gt;, decltype(comp) &gt; my_priority_queue_t; my_priority_queue_t pq(comp); for (auto w : freq) &#123; pq.emplace(w.first, w.second); if (pq.size()&gt;k) pq.pop(); &#125; vector&lt;string&gt; output; while (!pq.empty()) &#123; output.insert(output.begin(), pq.top().first); pq.pop(); &#125; return output;&#125;","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/categories/æ•°æ®ç»“æ„/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"Trie","slug":"Trie","date":"2017-12-24T07:12:34.000Z","updated":"2017-12-29T09:01:48.036Z","comments":true,"path":"2017/12/24/Trie/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Trie/","excerpt":"å­—å…¸æ¨¹","text":"å­—å…¸æ¨¹å­¸ç¿’äº†ä¸€ä¸‹å­—å…¸æ¨¹çš„ç°¡å–®å¯¦ç¾æ–¹å¼ReferenceèŠ‚ç‚¹çš„å®šä¹‰#define Maxn 26struct trieNode &#123; int count;//ä»¥è¯¥èŠ‚ç‚¹ä¸ºç»“å°¾çš„å•è¯çš„ä¸ªæ•° trieNode* next[Maxn]; trieNode(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;; åœ¨å­—å…¸ä¸­æ’å…¥æ–°çš„å­—ç¬¦ä¸²void insert(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root;//æ ¹èŠ‚ç‚¹ //ä¸€ä¸ªä¸€ä¸ªå­—ç¬¦æ’å…¥ for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a';//26ä¸ªå­—æ¯ä¸­çš„ä½ç½® if (p-&gt;next[index]==NULL) p-&gt;next[index] = new trieNode(0);//åˆ›å»º p = p-&gt;next[index]; &#125; //ä»¥è¯¥å­—ç¬¦ä¸ºç»“å°¾çš„å•è¯ p-&gt;count++;&#125; åˆªé™¤å­—å…¸ä¸­çš„å…ƒç´ void del(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) return; p = p-&gt;next[index]; &#125; p-&gt;count--;&#125; æŸ¥æ‰¾å­—å…¸ä¸­æ˜¯å¦å­˜åœ¨æŸå€‹å­—ç¬¦ä¸²bool search(trieNode* root, string str) &#123; if (root == NULL) &#123; return false; &#125; int size = str.size(); trieNode *p = root; int index; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; // æ— æ³•è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦ if (p-&gt;next[index] == NULL) &#123; return false; &#125;//if // ç»§ç»­ä¸‹ä¸€ä¸ªå­—ç¬¦ p = p-&gt;next[index]; &#125; return p-&gt;count &gt; 0;//æ˜¯å¦æœ‰&#125; éæ›†è¼¸å‡ºæ•´å€‹å­—å…¸//åˆ©ç”¨é€’å½’ç¨‹åºæŸ¥è¯¢æ•´ä¸ªå­—å…¸void printDic(trieNode* root, vector&lt;vector&lt;char&gt;&gt; &amp;words, vector&lt;char&gt; &amp;word) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;count &gt; 0) &#123; words.push_back(word); &#125;//åˆ°äº†æ ¹ä¸”æœ‰å€¼ for (int i = 0; i &lt; 26; ++i) &#123; if (root-&gt;next[i]) &#123;//26ä¸ªå¾ªç¯ word.push_back('a' + i); printDic(root-&gt;next[i], words, word); word.pop_back();//å›æº¯ &#125; &#125;&#125; LeetCodeä¸Šçš„ç›¸é—œé¡Œç›®ä¸€.é¡Œç›®éˆæ¥ä½¿ç”¨å­—å…¸æ¨¹çš„è§£æ³•#define Maxn 26struct node &#123; int count; int value; node* next[Maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;;class MapSum &#123;public: /** Initialize your data structure here. */ MapSum() &#123; root = new node(0); &#125; void insert(string key, int val) &#123; int size = key.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = key[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++; p-&gt;value = val; &#125; node* help(string prefix) &#123; int size = prefix.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = prefix[i] - 'a'; if (p-&gt;next[index] == NULL) return NULL; p = p-&gt;next[index]; &#125; return p;//æœ‰è¯¥å‰ç¼€ &#125; void search(node* root,int&amp; res) &#123; if (root == NULL)//ç©º return; if (root-&gt;count &gt; 0) res += root-&gt;value; for (int i = 0; i &lt; Maxn; i++) if (root-&gt;next[i]) search(root-&gt;next[i], res); &#125; int sum(string prefix) &#123; int res = 0; node* current = help(prefix); search(current,res); return res; &#125;private: node* root;&#125;; äºŒ.é¡Œç›®éˆæ¥#define maxn 26struct node &#123; int count; node* next[maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; maxn; i++) next[i] = NULL; &#125;&#125;;void insert(node* root,string str)&#123; int size = str.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++;&#125;int search(node* &amp;root, char c) &#123; if (root == NULL) &#123; return -1; &#125; int index = c - 'a'; if (root-&gt;next[index] == NULL) return -1;//ä¸å­˜åœ¨ root = root-&gt;next[index]; if (root-&gt;count &gt; 0) return 1;//å­˜åœ¨ return 0;//å¯èƒ½å­˜åœ¨&#125;string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) &#123; int size = dict.size(); node* root = new node(0); string res = \"\"; for (int i = 0; i &lt; size; i++) insert(root, dict[i]); int keysize = sentence.size(); for (int j = 0; j &lt; keysize; ) &#123; node* p = root; string element = \"\"; bool tag = false; while (j &lt; keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; int com = search(p, sentence[j]); if (com==-1) &#123; j++; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; j++; &#125; res += element; res += \" \"; tag = true; break; &#125; if (com == 0) &#123; //do noing &#125; if (com == 1) &#123; res += element; res += \" \"; tag = true; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') j++; break; &#125; j++; &#125; if (!tag) &#123; res += element; res += \" \"; &#125; j++; &#125; res.pop_back(); return res;&#125;","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/categories/æ•°æ®ç»“æ„/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"Heap","slug":"Heap","date":"2017-12-24T02:06:46.000Z","updated":"2017-12-29T09:00:39.268Z","comments":true,"path":"2017/12/24/Heap/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Heap/","excerpt":"è€ƒè©¦éåŠï¼Œæ˜¨å¤©å»é’å³¶å¸‚å€è½‰äº†ä¸€åœˆï¼Œèµ°åœ¨äº”å››å»£å ´çš„æµ·é‚Šï¼Œè½è½æµ·æµªæ‹æ‰“çš„è²éŸ³ï¼ŒçœŸæ˜¯ä¸éŒ¯å‘¢ã€‚","text":"è€ƒè©¦éåŠï¼Œæ˜¨å¤©å»é’å³¶å¸‚å€è½‰äº†ä¸€åœˆï¼Œèµ°åœ¨äº”å››å»£å ´çš„æµ·é‚Šï¼Œè½è½æµ·æµªæ‹æ‰“çš„è²éŸ³ï¼ŒçœŸæ˜¯ä¸éŒ¯å‘¢ã€‚çµ¦åšå®¢æ›äº†ä¸»é¡Œï¼Œå¾ˆå¤§è¡†ä¹Ÿå¾ˆé›…è‡´çš„ä¸»é¡Œã€‚æ˜¨å¤©ä¸‹åˆå››é»å¤šå›ä¾†ä¹‹å¾Œï¼Œå»è¶…å¸‚è²·äº†ä¸€äº›é›¶é£Ÿï¼Œæ…µæ‡¶åœ°èººåœ¨åºŠä¸Šï¼Œçœ‹äº†ä¸€éƒ¨é›»å½±ï¼Œå«åšæƒ…è–ï¼Œé‚„æ˜¯æ¯”è¼ƒæœ‰æ„æ€çš„ã€‚æ™šä¸Šï¼Œå¯«äº†å¹¾é“Leetcodeä¸Šçš„é¡Œç›®ï¼Œè£œäº†ä¸€ä¸‹æ•¸æ“šçµæ§‹å¯¦é©—çš„ä½œæ¥­ã€‚è¦æ±‚åˆ©ç”¨éˆè¡¨å¯¦ç¾ä¸€å€‹å †struct heapNode &#123; heapNode(const int&amp; theElement, heapNode* p) &#123; parent = p; element = theElement; left = right = NULL; &#125; int element; heapNode* parent; heapNode* left; heapNode* right;&#125;;class maxHeap &#123;public: int&amp; top() &#123; if (root) return root-&gt;element; &#125;//è·å–å †é¡¶å…ƒç´  void insert(const int&amp; theElement);//æ’å…¥ int size() &#123; return heapSize; &#125; void pop();//åˆ é™¤ void initialize(vector&lt;int&gt;&amp; nums);//åˆå§‹åŒ–ä¸€ä¸ªå¤§æ ¹å †private: heapNode* root; int heapSize; deque&lt;heapNode*&gt; pars;//å‚¨å­˜èŠ‚ç‚¹ int childNumber;//å­©å­çš„æ•°é‡&#125;; æ’å…¥void maxHeap::insert(const int&amp; theElement) &#123; if (heapSize == 0) &#123;//ç©ºå † root = new heapNode(theElement, NULL); root-&gt;parent = root; heapSize++; pars.push_back(root); childNumber = 0; return; &#125; //æ’å…¥æ–°çš„å…ƒç´  heapNode* p = pars.front(); heapNode* newNode = new heapNode(theElement, p); heapSize++; pars.push_back(newNode); if (childNumber == 0)//å·¦èŠ‚ç‚¹ p-&gt;left = newNode; if (childNumber == 1)//å³èŠ‚ç‚¹ p-&gt;right = newNode; childNumber++; if (childNumber == 2) &#123;//å­©å­èŠ‚ç‚¹æ»¡äº† pars.pop_front(); childNumber = 0; &#125; heapNode* current = newNode; while (current-&gt;parent != current&amp;&amp;current-&gt;element &gt; current-&gt;parent-&gt;element) &#123; //äº¤æ¢å­©å­èŠ‚ç‚¹ä¸çˆ¶èŠ‚ç‚¹çš„å…ƒç´  int tempt = current-&gt;element; current-&gt;element = current-&gt;parent-&gt;element; current-&gt;parent-&gt;element = tempt; current = current-&gt;parent; &#125; return;&#125; åˆ é™¤void maxHeap::pop() &#123; if (!root)//ç©ºå † return; heapNode* lastChild = pars.back(); root-&gt;element = lastChild-&gt;element;//æ›¿æ¢ heapNode* p = lastChild-&gt;parent; if (p == root &amp;&amp; heapSize==1 ) &#123;//æœ¬èº« root = NULL; heapSize--; childNumber = 0; pars.pop_back();//åˆ é™¤ return; &#125; if (childNumber == 0) &#123;//æ»¡äº† p-&gt;right = NULL; pars.push_front(p);//æ·»åŠ èŠ‚ç‚¹ heapSize--; childNumber = 1; pars.pop_back();//åˆ é™¤ lastChild = pars.back(); &#125; else &#123; p-&gt;left = NULL; heapSize--; childNumber--; pars.pop_back(); lastChild = pars.back(); &#125; //è‡ªä¸Šè€Œä¸‹åœ°è¿›è¡Œæ›´æ–° heapNode* current = root; while (current-&gt;left&amp;&amp;current-&gt;right) &#123; heapNode* tempt = (current-&gt;left-&gt;element &gt; current-&gt;right-&gt;element) ? current-&gt;left : current-&gt;right;//æ•°å€¼è¾ƒå¤§è€… if (current-&gt;element &gt; tempt-&gt;element) return; int value = tempt-&gt;element; tempt-&gt;element = current-&gt;element; current-&gt;element = value; current = tempt;//æ›¿æ¢æ›´æ–° &#125; //æ•°å€¼äº¤æ¢ if (current-&gt;left&amp;&amp;current-&gt;left-&gt;element &gt; current-&gt;element) &#123; int leftTempt = current-&gt;left-&gt;element; current-&gt;left-&gt;element = current-&gt;element; current-&gt;element = leftTempt; &#125;&#125; åˆå§‹åŒ–ä¸€ä¸ªå¤§æ ¹å †//å»ºç«‹ä¸€ä¸ªå¤§æ ¹å †//å…ˆå»ºç«‹ä¸€ä¸ªç”¨é“¾è¡¨è¡¨ç¤ºçš„å †ï¼Œç„¶åè¿›è¡Œè°ƒæ•´void maxHeap::initialize(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return; //å»ºç«‹ä¸€æ£µæ ‘ stack&lt;heapNode*&gt; pNodes;//ç”¨äºä¿å­˜æ‰€æœ‰çš„çˆ¶èŠ‚ç‚¹ root = new heapNode(nums[0], NULL); root-&gt;parent = root; childNumber = 0; heapSize++; pars.push_back(root); for (int i = 1; i &lt; nums.size(); i++) &#123; heapNode* p = pars.front(); heapNode* newNode = new heapNode(nums[i], p); heapSize++; pars.push_back(newNode); if (childNumber == 0)//å·¦èŠ‚ç‚¹ p-&gt;left = newNode; if (childNumber == 1)//å³èŠ‚ç‚¹ p-&gt;right = newNode; childNumber++; if (childNumber == 2) &#123; pNodes.push(pars.front());//å°†æ»¡å­©å­çš„èŠ‚ç‚¹å­˜è¿›å» pars.pop_front(); childNumber = 0; &#125; &#125; //å¯¹æ ‘è¿›è¡Œè‡ªä¸Šè€Œä¸‹çš„è°ƒæ•´ if (pars.front()-&gt;left) pNodes.push(pars.front()); while (!pNodes.empty()) &#123;//check æ‰€æœ‰çš„çˆ¶èŠ‚ç‚¹ heapNode* current = pNodes.top(); pNodes.pop(); while (current-&gt;left&amp;&amp;current-&gt;right) &#123; heapNode* tempt = (current-&gt;left-&gt;element &gt; current-&gt;right-&gt;element) ? current-&gt;left : current-&gt;right;//æ•°å€¼è¾ƒå¤§è€… if (current-&gt;element &gt; tempt-&gt;element) break; int value = tempt-&gt;element; tempt-&gt;element = current-&gt;element; current-&gt;element = value; current = tempt;//æ›¿æ¢æ›´æ–° &#125; //æ•°å€¼äº¤æ¢ if (current-&gt;left&amp;&amp;current-&gt;left-&gt;element &gt; current-&gt;element) &#123; int leftTempt = current-&gt;left-&gt;element; current-&gt;left-&gt;element = current-&gt;element; current-&gt;element = leftTempt; &#125; &#125; return;&#125;","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/categories/æ•°æ®ç»“æ„/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"æ‚æ„Ÿ","slug":"æ‚æ„Ÿ","date":"2017-12-11T12:35:03.000Z","updated":"2017-12-11T12:55:58.151Z","comments":true,"path":"2017/12/11/æ‚æ„Ÿ/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/11/æ‚æ„Ÿ/","excerpt":"2017/12/11","text":"2017/12/11ç°åœ¨æ˜¯20:36ï¼›å†™ä¸€äº›å¾ˆæ‚çš„ä¸œè¥¿å§ï¼Œå…ˆæ˜¯ä¸¤é“é¢˜ç›®ï¼›1.Bing It On Solution#include&lt;map&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;map&lt;string, int&gt;mp;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string key; cin &gt;&gt; key; for (int i = 1; i &lt; key.size(); i++) &#123; mp[key.substr(0, i)]++; &#125; cout &lt;&lt; mp[key] &lt;&lt; endl; mp[key]++; &#125;&#125; mapçš„ä½¿ç”¨#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; map&lt;int, int&gt; mp; mp[1];//è¾“å‡º 1 0 mp[1]++;//è¾“å‡º 1 1 auto it = mp.begin(); while (it != mp.end()) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl; it++; &#125;&#125; 2.Power Stringå¯ç”¨KMPç®—æ³•è§£å†³ï¼Œç›´æ¥ç”¨æš´åŠ›åšäº† Solution #include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main() &#123; string key; for (int i = 0; ; i++) &#123; bool tag = false;//æ‰¾åˆ°äº†å— if (key == \".\") break; vector&lt;int&gt; pos; cin &gt;&gt; key; for (int j = 1; j &lt; key.size(); j++) if (key[j] == key[0]) pos.push_back(j); if (pos.empty()) &#123; cout &lt;&lt; 1 &lt;&lt; endl;//ç©ºçš„ continue; &#125; for (int k = 0; k &lt; pos.size(); k++) &#123; bool flag = true; if (key.size() % pos[k] != 0) &#123;//ç¡®å®šæ•´é™¤ continue; &#125; //æ¯ä¸€æ®µçš„é•¿åº¦ä¸ºpos[k] for (int i = pos[k]; i &lt; key.size();) &#123; if (key[i] != key[0]) &#123; flag = false; break; &#125; i += pos[k]; &#125; if (!flag) continue;//ä¸åŒ¹é… string tempt = key.substr(0, pos[k]);//ç¬¬ä¸€æ®µå­—ç¬¦ int l = pos[k]; bool judge = true; while (l != key.size()) &#123; if (tempt != key.substr(l, pos[k])) &#123; judge = false;//ä¸åŒ¹é… break; &#125; l += pos[k]; &#125; if (judge) &#123;//æ‰¾åˆ° cout &lt;&lt; key.size() / pos[k] &lt;&lt; endl; tag = true;//æ‰¾åˆ° break; &#125; &#125; //æ²¡æœ‰æ‰¾åˆ° if (!tag) cout &lt;&lt; 1 &lt;&lt; endl; &#125;&#125; é©¬ä¸Šè€ƒè¯•äº†ï¼Œç”µè·¯ä¹Ÿç»“è¯¾äº†ï¼Œè¿™æ ·å‘¨å…­å‘¨æ—¥å‘¨ä¸€éƒ½æ²¡æœ‰è¯¾äº†ã€‚æœ€è¿‘ä½œæ¯æ˜¯10ç‚¹èµ·åºŠï¼Œä¸­åˆæ™šä¸Šä¸€ç›´åœ¨è‡ªä¹ å®¤å‘¢ã€‚ç°åœ¨åšå®¢ä»£ç æ˜¾ç¤ºä¸å¥½çœ‹ï¼Œä¹Ÿä¸æƒ³é‡æ–°æ¢ä¸ªä¸»é¢˜äº†ï¼Œæœ‰ç‚¹å¤ªéº»çƒ¦äº†ã€‚å‰ç«¯çš„çŸ¥è¯†ä¹Ÿæ²¡æœ‰æ¥è§¦è¿‡ï¼Œå¯’å‡å­¦å­¦jsï¼Œå¼„å¼„é¡µé¢å§ã€‚ æ²¡æƒ³åˆ°ä¼šæœ‰äººæµè§ˆæˆ‘è¿™ä¸ªåšå®¢ï¼Œå¯èƒ½äº’è”ç½‘å¤ªæµ©ç€šäº†å§ï¼Œæ€»æœ‰äººä¼šåœ¨è¿™ç‰‡æµ·æ´‹ç›¸é‡ï¼Œæ„Ÿè°¢ä½ ä»¬çš„åˆ°è®¿ï¼è¿™ä¸ªåšå®¢ï¼Œä¸»è¦ä¹Ÿæ˜¯æ”¾ä¸€äº›å¹³æ—¶çš„ä½œä¸šä¹‹ç±»çš„ï¼Œæ°´å¹³å¤ªæ°´äº†ï¼Œä¹Ÿæ²¡ä»€ä¹ˆé«˜çº§çš„ä¸œè¥¿ï¼Œä¹Ÿæ²¡æœ‰è®¤çœŸåœ°å†™ï¼Œåªæ˜¯æ”¾äº†ä¸€äº›ä»£ç ï¼› æ„Ÿè°¢ä½ ä»¬çš„æ¥è®¿ï¼å¾®åšè¿™ä¸ªä¸œè¥¿ï¼Œå¯èƒ½ä¹Ÿé©¬ä¸Šä¸ç”¨äº†å§ã€‚æ€ä¹ˆè¯´å‘¢ï¼Ÿ 2018ã€2019å¥½è¿ï¼","categories":[],"tags":[{"name":"æ‚æ„Ÿ","slug":"æ‚æ„Ÿ","permalink":"http://Persuingsdu.github.io/tags/æ‚æ„Ÿ/"}]},{"title":"Something","slug":"Something","date":"2017-12-10T12:22:59.000Z","updated":"2017-12-10T12:41:52.155Z","comments":true,"path":"2017/12/10/Something/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/10/Something/","excerpt":"2017/12/10","text":"2017/12/10Hello,Homework!ç»™å‡ºå‰åºå’Œä¸­åºéå†ï¼Œæ„å»ºä¸€ä¸ªäºŒå‰æ ‘. ä»£ç BinaryTreeNode&lt;E&gt;* build(int ps,int pt,int is,int it,vector&lt;E&gt;&amp; preOrder,vector&lt;E&gt;&amp; inOrder)&#123; if (ps &gt;= pt) return NULL; BinaryTreeNode&lt;E&gt;* res = new BinaryTreeNode&lt;E&gt;(preOrder[ps]); int cnt = find(inOrder.begin(), inOrder.end(), preOrder[ps]) - inOrder.begin() - is; res-&gt;left = build(ps + 1, ps + 1 + cnt, is, is + cnt, preOrder, inOrder); res-&gt;right = build(ps + 1 + cnt, pt, is + cnt + 1, it, preOrder, inOrder); return res;&#125;void buildTree(vector&lt;E&gt;&amp; preorder, vector&lt;E&gt;&amp; inorder) &#123; int size = preorder.size(); root = build(0, size, 0, size, preorder, inorder);&#125; è¯»å–txtç±»å‹çš„æ–‡ä»¶å‚è€ƒé“¾æ¥1å‚è€ƒé“¾æ¥2 ä»£ç void readTxt(string file) &#123; ifstream infile; infile.open(file.data());//å°†æ–‡ä»¶æµå¯¹è±¡ä¸æ–‡ä»¶è¿æ¥èµ·æ¥ assert(infile.is_open());//è‹¥å¤±è´¥ï¼Œè¾“å‡ºé”™è¯¯æ¶ˆæ¯ï¼Œå¹¶åœæ­¢ string s; while (getline(infile, s)) &#123; //æ“ä½œ &#125; infile.close();&#125;//é€ä¸ªå­—ç¬¦è¯»å…¥ï¼Œå¿½ç•¥ç©ºæ ¼ä¸å›è½¦void readSingle(string file) &#123; ifstream infile; infile.open(file.data());//å°†æ–‡ä»¶æµå¯¹è±¡ä¸æ–‡ä»¶è¿æ¥èµ·æ¥ assert(infile.is_open());//è‹¥å¤±è´¥ï¼Œè¾“å‡ºé”™è¯¯æ¶ˆæ¯ï¼Œå¹¶åœæ­¢ char c; while (!infile.eof()) &#123; infile &gt;&gt; c; //æ“ä½œ &#125; infile.close();&#125;//é€ä¸ªå­—ç¬¦è¯»å…¥ï¼ŒåŒ…æ‹¬å›è½¦å’Œç©ºæ ¼void readSingleTxt(string file) &#123; ifstream infile; infile.open(file.data()); //å°†æ–‡ä»¶æµå¯¹è±¡ä¸æ–‡ä»¶è¿æ¥èµ·æ¥ assert(infile.is_open()); //è‹¥å¤±è´¥,åˆ™è¾“å‡ºé”™è¯¯æ¶ˆæ¯,å¹¶ç»ˆæ­¢ç¨‹åºè¿è¡Œ char c; infile &gt;&gt; noskipws; while (!infile.eof()) &#123; infile &gt;&gt; c; //æ“ä½œ &#125; infile.close();//å…³é—­æ–‡ä»¶è¾“å…¥æµ &#125;int main() &#123; readSingle(\"C:\\\\Users\\\\11692\\\\Desktop\\\\maze.txt\");//æ‹¬å·å†…stringä¸ºæ–‡ä»¶çš„åœ°å€&#125; å®ç°çš„äºŒå‰æ ‘ç±»ï¼Œæä¾›äº†åŸºæœ¬çš„æ“ä½œè‡ªå·±è®¤çœŸåœ°å®ç°äº†ä¸€ä¸‹ï¼Œåˆå­¦äº†vsçš„è°ƒè¯•æ–¹æ³•ï¼›è¿™é‡Œé¢ä¸»è¦å­¦ä¹ çš„æ˜¯å‡½æ•°æŒ‡é’ˆçš„ä½¿ç”¨æ ¼å¼ ret_type(*var_name)(arg_list)å¯ä»¥é€šè¿‡ä¸¤æ£µäºŒå‰æ ‘åˆå¹¶æ„é€ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ ‘çš„æ ¹èŠ‚ç‚¹æ„é€ ä¸€æ£µäºŒå‰æ ‘ï¼› ä»£ç å¦‚ä¸‹ï¼Œçœç•¥äº†æ ‘èŠ‚ç‚¹çš„å®šä¹‰#pragma once#include\"BinaryTreeNode.h\"#include\"booster.h\"#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;template&lt;class E&gt;class linkedBinaryTree &#123;public: linkedBinaryTree() &#123; root = NULL; treeSize = 0; &#125; linkedBinaryTree(BinaryTreeNode&lt;E&gt;* theRoot) &#123; root = theRoot; treeSize = 0; &#125; ~linkedBinaryTree() &#123; destory();&#125; bool empty() const &#123; return treeSize == 0; &#125; int size() &#123; sizeTravel(root); return treeSize + 1; &#125; void makeTree(const E&amp; element, linkedBinaryTree&lt;E&gt;&amp;, linkedBinaryTree&lt;E&gt;&amp;); //å‰åºéå†å¹¶ä¸”ç¡®å®šå¯¹èŠ‚ç‚¹è¿›è¡Œçš„æ“ä½œ void preOrder(void(*theVist)(BinaryTreeNode&lt;E&gt;*)) &#123; visit = theVist;//ç»™è®¿é—®å‡½æ•°èµ‹å€¼,ç¡®å®šè®¿é—®å‡½æ•° preOrder(root); &#125; void inOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*)) &#123; visit = theVisit; inOrder(root); &#125; void postOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*)) &#123; visit = theVisit; postOrder(root); &#125; void levelOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*));//BFSéå† void preOrderOutput() &#123; preOrder(output); cout &lt;&lt; endl; &#125;//è°ƒç”¨publicçš„preOrderç»™visitèµ‹å€¼ void inOrderOutput() &#123; inOrder(output); cout &lt;&lt; endl; &#125; void postOrderOutput() &#123; postOrder(output); cout &lt;&lt; endl; &#125; void levelOrderOutput() &#123; levelOrder(output); cout &lt;&lt; endl; &#125; void destory() &#123; erase(root); root = NULL; &#125; void erase(BinaryTreeNode&lt;E&gt;* t) &#123; if (!t) return; if (t-&gt;left) erase(t-&gt;left); if (t-&gt;right) erase(t-&gt;right); delete t; &#125; int height() const &#123; return height(root); &#125; void sizeTravel(BinaryTreeNode&lt;E&gt;* t) &#123; if (!t) return; if (t-&gt;left) &#123; treeSize++; sizeTravel(t-&gt;left); &#125; if (t-&gt;right) &#123; treeSize++; sizeTravel(t-&gt;right); &#125; &#125; /* 1 / \\ 3 5 / 7 \\ 9 å‰åºéå†ï¼š 1 3 7 9 5 ä¸­åºéå†ï¼š 7 9 3 1 5 */ BinaryTreeNode&lt;E&gt;* build(int ps,int pt,int is,int it,vector&lt;E&gt;&amp; preOrder,vector&lt;E&gt;&amp; inOrder)&#123; if (ps &gt;= pt) return NULL; BinaryTreeNode&lt;E&gt;* res = new BinaryTreeNode&lt;E&gt;(preOrder[ps]); int cnt = find(inOrder.begin(), inOrder.end(), preOrder[ps]) - inOrder.begin() - is; res-&gt;left = build(ps + 1, ps + 1 + cnt, is, is + cnt, preOrder, inOrder); res-&gt;right = build(ps + 1 + cnt, pt, is + cnt + 1, it, preOrder, inOrder); return res; &#125; void buildTree(vector&lt;E&gt;&amp; preorder, vector&lt;E&gt;&amp; inorder) &#123; int size = preorder.size(); root = build(0, size, 0, size, preorder, inorder); &#125;private: BinaryTreeNode&lt;E&gt;* root; int treeSize; static int count;//å­æ ‘èŠ‚ç‚¹çš„ä¸ªæ•° //å‡½æ•°æŒ‡é’ˆ //æ ¼å¼ ret_type(*var_name)(arg_list) static void (*visit)(BinaryTreeNode&lt;E&gt;*);//è®¿é—®å‡½æ•° æŒ‡é’ˆæŒ‡å‘å‡½æ•° ä¸æ˜¯å…·ä½“çš„å‡½æ•°ç›¸å½“äºä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å‡½æ•° static void preOrder(BinaryTreeNode&lt;E&gt;* t);//å‰ static void inOrder(BinaryTreeNode&lt;E&gt;* t);//ä¸­ static void postOrder(BinaryTreeNode&lt;E&gt;* t);//å static void output(BinaryTreeNode&lt;E&gt;* t) &#123;//è¾“å‡ºèŠ‚ç‚¹çš„å€¼ cout &lt;&lt; t-&gt;element &lt;&lt; \" \"; &#125; static int height(BinaryTreeNode&lt;E&gt;* t);&#125;;void(*linkedBinaryTree&lt;int&gt;::visit)(BinaryTreeNode&lt;int&gt;*);void(*linkedBinaryTree&lt;booster&gt;::visit)(BinaryTreeNode&lt;booster&gt;*);void(*linkedBinaryTree&lt;pair&lt;int, int&gt;&gt;::visit)(BinaryTreeNode&lt;pair&lt;int, int&gt; &gt;*);void(*linkedBinaryTree&lt;pair&lt;const int, char&gt;&gt;::visit)(BinaryTreeNode&lt;pair&lt;const int, char&gt; &gt;*);void(*linkedBinaryTree&lt;pair&lt;const int, int&gt;&gt;::visit)(BinaryTreeNode&lt;pair&lt;const int, int&gt; &gt;*);template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::makeTree(const E&amp; element, linkedBinaryTree&lt;E&gt;&amp; leftTree, linkedBinaryTree&lt;E&gt;&amp; rightTree) &#123; root = new BinaryTreeNode&lt;E&gt;(element, leftTree.root, rightTree.root); //treeSize = leftTree.treeSize + rightTree.treeSize + 1; leftTree.root = rightTree.root = NULL; //leftTree.treeSize = rightTree.treeSize = 0;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::preOrder(BinaryTreeNode&lt;E&gt;* t)&#123;// Preorder traversal. if (t) &#123; linkedBinaryTree&lt;E&gt;::visit(t);//è®¿é—®èŠ‚ç‚¹t,æ‰§è¡Œç›¸åº”çš„æ“ä½œ preOrder(t-&gt;left); preOrder(t-&gt;right); &#125;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::inOrder(BinaryTreeNode&lt;E&gt;* t)&#123;// Inorder traversal. if (t != NULL) &#123; inOrder(t-&gt;left); linkedBinaryTree&lt;E&gt;::visit(t);//è®¿é—® inOrder(t-&gt;right); &#125;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::postOrder(BinaryTreeNode&lt;E&gt;* t)&#123;// Postorder traversal. if (t != NULL) &#123; postOrder(t-&gt;left); postOrder(t-&gt;right); linkedBinaryTree&lt;E&gt;::visit(t);//è®¿é—® &#125;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::levelOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*)) &#123; queue&lt;BinaryTreeNode&lt;E&gt;*&gt; p; BinaryTreeNode&lt;E&gt;* t; if (root != NULL) p.push(root); while (!p.empty()) &#123; t = p.front(); theVisit(t);//è®¿é—®è¯¥èŠ‚ç‚¹ if (t-&gt;left) p.push(t-&gt;left); if (t-&gt;right) p.push(t-&gt;right); p.pop();//åˆ é™¤ &#125;&#125;template &lt;class E&gt;int linkedBinaryTree&lt;E&gt;::height(BinaryTreeNode&lt;E&gt;* t)&#123;// Return height of tree rooted at *t. if (t == NULL) return 0; // empty tree int hl = height(t-&gt;left); // height of left int hr = height(t-&gt;right); // height of right if (hl &gt; hr) return ++hl; else return ++hr;&#125;","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"è®¡ç®—è¡¨è¾¾å¼çš„æ•°å€¼","slug":"è®¡ç®—è¡¨è¾¾å¼çš„æ•°å€¼","date":"2017-12-08T12:02:23.000Z","updated":"2017-12-31T03:57:57.210Z","comments":true,"path":"2017/12/08/è®¡ç®—è¡¨è¾¾å¼çš„æ•°å€¼/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/08/è®¡ç®—è¡¨è¾¾å¼çš„æ•°å€¼/","excerpt":"2017/12/8","text":"2017/12/8 è®¡ç®—è¡¨è¾¾å¼çš„æ•°å€¼è¿™ä¸ªæ–¹æ³•è®¡ç®—ä¸å«æœ‰æ‹¬å·çš„æ•°å€¼ï¼Œä¹Ÿæ˜¯æ ¸å¿ƒçš„å†…å®¹ã€‚é¦–å…ˆå¤„ç†æ‰ä¹˜å·ä¸é™¤å·,ç„¶åè®¡ç®—æ•°å€¼;ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥å‚¨å­˜åŠ å·ä¸å‡å·;ç”¨ä¸€ä¸ªåŒå‘é˜Ÿåˆ—æ¥å­˜æ”¾æ•°å€¼ï¼Œæ€æƒ³æ˜¯é‡åˆ°ä¹˜æ³•æˆ–è€…é™¤æ³•,å…ˆå–å‡ºä¸¤ä¸ªæ•°ï¼Œç„¶åè®¡ç®—å‡ºç»“æœï¼Œç„¶åå†å­˜å…¥é˜Ÿåˆ—ï¼›å¤„ç†å®Œè¡¨è¾¾å¼ä¸­çš„ä¹˜æ³•å’Œé™¤æ³•ä¹‹åï¼Œç„¶åå†è®¡ç®—æ•°å€¼ï¼› ä»£ç double cal(int l, int r, string s) &#123; queue&lt;char&gt; f; deque&lt;double&gt; value; if (s.size() == 0) return 0; for (int i = l; i &lt; r; ) &#123; if (isdigit(s[i]) || s[i] == '.') &#123; string ss = \"\"; while ((isdigit(s[i]) || s[i] == '.') &amp;&amp; i&lt;r) &#123; ss += s[i]; i++; &#125; value.push_back(atof(ss.c_str())); &#125; if (s[i] == '+' || s[i] == '-') &#123; f.push(s[i]); i++; &#125; if (s[i] == '*') &#123; double x1 = value.back(); value.pop_back(); string p = \"\"; while ((isdigit(s[i + 1]) || s[i + 1] == '.') &amp;&amp; i + 1 &lt; r) &#123; p += s[i + 1]; i++; &#125; double x2 = atof(p.c_str()); double multi = x1*x2; value.push_back(multi); i++; &#125; if (s[i] == '/') &#123; double y1 = value.back(); value.pop_back(); string p = \"\"; while ((isdigit(s[i + 1]) || s[i + 1] == '.') &amp;&amp; i + 1&lt;r) &#123; p += s[i + 1]; i++; &#125; double y2 = atof(p.c_str()); double divi = y1 / y2; value.push_back(divi); i++; &#125; &#125; while (!f.empty()) &#123; if (f.front() == '-') &#123; double s1 = value.front(); value.pop_front(); double s2 = value.front(); value.pop_front(); value.push_front(s1 - s2); &#125; if (f.front() == '+') &#123; double s1 = value.front(); value.pop_front(); double s2 = value.front(); value.pop_front(); value.push_front(s1 + s2); &#125; f.pop(); &#125; return value.front();&#125; è®¡ç®—å«æœ‰æ‹¬å·é‡åˆ°ä¸æ˜¯ ) å°±å­˜è¿›æ ˆä¸­ï¼Œé‡åˆ° ) ,å°±è®¡ç®—å‡ºæœ€è¿‘çš„å·¦æ‹¬å·å’Œè¿™ä¸ªå³æ‹¬å·ä¸­çš„è¡¨è¾¾å¼çš„å€¼ï¼Œå­˜è¿›æ ˆä¸­ã€‚ ä»£ç double calculate(string s) &#123; stack&lt;char&gt; a; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] != ')') a.push(s[i]); if (s[i] == ')') &#123; string ss = \"\"; while (!a.empty() &amp;&amp; a.top() != '(') &#123; ss += a.top(); a.pop(); &#125; a.pop(); reverse(ss.begin(), ss.end()); double p = cal(0, ss.size(), ss); string r = to_string(p); for (int i = 0; i &lt; r.size(); i++) a.push(r[i]); &#125; &#125; string res = \"\"; while (!a.empty()) &#123; res += a.top(); a.pop(); &#125; reverse(res.begin(), res.end()); return cal(0, res.size(), res);&#125; æ³¨æ„ STLä¸­stackã€queueã€dequeçš„ä½¿ç”¨; ä½¿ç”¨atofã€stringstreamå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—æ—¶ï¼Œæ³¨æ„ç²¾åº¦çš„ä¸¢å¤±; æƒ³è¦ä¿ç•™ç²¾åº¦ï¼Œå¯ä»¥ä¸ç”¨è½¬æˆæ•°å­—ï¼Œç›´æ¥åˆ©ç”¨stringï¼Œåˆ©ç”¨é«˜ç²¾åº¦è®¡ç®—å‡ºè¡¨è¾¾å¼çš„å€¼;","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„ä½œä¸š","slug":"æ•°æ®ç»“æ„ä½œä¸š","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„ä½œä¸š/"}]},{"title":"åŠ¨æ€å†…å­˜ä¸æ™ºèƒ½æŒ‡é’ˆ","slug":"åŠ¨æ€å†…å­˜ä¸æ™ºèƒ½æŒ‡é’ˆ","date":"2017-11-23T06:51:53.000Z","updated":"2017-11-23T08:53:49.194Z","comments":true,"path":"2017/11/23/åŠ¨æ€å†…å­˜ä¸æ™ºèƒ½æŒ‡é’ˆ/","link":"","permalink":"http://Persuingsdu.github.io/2017/11/23/åŠ¨æ€å†…å­˜ä¸æ™ºèƒ½æŒ‡é’ˆ/","excerpt":"2017//11/23","text":"2017//11/23ç¨‹åºç”¨å †æ¥å‚¨å­˜åŠ¨æ€åˆ†é…çš„å¯¹è±¡ï¼Œå³é‚£äº›åœ¨ç¨‹åºè¿è¡Œæ—¶åˆ†é…çš„å¯¹è±¡ã€‚åŠ¨æ€å¯¹è±¡çš„ç”Ÿå­˜æœŸç”±ç¨‹åºæ¥æ§åˆ¶ï¼Œå½“åŠ¨æ€å¯¹è±¡ä¸å†ä½¿ç”¨æ—¶ï¼Œæˆ‘ä»¬çš„ä»£ç å¿…é¡»æ˜¾ç¤ºåœ°é”€æ¯å®ƒä»¬ã€‚åŠ¨æ€å†…å­˜ä¸æ™ºèƒ½æŒ‡é’ˆåŠ¨æ€å†…å­˜çš„ç®¡ç†é€šè¿‡ä¸€å¯¹æ“ä½œè¿ç®—ç¬¦æ¥å®Œæˆã€‚newï¼Œåœ¨åŠ¨æ€å†…å­˜ä¸­ä¸ºå¯¹è±¡åˆ†é…ç©ºé—´ï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘è¯¥å¯¹è±¡çš„æŒ‡é’ˆï¼›deleteï¼Œæ¥å—ä¸€ä¸ªåŠ¨æ€å¯¹è±¡çš„æŒ‡é’ˆï¼Œé”€æ¯è¯¥å¯¹è±¡ï¼Œå¹¶é‡Šæ”¾ä¸ä¹‹ç›¸å…³çš„å†…å­˜ã€‚1.å¿˜è®°é‡Šæ”¾å†…å­˜ï¼Œäº§ç”Ÿå†…å­˜æ³„éœ²ï¼›2.å°šæœ‰æŒ‡é’ˆå¼•ç”¨å†…å­˜çš„æƒ…å†µä¸‹é‡Šæ”¾äº†å®ƒï¼Œäº§ç”Ÿå¼•ç”¨éæ³•å†…å­˜çš„æŒ‡é’ˆã€‚ ä¸¤ç§æ™ºèƒ½æŒ‡é’ˆï¼Œè´Ÿè´£è‡ªåŠ¨é‡Šæ”¾æ‰€æŒ‡å‘çš„å¯¹è±¡,å®šä¹‰åœ¨memoryå¤´æ–‡ä»¶ä¸­ã€‚shared_ptr å…è®¸å¤šä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼›unique_ptr ç‹¬å æŒ‡å‘çš„å¯¹è±¡ï¼› åˆ›å»ºæ™ºèƒ½æŒ‡é’ˆshared_ptr&lt;string&gt; p1;//shared_ptrï¼Œå¯ä»¥æŒ‡å‘stringshared_ptr&lt;list&lt;int&gt;&gt; p2;//ä½¿ç”¨å¤§è‡´ä¸æ™®é€šæŒ‡é’ˆç±»ä¼¼if(p1 &amp;&amp; p1-&gt;empty()) *p1=\"hi\"; make_sharedå‡½æ•°æœ€å®‰å…¨çš„åˆ†é…å’Œä½¿ç”¨åŠ¨æ€å†…å­˜çš„æ–¹æ³•æ˜¯è°ƒç”¨ä¸€ä¸ªåä¸ºmake_sharedçš„æ ‡å‡†åº“å‡½æ•°ï¼Œå®šä¹‰åœ¨memoryå¤´æ–‡ä»¶ä¸­ã€‚shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10,'9');shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;();//æŒ‡å‘ä¸€ä¸ªå€¼åˆå§‹åŒ–çš„int,å€¼ä¸º0 ç¨‹åºä½¿ç”¨åŠ¨æ€å†…å­˜å‡ºäºä»¥ä¸‹çš„ä¸‰ä¸ªåŸå› ä¹‹ä¸€ï¼š1.ç¨‹åºä¸çŸ¥é“è‡ªå·±éœ€è¦ä½¿ç”¨å¤šå°‘ä¸ªå¯¹è±¡ï¼Œä¾‹å¦‚å®¹å™¨ç±»ï¼›2.ç¨‹åºä¸çŸ¥é“å¯¹è±¡çš„å‡†ç¡®ç±»å‹ï¼›3.ç¨‹åºéœ€è¦åœ¨å¤šä¸ªå¯¹è±¡ä¹‹é—´å…±äº«æ•°æ®ï¼Œä»¥ä¸‹çš„ä¾‹å­ç”¨æ¥è¯´æ˜æ”¹åŸå› ï¼›#include&lt;memory&gt;#include&lt;initializer_list&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;class StrBlob &#123;public: typedef vector&lt;string&gt;::size_type size_type; StrBlob(); StrBlob(initializer_list&lt;string&gt; il); size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; //æ·»åŠ å’Œåˆ é™¤å…ƒç´  void push_back(string&amp; t) &#123; data-&gt;push_back(t); &#125; void pop_back(); //å…ƒç´ è®¿é—® string&amp; front(); string&amp; back();private: shared_ptr&lt;vector&lt;string&gt;&gt; data; void check(size_type i, const string&amp; msg) const;&#125;;//æ„é€ å‡½æ•°StrBlob::StrBlob():data(make_shared&lt;vector&lt;string&gt;&gt;())&#123;&#125;StrBlob::StrBlob(initializer_list&lt;string&gt; il): data(make_shared&lt;vector&lt;string&gt;&gt;(il))&#123;&#125;//æ£€æŸ¥ç»™å®šçš„ç´¢å¼•æ˜¯å¦åœ¨åˆæ³•çš„èŒƒå›´å†…void StrBlob::check(size_type i, const string&amp; msg) const &#123; if (i &gt;= data-&gt;size()) throw out_of_range(msg);&#125;string&amp; StrBlob::front() &#123; check(0, \"Front on empty StrBlob\"); return data-&gt;front();&#125;string&amp; StrBlob::back() &#123; check(0, \"Back on empty StrBlob\"); return data-&gt;back();&#125;void StrBlob::pop_back() &#123; check(0, \"pop_back on empty StrBlob\"); data-&gt;pop_back();&#125; ç›´æ¥ç®¡ç†å†…å­˜ä½¿ç”¨newåŠ¨æ€åˆ†é…å’Œåˆå§‹åŒ–å¯¹è±¡int *p1 = new int;//pæŒ‡å‘ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„ã€æœªåˆå§‹åŒ–çš„æ— åå¯¹è±¡string *ps = new string;//åˆå§‹åŒ–ä¸ºç©ºçš„stringint *pi = new int(1024);string *ps = new string(10,'9');vector&lt;int&gt; *pv = new vector&lt;int&gt;&#123;0,1,2,3&#125;; é‡Šæ”¾åŠ¨æ€å†…å­˜delete p//på¿…é¡»æŒ‡å‘ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„å¯¹è±¡æˆ–è€…æ˜¯ä¸€ä¸ªç©ºæŒ‡é’ˆ1.é”€æ¯ç»™å®šçš„æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡ï¼›2.é‡Šæ”¾å¯¹åº”çš„å†…å­˜ï¼› int i,*pil=&amp;i,*pi2=nullptr;double *pd = new double(33),*pd2=pd;delete i;//é”™è¯¯ï¼Œiä¸æ˜¯ä¸€ä¸ªæŒ‡é’ˆdelete pil//æœªå®šä¹‰,pilæŒ‡å‘ä¸€ä¸ªå±€éƒ¨å˜é‡,é‡Šæ”¾ä¸€ä¸ªå¹¶énewåˆ†é…çš„å†…å­˜çš„è¡Œä¸ºæ˜¯æœªå®šä¹‰çš„delete pd;//æ­£ç¡®delete pd2;//æœªå®šä¹‰ï¼Œpd2æŒ‡å‘çš„å†…å­˜å·²ç»è¢«é‡Šæ”¾æ‰äº†delete pi2;//æ­£ç¡®ï¼Œé‡Šæ”¾ä¸€ä¸ªç©ºæŒ‡é’ˆæ€»æ˜¯æ²¡æœ‰é”™è¯¯çš„ å¯¹äºä¸€ä¸ªç”±å†…ç½®æŒ‡é’ˆç®¡ç†çš„åŠ¨æ€å¯¹è±¡ï¼Œç›´åˆ°è¢«æ˜¾ç¤ºé‡Šæ”¾ä¹‹å‰å®ƒéƒ½æ˜¯ä¸€ç›´å­˜åœ¨çš„ã€‚//factory è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„å¯¹è±¡Foo* factory(T arg)&#123; //å¤„ç†arg return new Foo(arg);//è°ƒç”¨è€…è´Ÿè´£é‡Šæ”¾æ­¤å†…å­˜&#125;void use_factory(T arg)&#123; Foo* p = factory(arg); //ä½¿ç”¨pä½†æ˜¯ä¸deleteå®ƒ&#125;//pç¦»å¼€äº†ä½œç”¨åŸŸï¼Œä½†å®ƒæ‰€æŒ‡å‘çš„å†…å­˜æ²¡æœ‰è¢«é‡Šæ”¾æ‰//ä¿®æ­£çš„æ–¹æ³•void use_factory(arg)&#123; Foo *p = factory(arg); //ä½¿ç”¨p delete p;//è®°å¾—é‡Šæ”¾å†…å­˜&#125;Foo* use_factory(arg)&#123; Foo *p =fatcory(arg); //ä½¿ç”¨p return p;//è°ƒç”¨è€…è´Ÿè´£é‡Šæ”¾å†…å­˜&#125;","categories":[],"tags":[{"name":"c++primer","slug":"c-primer","permalink":"http://Persuingsdu.github.io/tags/c-primer/"}]},{"title":"åŒå‘é“¾è¡¨","slug":"åŒå‘é“¾è¡¨","date":"2017-11-19T11:45:58.000Z","updated":"2017-11-22T14:40:32.510Z","comments":true,"path":"2017/11/19/åŒå‘é“¾è¡¨/","link":"","permalink":"http://Persuingsdu.github.io/2017/11/19/åŒå‘é“¾è¡¨/","excerpt":"å­¦ä¹ äº†ä¸€ä¸‹åŒå‘é“¾è¡¨çš„å®ç°ã€‚","text":"å­¦ä¹ äº†ä¸€ä¸‹åŒå‘é“¾è¡¨çš„å®ç°ã€‚Refernceæ•°æ®ç»“æ„çš„å®éªŒè¦æ±‚æŒæ¡é“¾è¡¨éå†å™¨çš„ä½¿ç”¨ï¼Œç”±äºä¹¦ä¸Šçš„é“¾è¡¨æ˜¯å•å‘é“¾è¡¨ï¼Œåˆ™è¿­ä»£å™¨ä¹Ÿåªèƒ½æ˜¯å‘å‰çš„è¿­ä»£å™¨ã€‚ä¸ºäº†å®ç°åŒå‘è¿­ä»£å™¨ï¼Œé‡‡ç”¨äº†åŒå‘é“¾è¡¨è¿™ä¸€æ•°æ®ç»“æ„ã€‚2017/11/22æ›´æ–°int main() &#123; vector&lt;doubleLink&lt;int&gt;*&gt; v;//å­˜æ”¾æŒ‡é’ˆ doubleLink&lt;int&gt; a; a.insert_first(3); a.output(cout); v.push_back(&amp;a); v[0]-&gt;output(cout);&#125; ç»“æ„ä½“çš„å®šä¹‰Dataéƒ¨åˆ†ä»¥åŠå‘å‰å’Œå‘åçš„æŒ‡é’ˆtemplate&lt;class T&gt;struct chainode &#123; T element; chainode&lt;T&gt;* pre; chainode&lt;T&gt;* next; chainode() &#123;&#125; chainode(T&amp; element) &#123; this-&gt;element = element; &#125; chainode(T&amp; element, chainode&lt;T&gt;* pre, chainode&lt;T&gt;* next) &#123; this-&gt;element = element; this-&gt;pre = pre; this-&gt;next = next; &#125;&#125;; åŒå‘é“¾è¡¨ç±»çš„å®ç°é‡ç‚¹æ˜¯å†…éƒ¨ç±»è¿­ä»£å™¨ç±»çš„å®ç°ã€‚//æ‰€æœ‰ä½ç½®çš„ä¸‹æ ‡æ˜¯ä»¥ 0 è®¡æ•°template&lt;class T&gt;class doubleLink &#123;public: doubleLink(); ~doubleLink(); int size() &#123; return listSize; &#125; bool empty() &#123; return listSize == 0; &#125; chainode&lt;T&gt;* get_node(int index);//è·å¾—indexä½ç½®ä¸Šçš„èŠ‚ç‚¹ T get(int index);//è·å¾—æŒ‡å®šä½ç½®ä¸Šçš„å…ƒç´  void insert_first(T element);//å°†å…ƒç´ æ’å…¥åˆ°ç¬¬ä¸€ä¸ªä½ç½® void append_last(T element); void insert(int index, T elemet);//å°†å…ƒç´ æ’å…¥åˆ°ç‰¹å®šçš„ä½ç½® void erase(int index);//åˆ é™¤æŒ‡å®šä½ç½®ä¸Šçš„å…ƒç´  void erase_e(T key);//åˆ é™¤æŒ‡å®šçš„å…ƒç´ ,å¦‚æœè¯¥å…ƒç´ ä¸å­˜åœ¨,åˆ™ä»€ä¹ˆä¹Ÿä¸æ“ä½œ,è¾“å‡ºæç¤ºè¯­å¥,è¿”å› int indexOf(T value);//è·å–å…ƒç´ çš„ä½ç½®,å¦‚æœä¸å­˜åœ¨å°±è¿”å› 0 void output(ostream&amp; out) const;//è¾“å‡ºé“¾è¡¨çš„å…ƒç´  void rcout(doubleLink&lt;T&gt;&amp; theChain); void merge(doubleLink&lt;T&gt;&amp; a, doubleLink&lt;T&gt;&amp; b);//å°†a,bè¿›è¡Œåˆå¹¶ class iterator; iterator begin() &#123; return iterator(firstNode-&gt;next); &#125;//ç¬¬ä¸€ä¸ªå…ƒç´  iterator end() &#123; return iterator(firstNode); &#125;//ç©ºçš„å¤´ç»“ç‚¹ //åŒå‘é“¾è¡¨çš„è¿­ä»£å™¨ class iterator &#123; public: // typedefs required by C++ for a forward iterator typedef forward_iterator_tag iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; //æ„é€ å‡½æ•° iterator(chainode&lt;T&gt;* theNode = NULL) &#123; node = theNode; &#125; // è§£å¼•ç”¨ T&amp; operator*() const &#123; return node-&gt;element; &#125; T* operator-&gt;() const &#123; return &amp;node-&gt;element; &#125; // å¢åŠ  iterator&amp; operator++() &#123; //å‰åŠ  node = node-&gt;next; return *this; &#125; iterator operator++(int) &#123;//ååŠ  iterator old = *this; node = node-&gt;next; return old; &#125; //é€’å‡ iterator&amp; operator--() &#123;//å‰å‡ node = node-&gt;pre; return *this; &#125; iterator operator--(int) &#123;//åå‡ iterator old = *this; node = node-&gt;pre; return old; &#125; //åˆ¤æ–­ bool operator!=(const iterator right) const&#123; return node != right.node; &#125; bool operator==(const iterator right) const&#123; return node == right.node; &#125;protected: chainode&lt;T&gt;* node;&#125;; private: int listSize; chainode&lt;T&gt;* firstNode;&#125;; å…·ä½“çš„æ–¹æ³•å®ç° æ„é€ å‡½æ•°åœ¨è¿™é‡Œåˆå§‹åŒ–ä¸€ä¸ªç©ºçš„è¡¨å¤´ï¼Œåœ¨é“¾è¡¨ä¸­å¤´ç»“ç‚¹Dataéƒ¨åˆ†ä¸ºç©ºï¼Œåˆå§‹åŒ–preä¸nextå‡ä¸ºè‡ªèº«ã€‚ //è¡¨å¤´ä¸å­˜å‚¨ä»»ä½•å…ƒç´ template&lt;class T&gt;doubleLink&lt;T&gt;::doubleLink() &#123; listSize = 0; firstNode = new chainode&lt;T&gt;();//ç©ºè¡¨å¤´ firstNode-&gt;pre = firstNode-&gt;next = firstNode;&#125; ææ„å‡½æ•°è¿™é‡Œçš„åˆ é™¤æ¯ä¸ªèŠ‚ç‚¹ä¸å•å‘é“¾è¡¨ç±»ä¼¼ï¼Œæ³¨æ„éå†çš„æ–¹å¼ï¼Œç”±äºæˆ‘ä»¬å¢åŠ äº†ä¸€ä¸ªç©ºçš„è¡¨å¤´ï¼Œå› æ­¤éå†çš„æ–¹å¼åŒå¾ªç¯é“¾è¡¨æœ€åï¼Œè¦åˆ é™¤ç©ºçš„è¡¨å¤´ã€‚ //ææ„å‡½æ•°template&lt;class T&gt;doubleLink&lt;T&gt;::~doubleLink() &#123; chainode&lt;T&gt;* p; chainode&lt;T&gt;* q = firstNode-&gt;next; while (q != firstNode) &#123; p = q; q = q-&gt;next; delete p; &#125; //åˆ é™¤è¡¨å¤´ delete firstNode;//å­˜åœ¨çš„å¯¹è±¡ firstNode = NULL;//èŠ‚ç‚¹æŒ‡å‘çš„å¯¹è±¡é‡ç½®ä¸ºNULL listSize = 0;&#125; è·å–æŒ‡å®šä½ç½®ä¸Šçš„èŠ‚ç‚¹å¯¹äºå•å‘é“¾è¡¨ï¼Œåªèƒ½ä»å¤´éå†ï¼Œä½†æ˜¯ç”±äºåŒå‘é“¾è¡¨èƒ½æ‰¾åˆ°å…¶å‰é©±ï¼Œäºæ˜¯æœ‰ä¸¤ç§æ–¹å¼ï¼Œä»å¤´å¼€å§‹æ‰¾æˆ–è€…ä»å°¾èŠ‚ç‚¹å¼€å§‹æ‰¾ï¼Œæ ¹æ®indexæ¥ç¡®å®šé‡‡å–ä½•ç§æ–¹å¼ï¼Œä»è€Œæ›´å¿«ã€‚ //è·å¾—ä½ç½®ä¸ºindexçš„èŠ‚ç‚¹template&lt;class T&gt;chainode&lt;T&gt;* doubleLink&lt;T&gt;::get_node(int index) &#123; if (index&lt;0 || index&gt;=listSize) &#123; throw invalid_argument(\"invalid_argument\"); &#125; //æ­£å‘æŸ¥æ‰¾ if (index &lt;= listSize / 2) &#123; chainode&lt;T&gt;* pos = firstNode-&gt;next; for (int i = 0; i &lt; index; i++) pos = pos-&gt;next; return pos; &#125; else &#123; int reverIndex = listSize - index - 1; chainode&lt;T&gt;* rpos = firstNode-&gt;pre;//å°¾èŠ‚ç‚¹ for (int j = 0; j &lt; reverIndex; j++) rpos = rpos-&gt;pre; return rpos; &#125;&#125; æ’å…¥å…ƒç´ ä¸åˆ é™¤å…ƒç´ è¿™ä¹Ÿæ˜¯ä¸å•å‘é“¾è¡¨çš„æ˜¾è‘—ä¸åŒçš„åœ°æ–¹ã€‚ æ’å…¥å…ƒç´  //åœ¨æŒ‡å®šä½ç½®ä¸Šæ’å…¥å…ƒç´ template&lt;class T&gt;void doubleLink&lt;T&gt;::insert(int index, T element) &#123; if (index == 0) &#123; insert_first(element); return; &#125; chainode&lt;T&gt;* pos = get_node(index); chainode&lt;T&gt;* newNode = new chainode&lt;T&gt;(element, pos-&gt;pre, pos); pos-&gt;pre-&gt;next = newNode; pos-&gt;pre = newNode; listSize++; return;&#125; åˆ é™¤å…ƒç´  //åˆ é™¤æŒ‡å®šä½ç½®ä¸Šçš„å…ƒç´ template&lt;class T&gt;void doubleLink&lt;T&gt;::erase(int index) &#123; chainode&lt;T&gt;* pos = get_node(index); pos-&gt;next-&gt;pre = pos-&gt;pre; pos-&gt;pre-&gt;next = pos-&gt;next; delete pos; listSize--; return;&#125; é“¾è¡¨çš„åå‘éå† //åå‘è¾“å‡ºé“¾è¡¨çš„å…ƒç´ template&lt;class T&gt;void doubleLink&lt;T&gt;::rcout(doubleLink&lt;T&gt;&amp; theChain) &#123; auto iter = --theChain.end(); while (iter != --theChain.begin()) &#123; cout &lt;&lt; *iter &lt;&lt; \" \"; iter--; &#125;&#125; ä¸¤ä¸ªæœ‰åºé“¾è¡¨åˆå¹¶ //mergeå°†a,bè¿›è¡Œåˆå¹¶,åˆå¹¶çš„æ–¹å¼ä¸ºbçš„å…ƒç´ åŠ åˆ°açš„å‰é¢template&lt;class T&gt;//é€’å¢çš„ä¸¤ä¸ªé“¾è¡¨è¿›è¡Œåˆå¹¶void doubleLink&lt;T&gt;::merge(doubleLink&lt;T&gt;&amp;a, doubleLink&lt;T&gt;&amp; b) &#123; auto ib = b.begin(); chainode&lt;T&gt;* pos = a.firstNode-&gt;next; int i = 0; while (pos != firstNode&amp;&amp;ib != b.end()) &#123; if (*ib &lt; pos-&gt;element) &#123; a.insert(i, *ib); ib++; &#125; else &#123; pos = pos-&gt;next; &#125; i++; &#125; while (ib != b.end()) &#123; a.append_last(*ib); ib++; &#125; b.~doubleLink();//ææ„b&#125;","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"Leetcode Backtracking","slug":"Leetcode-Backtracking","date":"2017-10-29T03:09:33.000Z","updated":"2017-10-29T08:45:42.499Z","comments":true,"path":"2017/10/29/Leetcode-Backtracking/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/29/Leetcode-Backtracking/","excerpt":"ç”¨æ¥æ€»ç»“leetcodeä¸Šçš„ä¸€ç±»é—®é¢˜","text":"ç”¨æ¥æ€»ç»“leetcodeä¸Šçš„ä¸€ç±»é—®é¢˜ Combinations Combination Sum Combinationsæ±‚å¹‚é›†é—®é¢˜æ¼”åŒ–ç‰ˆMy solution: int s = 0;void dfs(vector&lt;int&gt;&amp; ele, int n, int k, int i,vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; flag) &#123; if (s == k) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (flag[i] == 1) &#123; ele.push_back(i); c++; &#125; if (c == k) break; &#125; res.push_back(ele); ele.clear(); return; &#125; if (i &gt; n) return; flag[i] = 1; s++; dfs(ele, n, k, i + 1,res,flag); flag[i] = 0; s--; dfs(ele, n, k, i + 1,res,flag);&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;int&gt; flag(n + 1, 0); vector&lt;int&gt; ele; vector&lt;vector&lt;int&gt;&gt; res; dfs(ele, n, k, 1, res, flag ); return res;&#125; Combination SumDiscuss","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://Persuingsdu.github.io/tags/Leetcode/"}]},{"title":"BST","slug":"BFS","date":"2017-10-22T07:23:38.000Z","updated":"2017-10-28T11:50:56.944Z","comments":true,"path":"2017/10/22/BFS/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/22/BFS/","excerpt":"2017/10/28æ›´æ–°","text":"2017/10/28æ›´æ–° Kth Largest Element in an ArraySubsets Kth Largest Element in an Arrayquick sort int ans;void quick_sort(vector&lt;int&gt;&amp; s, int l, int r,int k)&#123; if (l &lt; r) &#123; //Swap(s[l], s[(l + r) / 2]); int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; s[j] &lt;= x) j--; if (i &lt; j) s[i++] = s[j]; while (i &lt; j &amp;&amp; s[i] &gt; x) i++; if (i &lt; j) s[j--] = s[i]; &#125; s[i] = x; if (i &gt; k-1 ) quick_sort(s, l, i - 1, k ); if (i &lt; k-1 ) // 2,3 3 quick_sort(s, i + 1, r, k); if (i == k-1 ) ans = s[i]; return; &#125; ans = s[l];&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; quick_sort(nums, 0, nums.size() - 1, k); return ans;&#125; SubsetsBacktarckingbacktracking &amp; bit manipulation &amp; iterativeDiscuss 2017/10/26æ›´æ–°Two Sum IV - Input is a BST Most Frequent Subtree Sum Two Sum IV - Input is a BSTæ°´é¢˜ï¼Œæ ‘çš„ä¸­åºéå† &amp; two pointervoid travel(TreeNode* root,vector&lt;int&gt;&amp; nums) &#123; if (!root) return; if (root-&gt;left) travel(root-&gt;left,nums); nums.push_back(root-&gt;val); if (root-&gt;right) travel(root-&gt;right,nums);&#125;bool findTarget(TreeNode* root, int k) &#123; vector&lt;int&gt; nums; travel(root,nums); if (nums[0]+nums[1] &gt; k) return false; int i = 0, j = nums.size() - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &gt; k) j--; else &#123; if (nums[i] + nums[j] &lt; k) i++; else return true; &#125; &#125; return false;&#125; 2017/10/25æ›´æ–°åˆå†™äº†ä¸€äº›å¾ˆçƒ‚çš„ä»£ç ï¼Œå¥½å¿ƒç„¦â€¦ä¸¤é“é¢˜çš„runtimeå‡æ’åœ¨50%å·¦å³â€¦æ•ˆç‡ä¸é«˜ï¼Œç¬¬ä¸€éåˆ·ï¼Œå…ˆèƒ½è¿‡ï¼Œä¹‹åå°è¯•æ›´å¿«çš„æ–¹æ³•ã€‚Convert BST to Greater Tree Validate Binary Search Tree Convert BST to Greater Tree void add(TreeNode* root,int value) &#123; if (!root) return; root-&gt;val += value; if (root-&gt;left) add(root-&gt;left,value); if (root-&gt;right) add(root-&gt;right, value);&#125;void dfs(TreeNode* root) &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right) return; if (root-&gt;right) &#123; dfs(root-&gt;right); TreeNode* p = root-&gt;right; while (p-&gt;left) p = p-&gt;left; root-&gt;val += p-&gt;val; &#125; if (root-&gt;left) &#123; dfs(root-&gt;left); add(root-&gt;left, root-&gt;val); &#125;&#125;TreeNode* convertBST(TreeNode* root) &#123; if(!root) return root; dfs(root); return root;&#125; Validate Binary Search Treeè¿™é“é¢˜çš„æ€æƒ³å°±æ˜¯å…ˆå¯¹å±€éƒ¨åˆ¤æ–­å·¦å³å­èŠ‚ç‚¹å’Œçˆ¶èŠ‚ç‚¹çš„å…³ç³»ï¼Œç„¶ååˆ¤æ–­çˆ¶èŠ‚ç‚¹æ˜¯å¦å¤§äºå·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ä»¥åŠçˆ¶èŠ‚ç‚¹æ˜¯å¦å°äºå³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚ç”¨äº†é€’å½’ï¼Œä½†æ˜¯å¿…é¡»é€’å½’å®Œæ‰€æœ‰çš„æƒ…å†µï¼Œæ— æ³•åšåˆ°åŠæ—¶ç»ˆæ­¢ï¼Œæœ‰æ—¶é—´ï¼Œå†è¿›è¡Œä¼˜åŒ–ã€‚ int ans = true;bool isValidBST(TreeNode* root) &#123; if (!root) return ans; if (root-&gt;left) &#123; if (root-&gt;left-&gt;val &gt;= root-&gt;val) ans= false; isValidBST(root-&gt;left); if (root-&gt;left-&gt;right) &#123; TreeNode* p = root-&gt;left-&gt;right; while (p) &#123; if (p-&gt;val &gt;= root-&gt;val) &#123; ans = false; &#125; p = p-&gt;right; &#125; &#125; &#125; if (root-&gt;right) &#123; if (root-&gt;right-&gt;val &lt;= root-&gt;val) ans= false; isValidBST(root-&gt;right); if (root-&gt;right-&gt;left) &#123; TreeNode* p = root-&gt;right-&gt;left; while (p) &#123; if (p-&gt;val &lt;= root-&gt;val) ans = false; p = p-&gt;left; &#125; &#125; &#125; return ans;&#125; c++å®ç°BST #pragma once#include&lt;iostream&gt;#include&lt;utility&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;struct TreeNode &#123; int value; TreeNode* left; TreeNode* right; TreeNode() &#123; value = 0; left = right = NULL; &#125; TreeNode(int val) &#123; value = val; left = right = NULL; &#125;&#125;;class bst &#123;public: bst() &#123;&#125;; bst(int val); void insert(const int&amp; val); void erase(const int&amp; val); int size() const &#123; return capacity; &#125; bool empty()&#123; return capacity == 0; &#125; void bfs();private: int capacity; TreeNode* root;&#125;;bst::bst(int val) &#123; root = new TreeNode(val); capacity = 1;&#125;void bst::bfs() &#123; if (capacity == 0) return; queue&lt;TreeNode*&gt; unvisted; unvisted.push(root); while (!unvisted.empty()) &#123; TreeNode* current = unvisted.front(); unvisted.pop(); if (current-&gt;left) unvisted.push(current-&gt;left); if (current-&gt;right) unvisted.push(current-&gt;right); cout &lt;&lt; current-&gt;value &lt;&lt; \" \"; &#125;&#125;void bst::insert(const int&amp; val) &#123; if (capacity == 0) root = new TreeNode(val); else &#123; TreeNode* newNode = new TreeNode(val); TreeNode* current = root; while (current) &#123; if (val &lt;= current-&gt;value) &#123; if (!current-&gt;left) &#123; current-&gt;left = newNode; break; &#125; else current = current-&gt;left; &#125; else &#123; if (!current-&gt;right) &#123; current-&gt;right = newNode; break; &#125; else current = current-&gt;right; &#125; &#125; &#125; capacity++;&#125;void bst::erase(const int&amp; val) &#123; TreeNode* current = root; TreeNode* target = root; int pos; while (current) &#123; if (val &lt;= current-&gt;value) &#123; if (current-&gt;left) if (val == current-&gt;left-&gt;value) &#123; target = current-&gt;left;//left=0; pos = 0; break; &#125; else current = current-&gt;left; else return; &#125; else &#123; if (current-&gt;right) if (val == current-&gt;right-&gt;value) &#123; target = current-&gt;right; pos = 1;//right=1; break; &#125; else current = current-&gt;right; else return; &#125; //cout &lt;&lt; current-&gt;value &lt;&lt; endl; &#125; //target ä¸ºè¦åˆ é™¤çš„ç›®æ ‡ //current ä¸ºå®ƒçš„çˆ¶èŠ‚ç‚¹ if (!target-&gt;left) &#123; if (!target-&gt;right) &#123; if (pos) current-&gt;right = NULL; else current-&gt;left = NULL; capacity--; return; &#125; else &#123; TreeNode* rmin = target-&gt;right;//rch min element TreeNode* pmin = target; while (rmin-&gt;left) &#123; pmin = rmin; rmin = rmin-&gt;left; &#125; pmin-&gt;left = NULL; if (rmin != target-&gt;right) rmin-&gt;right = target-&gt;right; if (pos) current-&gt;right = rmin; else current-&gt;left = rmin; capacity--; return; &#125; &#125; //targetæœ‰å·¦å­æ ‘ else &#123; //æ‰¾åˆ°å·¦å­æ ‘çš„max TreeNode* lmax = target-&gt;left;//rch min element TreeNode* pmax = target-&gt;left; while (lmax-&gt;right) &#123; pmax = lmax; lmax = lmax-&gt;right; &#125; //å­˜åœ¨å³å­æ ‘ pmax-&gt;right = NULL; if (lmax != target-&gt;left) lmax-&gt;left = target-&gt;left; if(target-&gt;right) lmax-&gt;right = target-&gt;right; if (pos) current-&gt;right = lmax; else current-&gt;left = lmax; capacity--; return; &#125;&#125;","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"},{"name":"bst","slug":"bst","permalink":"http://Persuingsdu.github.io/tags/bst/"}]},{"title":"Leetcode","slug":"DFS","date":"2017-10-15T15:58:22.000Z","updated":"2017-10-25T15:24:00.488Z","comments":true,"path":"2017/10/15/DFS/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/15/DFS/","excerpt":"2017/10/21æ›´æ–°äºå›¾ä¹¦é¦†","text":"2017/10/21æ›´æ–°äºå›¾ä¹¦é¦† Maximum Binary Tree é€’å½’å»ºæ ‘Populating Next Right Pointers in Each Node II bfsMaximum Depth of Binary Tree dfsBinary Tree Right Side View dfs / bfs 2017/10/20æ›´æ–°äºå›¾ä¹¦é¦†Leetcodeä¸Šå…³äºæ ‘çš„é€’å½’ç¨‹åºå¤§è‡´å¯ä»¥ç¼–å†™ä¸º:void dfs(TreeNode* root)&#123; ... if(root-&gt;left)&#123; ... dfs(root-&gt;left); ... &#125; if(root-&gt;right)&#123; ... dfs(root-&gt;right); ... &#125; ...&#125; å¤§è‡´ç»“æ„å¦‚ä¸Šï¼Œç„¶åé€‰æ‹©è¾ƒå°çš„æ•°æ®ï¼Œè·Ÿç€ç¨‹åºèµ°ä¸€éï¼Œä¿®æ­£æ¡ä»¶ï¼Œå³å¯ã€‚è¿™æ ·çš„åšæ³•å¯ä»¥è§£å†³å¤§å¤šæ•°çš„å…³äºæ ‘çš„dfsé—®é¢˜ï¼Œå…³é”®æ˜¯æ‰¾å¯»æ›´ä¼˜è§£ã€‚ ä¸‹é¢æ˜¯å…³äºæ ‘çš„bfsä¸dfs dfs è¾“å‡ºæ¯æ¡è·¯å¾„å¦‚ä¸‹é¢çš„é¢˜ç›®æ‰€è¿°ï¼Œä¸å†èµ˜è¿°ã€‚ bfs åˆ†è¡Œè¾“å‡ºæ¯è¡Œrowä¸­æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ä»£ç å¦‚ä¸‹vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; queue&lt;TreeNode*&gt; unvisted; if (root == NULL) return ans; int count = 1; int child = 0; unvisted.push(root); while (!unvisted.empty()) &#123; vector&lt;int&gt; element; while (count--) &#123; TreeNode* current = unvisted.front(); unvisted.pop(); element.push_back(current-&gt;val); if (current-&gt;left) &#123; unvisted.push(current-&gt;left); child++; &#125; if (current-&gt;right) &#123; unvisted.push(current-&gt;right); child++; &#125; &#125; ans.push_back(element); count = child; child = 0; &#125; return ans;&#125; åœ¨åšä¸€ä¸ªé¢˜ç›®æ—¶å‘ç°ç†è§£é”™äº†é¢˜ç›®ï¼Œäºæ˜¯å¼„å‡ºäº†ä¸€é“æ–°é¢˜ç›®åŸé¢˜ç»è¿‡å‡ æ¬¡Wrong Answerä¹‹åï¼Œå‘ç°ç†è§£é”™äº†é¢˜æ„â€¦äºæ˜¯æ„å¤–åœ°äº§ç”Ÿäº†ä¸€é“æ–°é¢˜ï¼šè¾“å‡ºå­˜åœ¨å·¦å¶å­èŠ‚ç‚¹çš„æ·±åº¦æœ€æ·±å¤„çš„ä¸€å±‚æœ€å·¦è¾¹çš„å·¦å¶å­èŠ‚ç‚¹çš„å€¼(æœ‰ç‚¹ç»•â€¦.)ä»£ç å¦‚ä¸‹ï¼šæ³¨æ„æ¯æ¬¡é€’å½’è°ƒç”¨ç»“æŸåï¼Œå›æº¯æ›´æ–°int depth = 0;int times = 1;int leftmost;int findBottomLeftValue(TreeNode* root) &#123; if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; if (times &gt; depth) leftmost = root-&gt;left-&gt;val; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; times--; return leftmost; &#125; if (root-&gt;left) &#123; times++; findBottomLeftValue(root-&gt;left); &#125; if (root-&gt;right) &#123; times++; findBottomLeftValue(root-&gt;right); &#125; times--; return leftmost;&#125; â€”â€”â€”â€”åŸæ–‡å¦‚ä¸‹â€”â€”â€”â€”è¿™ç¯‡æ–‡ç« ç”¨æ¥æ€»ç»“Leetcodeä¸Šä¸dfsç›¸å…³çš„é¢˜ç›®ï¼Œæ–¹æ³•ä¸æ˜¯æœ€ä½³ï¼Œä»¥åæ›´æ–°ã€‚ä¸æ ‘ç›¸å…³çš„structç»“æ„ï¼Œå¦‚ä¸‹å®šä¹‰struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; Path Sumlinkbool ans;bool hasPathSum(TreeNode* root, int sum) &#123; if (root == NULL) return false; if (root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) &#123; if (sum==root-&gt;val) return true; else return false; &#125; if (root-&gt;left != NULL) ans = hasPathSum(root-&gt;left, sum - root-&gt;val); if(ans==true) return ans; if (root-&gt;right != NULL) ans = hasPathSum(root-&gt;right, sum - root-&gt;val); return ans;&#125; Binary Tree Pathslinkå»æ‰äº†å¤šä½™å†…å®¹ï¼Œåªä¿ç•™ä¸»è¦ä»£ç string ans = \"\";vector&lt;string&gt; s;//å‰æ0-9void help(TreeNode* root) &#123; ans += root-&gt;val + '0'; if (root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) &#123; s.push_back(ans); ans.erase(ans.end() - 1); return; &#125; if (root-&gt;left != NULL) help(root-&gt;left); if (root-&gt;right != NULL) help(root-&gt;right); ans.erase(ans.end() - 1);//å›æº¯&#125;","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"}]},{"title":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","date":"2017-10-06T11:41:10.000Z","updated":"2017-10-06T12:29:26.316Z","comments":true,"path":"2017/10/06/å¹¶æŸ¥é›†/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/06/å¹¶æŸ¥é›†/","excerpt":"","text":"å¹¶æŸ¥é›†è·¯å¾„å‹ç¼©ï¼šæ¯æ¬¡æŸ¥æ‰¾æ—¶ï¼Œä»¤æŸ¥æ‰¾è·¯å¾„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½ç›´æ¥æŒ‡å‘æ ¹èŠ‚ç‚¹åˆå¹¶å‡½æ•°çš„æ€§èƒ½æ”¹è¿›ï¼šåˆ©ç”¨é‡é‡è§„åˆ™æˆ–è€…é«˜åº¦è§„åˆ™ï¼Œå…·ä½“ä»£ç è§æ–‡ç«  å¸¦æƒå¹¶æŸ¥é›† å®šä¹‰ä¸¤ä¸ªæ•°ç»„faå’Œrankï¼Œfaç”¨æ¥åˆ¤æ–­é›†åˆå…³ç³»ï¼Œrankç”¨æ¥æè¿°å…¶ä¸æ ¹èŠ‚ç‚¹çš„å…³ç³»ã€‚å› ä¸ºå…³ç³»æ»¡è¶³ä¼ é€’æ€§ï¼Œæ‰€ä»¥å¯ä»¥æ¨å¯¼å‡ºç»™å‡ºæ¡ä»¶ä¸‹çš„å½“å‰å…³ç³»ï¼Œå†åˆ¤æ–­ä¸ä¹‹å‰å·²æœ‰å…³ç³»æ˜¯å¦çŸ›ç›¾ã€‚ ä¾‹é¢˜ï¼š1.é£Ÿç‰©é“¾2.Find them,Catch them","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"},{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","permalink":"http://Persuingsdu.github.io/tags/å¹¶æŸ¥é›†/"}]},{"title":"çº¿æ®µæ ‘åŸºæœ¬æ“ä½œ(ä¸€)","slug":"çº¿æ®µæ ‘åŸºæœ¬æ“ä½œ-ä¸€","date":"2017-10-05T14:44:10.000Z","updated":"2017-10-31T12:06:02.288Z","comments":true,"path":"2017/10/05/çº¿æ®µæ ‘åŸºæœ¬æ“ä½œ-ä¸€/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/05/çº¿æ®µæ ‘åŸºæœ¬æ“ä½œ-ä¸€/","excerpt":"å›½åº†ä½œä¸šçš„éœ€è¦ï¼Œä»Šæ™šå­¦ä¹ äº†ä¸€ä¸‹çº¿æ®µæ ‘çš„åŸºæœ¬æ“ä½œâ€”â€”å»ºæ ‘,åŒºé—´æŸ¥è¯¢,å•ç‚¹æ›´æ–°åç»­å­¦ä¹ åŒºé—´æ›´æ–°åŠæ›´å¤šçš„çŸ¥è¯†,æ­¤å¤„åªæ”¾ä»£ç ã€‚ä¸»è¦å‚è€ƒæ­¤æ–‡ç«  æ•°æ®ç»“æ„â€”â€”çº¿æ®µæ ‘","text":"å›½åº†ä½œä¸šçš„éœ€è¦ï¼Œä»Šæ™šå­¦ä¹ äº†ä¸€ä¸‹çº¿æ®µæ ‘çš„åŸºæœ¬æ“ä½œâ€”â€”å»ºæ ‘,åŒºé—´æŸ¥è¯¢,å•ç‚¹æ›´æ–°åç»­å­¦ä¹ åŒºé—´æ›´æ–°åŠæ›´å¤šçš„çŸ¥è¯†,æ­¤å¤„åªæ”¾ä»£ç ã€‚ä¸»è¦å‚è€ƒæ­¤æ–‡ç«  æ•°æ®ç»“æ„â€”â€”çº¿æ®µæ ‘ 1.å»ºæ ‘é¦–å…ˆå†™ä¸€ä¸ªå‡½æ•°,è¯¥å‡½æ•°ç”¨æ¥æ›´æ–°çˆ¶èŠ‚ç‚¹,æŒ‡æ˜çˆ¶èŠ‚ç‚¹ä¸å·¦å­æ ‘ä¸å³å­æ ‘çš„å…³ç³»void pushup(int i) { segTree[i] = max(segTree[2 i],segTree[2 i + 1]);}è¿™é‡Œé¢çš„å…³ç³»æ˜¯å¯ä»¥è‡ªå®šä¹‰,å¯ä»¥è¿›è¡Œæ±‚å’Œ,æ±‚æœ€å°å€¼ç­‰ç­‰æ“ä½œ,è¿™é‡Œé€‰æ‹©äº†æœ€å¤§å€¼ä½œä¸ºç¤ºä¾‹//åˆ©ç”¨é€’å½’å»ºæ ‘void build(int i, int l, int r) { if (l == r) segTree[i] = value[l]; else { //é€’å½’æ„é€ å·¦å³å­æ ‘ build(2 i, l, (l + r) / 2); build(2 i + 1, (l + r) / 2 + 1, r); pushup(i);//å›æº¯æ›´æ–°çˆ¶èŠ‚ç‚¹ }} 2.åŒºé—´æŸ¥è¯¢iä»£è¡¨æŸ¥è¯¢çš„ç»“ç‚¹,(b,e)ä»£è¡¨è¯¥ç»“ç‚¹çš„èŒƒå›´,(l,r)ä»£è¡¨æŸ¥è¯¢ç»“ç‚¹çš„èŒƒå›´æ³¨æ„è¯¥å‡½æ•°çš„returnå€¼è¦ä¸pushupæ›´æ–°çˆ¶èŠ‚ç‚¹çš„ç›®çš„åŒ¹é…,æ­¤å¤„å°±æ˜¯è¿”å›è¯¥åŒºé—´çš„æœ€å¤§å€¼int query(int i, int b, int e, int l, int r) { int p1, p2; if (l &gt; e||r &lt; b) return INT_MIN; //æ— äº¤é›† if (b &gt;= l&amp;&amp;e &lt;= r) return segTree[i]; //éœ€è¦æŸ¥è¯¢çš„åŒºé—´å¤§äºiå­˜å‚¨çš„åŒºé—´ p1 = query(2 i, b, (b + e) / 2, l, r); p2 = query(2 i + 1, (b + e) / 2 + 1, e, l, r); return max(p1, p2);} 3.å•èŠ‚ç‚¹æ›´æ–°iä»£è¡¨ç»“ç‚¹,(b,e)ä»£è¡¨è¯¥èŠ‚ç‚¹çš„èŒƒå›´,pä»£è¡¨æˆ‘ä»¬è¦æ›´æ–°çš„ç»“ç‚¹ä½ç½®,vä»£è¡¨è¦é€’å¢çš„æ•°å€¼void update_single(int i, int b, int e, int p, int v) { if (b == e) { segTree[i] += v; return; } int m = (b + e) / 2; if (p &lt;= m) update_single(2 i, b, m, p, v); else update_single(2 i + 1, m + 1, e, p, v); pushup(i);//å›æº¯æ›´æ–°}ç‰¹åˆ«æ³¨æ„,åœ¨å®é™…ç”¨ä¸­,ç©ºé—´è¦å¼€4*N è°ƒè¯•ä»£ç const int maxn = 256;int segTree[4 maxn + 10];int value[maxn];int main() { //å¼€çš„ç©ºé—´ä¸º4N value[0] = 1; value[1] = 2; value[2] = 2; value[3] = 4; value[4] = 9; value[5] = 3; build(1, 0, 5); for (int i = 1; i &lt;= 20; i++) cout &lt;&lt; â€œseg â€œ &lt;&lt; i &lt;&lt; â€œ=â€ &lt;&lt; segTree[i] &lt;&lt; endl; //æˆ‘ä»¬å®šä¹‰pushupå¾—åˆ°çš„æœ€ç»ˆç»“æœä¾¿æ˜¯segTree[1] update_single(1, 0, 5, 3, 8); query(1, 0, 5, 2, 4);} 2017/10/9 äºå›¾ä¹¦é¦†æ›´æ–°ä¾‹é¢˜ Potted Flowerconst int maxn = 100010;struct node { int sum, maxNow, minNow; int lmax, lmin; int rmax, rmin; int left, right;} T[4 maxn];int value[maxn];int n, m;//ç‚¹æ•°ï¼Œä¿®æ”¹æ¬¡æ•°void pushup(int i) { T[i].sum = T[2 i].sum + T[2 i + 1].sum; T[i].lmax = max(T[2 i].lmax, T[2 i].sum + T[2 i + 1].lmax); T[i].lmin = min(T[2 i].lmin, T[2 i].sum + T[2 i + 1].lmin); T[i].rmax = max(T[2 i + 1].rmax, T[2 i + 1].sum + T[2 i].rmax); T[i].rmin = min(T[2 i + 1].rmin, T[2 i + 1].sum + T[2 i].rmin); T[i].maxNow = max(max(T[2 i].maxNow, T[2 i + 1].maxNow), T[2 i].rmax + T[2 i + 1].lmax); T[i].minNow = min(min(T[2 i].minNow, T[2 i + 1].minNow), T[2 i].rmin + T[2 i + 1].lmin);}void build(int i, int l, int r) { T[i].left = l; T[i].right = r; if (l == r) {//å¶å­ç»“ç‚¹ï¼Œå°†æ‰€æœ‰æ•°æ®åˆå§‹åŒ–ä¸ºdata[end],ä¹Ÿå°±æ˜¯çº¿æ®µæ ‘çš„å…ƒçº¿æ®µ T[i].sum = T[i].lmax = T[i].lmin = T[i].rmax = T[i].rmin = T[i].maxNow = T[i].minNow = value[l]; } else {//å·¦å³é€’å½’è¿›è¡Œå»ºæ ‘ int mid = (l + r) &gt;&gt; 1; build(2 i, l, mid); build(2 i + 1, mid+1, r); pushup(i); }}//iä»£è¡¨çº¿æ®µæ ‘ä¸­çš„èŠ‚ç‚¹,kä»£è¡¨è¦æ›´æ–°çš„æ•°å­—çš„position,vä»£è¡¨valuevoid update_single(int i,int k,int v) { if (T[i].left == T[i].right) {//æ›´æ–°å¶å­ç»“ç‚¹ T[i].sum = T[i].lmax = T[i].lmin = T[i].rmax = T[i].rmin = T[i].maxNow = T[i].minNow = v; return; } int mid = (T[i].left + T[i].right) &gt;&gt; 1; if (k &lt;= mid) update_single(2 i, k, v); else update_single(2 * i + 1, k, v); pushup(i);//æ³¨æ„æ›´æ–°çº¿æ®µæ ‘}int main() { int ans, k, v; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) scanf_s(â€œ%dâ€, &amp;value[i]); build(1, 1, n); cin &gt;&gt; m; while (mâ€“) { cin &gt;&gt; k &gt;&gt; v; update_single(1, k, v); if (T[1].sum == T[1].maxNow) ans = T[1].sum - T[1].minNow; else ans = max(T[1].maxNow, T[1].sum - T[1].minNow); cout &lt;&lt; ans &lt;&lt; endl; }}","categories":[],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://Persuingsdu.github.io/tags/æ•°æ®ç»“æ„/"},{"name":"ACM","slug":"ACM","permalink":"http://Persuingsdu.github.io/tags/ACM/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"http://Persuingsdu.github.io/tags/çº¿æ®µæ ‘/"}]},{"title":"å…³äºéƒ‘å·çš„è®°å¿†","slug":"å…³äºéƒ‘å·çš„è®°å¿†","date":"2017-10-05T07:33:33.000Z","updated":"2017-10-20T15:23:06.031Z","comments":true,"path":"2017/10/05/å…³äºéƒ‘å·çš„è®°å¿†/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/05/å…³äºéƒ‘å·çš„è®°å¿†/","excerpt":"","text":"å…³äºéƒ‘å·çš„è®°å¿†å…³äºéƒ‘å·æˆ‘çŸ¥é“çš„ä¸å¤šï¼Œä¸ºäº†çˆ±æƒ…æ›¾ç»å»è¿‡é‚£é‡Œå¤šå°‘æ¬¡åœ¨ç«è½¦ä¸Šè·¯è¿‡è¿™åŸå¸‚ï¼Œä¸€ä¸ªäººæ‚„æ‚„åœ°æƒ³èµ·å¥¹å¥¹è¯´å¥¹å–œæ¬¢éƒ‘å·å†¬å¤©çš„é˜³å…‰ï¼Œå··å­é‡Œé£˜æ»¡ç…¤ç‚‰çš„å‘³é“é›¾æ°”ç©¿è¿‡å¥¹å¹´è½»çš„è„–å­ï¼Œç›´åˆ°ä»Šå¤©éƒ½æ²¡æœ‰æ•£å»å…³äºéƒ‘å·æˆ‘æƒ³çš„å…¨æ˜¯ä½ ï¼Œæƒ³æ¥æƒ³å»éƒ½æ˜¯å¿æ‚”å’Œå§”å±ˆå…³äºéƒ‘å·æˆ‘çˆ±çš„å…¨æ˜¯ä½ ï¼Œçˆ±æ¥çˆ±å»ä¸æ˜ç™½çˆ±çš„æ„ä¹‰å…³äºéƒ‘å·åªæ˜¯å¶å°”æƒ³èµ·ï¼Œç°åœ¨å¥¹çš„å‘³é“éƒ½åœ¨å›å¿†é‡Œæ¯æ¬¡å’Œæœ‹å‹è¯´èµ·è¿‡å»çš„æ—…è¡Œï¼Œæˆ‘ä¸æ•¢è¯´æˆ‘æ›¾å»è¿‡é‚£é‡Œå…³äºéƒ‘å·æˆ‘æƒ³çš„å…¨æ˜¯ä½ ï¼Œæƒ³æ¥ç”Ÿæ´»æ— éæ˜¯ç—›è‹¦å’Œç¾ä¸½å…³äºéƒ‘å·æˆ‘çˆ±çš„å…¨æ˜¯ä½ ï¼Œçˆ±åˆ°æœ€åæˆ‘ä»¬éƒ½æ— è·¯å¯å»ä¼¼æ˜¯è€Œéæˆ–æ˜¯ä¸–äº‹å¯ç•ï¼Œæœ‰æƒ…æœ‰ä¹‰åˆæ˜¯æœ‰ç±³æ— ç‚Šæ—¶é—´æ”¹å˜äº†å¾ˆå¤šåˆä»€ä¹ˆéƒ½æ²¡æœ‰è®©æˆ‘å†ä¸€æ¬¡æ‹¥æŠ±ä½ ï¼Œéƒ‘å·","categories":[],"tags":[{"name":"ç”Ÿæ´»æ‚æ„Ÿ","slug":"ç”Ÿæ´»æ‚æ„Ÿ","permalink":"http://Persuingsdu.github.io/tags/ç”Ÿæ´»æ‚æ„Ÿ/"}]},{"title":"My first blog","slug":"My-first-blog","date":"2017-10-04T14:00:56.000Z","updated":"2017-10-26T13:38:53.357Z","comments":true,"path":"2017/10/04/My-first-blog/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/04/My-first-blog/","excerpt":"ä»Šå¤©æ˜¯ä¸­ç§‹èŠ‚ï¼Œä¸ªäººçš„å°åšå®¢ç»ˆäºæ­å»ºèµ·æ¥äº†ğŸ˜Šï¼","text":"ä»Šå¤©æ˜¯ä¸­ç§‹èŠ‚ï¼Œä¸ªäººçš„å°åšå®¢ç»ˆäºæ­å»ºèµ·æ¥äº†ğŸ˜Šï¼è®¿å®¢åœ°å›¾","categories":[],"tags":[{"name":"ç”Ÿæ´»æ‚æ„Ÿ","slug":"ç”Ÿæ´»æ‚æ„Ÿ","permalink":"http://Persuingsdu.github.io/tags/ç”Ÿæ´»æ‚æ„Ÿ/"}]}]}