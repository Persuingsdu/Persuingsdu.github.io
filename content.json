{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"document","date":"2018-01-20T06:05:27.000Z","updated":"2018-01-20T06:05:27.285Z","comments":true,"path":"document/index.html","permalink":"http://Persuingsdu.github.io/document/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象程序设计","slug":"面向对象程序设计","date":"2018-02-05T06:44:12.000Z","updated":"2018-02-05T13:19:43.972Z","comments":true,"path":"2018/02/05/面向对象程序设计/","link":"","permalink":"http://Persuingsdu.github.io/2018/02/05/面向对象程序设计/","excerpt":"","text":"面向对象程序设计ECMA-262把对象定义为“无序属性的集合，其属性可以包含基本值、对象或者函数”，严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都一个名字，而每个名字都映射到一个值。1.常用对象字面量创建这种使用Object来创建自定义对象的方法。var person=&#123; name:\"Nicholas\", age:29, job:\"Software Engineer\" sayName:function()&#123; console.log(this.name); &#125;&#125;; 属性类型ECMAScript中有两种属性：数据属性和访问器属性1.数据属性[[Configurable]],[[Enumerble]],[[Writable]],[[Value]]直接在对象上定义的属性，它们的前三种特性都被设置为true，而[[Value]]特性被设置为指定的值。使用Obejct.defineProperty()修改属性默认的特性，接受三个参数属性所在的对象、属性的名字和一个描述符对象。var person=&#123;&#125;;Object.defineProperty(person,\"name\",&#123; writable:false, value:\"Nicholas\"&#125;); 一旦把configurable设置为false之后就会有限制了。在调用Obejct.defineProperty()方法创建一个新的属性时，如果不指定，其三种特定都被设置为false。2.访问器属性[[Configurable]],[[Enumerable]],[[Get]],[[Set]]访问器属性不能够直接定义，必须使用Obejct.defineProperty()来定义。var book=&#123; _year:2004, edition:1&#125;;Object.defineProperty(book,\"year\",&#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year=newValue; this.edition+=newValue-2004;//设置一个属性的值会导致其它属性的值发生变化 &#125; &#125;&#125;);book.year = 2005;console.log(book.edition);//2 定义多个属性的值，使用Object.defineProperties，接受两个对象参数：一个对象是要添加或者修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。读取属性的特性Object.getOwnPropertyDescriptor();,接受两个参数：属性所在的对象和要读取其描述符的属性名称。 创建对象构造函数模式function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; console.log(this.name); &#125;&#125;var person1=new Person(\"Nicholas\",29,\"Software Engineer\"); 存在的问题：每个方法在每个实例上都要重新创建一遍。原型模式我们创建的每个函数都一个prototype(原型)属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。每当代码读取某个对象的某个属性时，都会执行一次搜索，首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值。如果没有这个值，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。当为对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。使用delete操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。使用hasOwnProperty()方法可以检测一个属性是否存在于实例中，还是存在于原型中。更简单的原型语法function Person()&#123;&#125;Person.prototype=&#123; constructor:Person, name:\"Nicholas\", age:29, job:\"Software Engineer\", sayName:function()&#123; console.log(this.name); &#125;&#125;; 原型的动态性var friend=new Person();Person.prototype.sayHi=function()&#123; console.log(\"Hi\")&#125;friend.sayHi();//Hi 原型对象存在数据共享的问题。组合使用构造函数和原型模式避免构造函数和原型对象产生的问题。function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=[\"Shelby\",\"Court\"];&#125;Person.prototype=&#123; constructor:Person, sayName:function()&#123; console.log(this.name); &#125;&#125;var person1=new Person(\"Nicholas\",29,\"Software Engineer\");var person2=new Person(\"Grey\",27,\"Doctor\");person1.friends.push(\"Van\");console.log(person1.friends);//\"Shelby,Court,Van\"console.log(person2.friends);//\"Shelby,Court\" 继承ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针1.实现原型链的基本模式function SuperType()&#123; this.propery=true;&#125;SuperType.prototype.getSuperValue=function()&#123; return this.propery;&#125;function SubType()&#123; this.subproperty=false;&#125;//继承了SuperTypeSubType.prototype=new SuperType();SubType.prototype.getSubValue=function()&#123; return this.subproperty;&#125;var instance=new SubType();console.log(instance.getSuperValue());//true 关系图示原型链存在的问题：1.包含引用类型值的原型。2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。使用构造函数传递参数function SuperType(name)&#123; this.name=name;&#125;function SubType()&#123; //继承了SuperType,同时还传递了参数 SuperType.call(this,\"Nicholas\"); this.age=29;&#125;var instance=new SubType();console.log(instance.name);console.log(instance.age); 组合继承组合继承（combination inheritance）：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。function SuperType(name)&#123; this.name=name; this.colors=[\"red\",\"blue\",\"green\"];&#125;SuperType.prototype.sayName=function()&#123; console.log(this.name);&#125;function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age=age;&#125;//继承方法SubType.prototype=new SuperType();SubType.constructor=SubType;SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;;var instance1=new SubType(\"Nicholas\",29);instance1.colors.push(\"black\");console.log(instance1.colors);//\"red,blue,green,black\"instance1.sayName();//Nichaolasinstance1.sayAge();//29var instance2=new SubType(\"Grey\",27);console.log(instance2.colors);//\"red,blue,green\"instance2.sayName();//Greyinstance2.sayAge();//27 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，称为JavaScript中最常用的继承模式。原型式继承要求必须有一个对象作为另一个对象的基础。ECMAScript5通过新增Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义的额外的属性。var person=&#123; name:\"Nicholas\", friends:[\"Shelby\",\"Court\",\"Van\"]&#125;;var anotherPerson=Object.create(person);anotherPerson.name=\"Grey\";anotherPerson.friends.push(\"Rob\");var yetAnotherPerson=Object.create(person);yetAnotherPerson.name=\"Linda\";yetAnotherPerson.friends.push(\"Barbie\");console.log(person.friends);//\"Shelby,Court,Van,Rob,Barbie\" 寄生式继承寄生式（parasitic）即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。function createAnother(original)&#123; var clone=Object(original); clone.sayHi=function()&#123; console.log(\"Hi\"); &#125; return clone;&#125;var person=&#123; name:\"Nicholas\", friends:[\"Shelby\",\"Court\",\"Van\"]&#125;;var anotherPerson=createAnother(person);anotherPerson.sayHi();//Hi 包含引用类型的值始终会共享相应的值。寄生组合式继承function inheritPrototype(subType,superType)&#123; var prototype=Object(superType.prototype); prototype.constructor=subType; subType.prototype=prototype;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Persuingsdu.github.io/tags/javascript/"}]},{"title":"引用类型","slug":"引用类型","date":"2018-01-31T14:50:30.000Z","updated":"2018-02-02T15:25:38.786Z","comments":true,"path":"2018/01/31/引用类型/","link":"","permalink":"http://Persuingsdu.github.io/2018/01/31/引用类型/","excerpt":"","text":"引用类型引用类型的值（对象）是引用类型的一个实例。引用类型有时候也被称为对象定义，因为它们描述的是一类对象具有的属性和方法；新对象是使用new操作符和一个构造函数来创建。 Object类型创建Object实例的方法：1.使用new操作符后跟Object构造函数var person = new Object();person.name = \"Nicholas\";person.age = 29; 2.使用对象字面量表示方法var person = &#123;name:\"Nicolas\",age:29&#125; var person=&#123;&#125;;//与new Object()相同person.name=\"Nicholas\";person.age=29; 开发人员更青睐于使用对象字面量语法，因为语法要求的代码量少，并且有封装数据的感觉，同时，也是向函数传递大量可选参数的首选方式，例如：function displayInfo(args)&#123; var output=\"\"; if(typeof args.name==\"string\")&#123; output+=\"Name:\"+args.name+\"\\n\"; &#125; if(typeof args.age==\"number\")&#123; output+=\"Age:\"+args.age+\"\\n\"; &#125; console.log(output);&#125;displayInfo(&#123;name:\"Nicholas\",age:29&#125;);displayInfo(&#123;name:\"Grey\"&#125;); Array类型创建数组的基本方式var colors=new Array();var colors=new Array(20);var colors=new Arry(\"red\",\"green\",\"blue\"); 第二种使用数组字面量表示法var colors=[\"red\",\"green\",\"blue\"];var names=[];//创建一个空数组 可以通过索引来访问元素，如果设置某个值的索引超过了该数组的现有项数，数组就会自动添加到该索引的值加1var colors=[\"red\",\"green\",\"blue\"];colors[99]=\"black\";alert(colors.length);//100//数组大小为100，位置3-98实际上是不存在的，所有访问它们，都将返回undefined 另外，可以通过修改数组的length属性，可以从数组的末尾移除项或者向数组中添加新项；var colors=[\"red\",\"green\",\"blue\"];colors.length=2;alert(colors[2]);//undefined 检测数组if(Array.isArray(value))确定某个对象是不是数组栈方法ECMAScript专门提供了push()和pop()方法，以便实现类似栈的行为。push()方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后的数组的长度。var colors=new Array();var count=colors.push(\"red\",\"green\");//2 pop()方法var item=colors.pop();//item=\"green\" 队列方法shift()移除数组中的第一项并且返回该项，同时数组的长度减1。unshift()可以在数组的前端添加任意个项并返回新数组的长度。重排序方法reverse()反转数组项的顺序sort()会调用每个数据项的toString()方法，然后比较字符串来排序，即便是数组中的每一项都是数值。利用比较函数排序function compare(value1,value2)&#123; return value1-value2;&#125;var values=[0,1,5,10,15];values.sort();//0,1,10,15,5values.sort(compare);//15,10,5,1,0 操作方法concat()var colors=[\"red\",\"green\",\"blue\"];var colors2=colors.concat(\"yello\",[\"black\",\"brown\"]); slice()方法接受一个参数或者两个参数，接受一个参数，返回该位置到数组末尾的所有项。两个参数，返回起始位置和结束位置之间的项，但不包括结束项。splice()1.删除：指定两个参数，第一项的位置和要删除的项数。splice(0,2)2.插入：指定三个参数，起始位置，0，要插入的项splice(0,2,&quot;red&quot;,&quot;green&quot;)3.替换：指定三个参数，起始位置，要删除的项数，要插入的任意数量的项。splice(2,1,&quot;red&quot;,&quot;greem)位置方法indexOf()和lastIndexOf()接受两个参数：要查找的项和（可选的）表示查找起点位置索引。迭代方法每个方法接受2个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象。传入这些方法中的函数会接受三个参数：数据项的值，该项在数组中的位置和数组对象本身。1.every()每一项都返回true，返回true。2.filter()返回函数会返回true的项组成的数组。3.forEach()无返回值。4.map()对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。5.some()如果函数的任一项返回true，则返回true。every()var numbers=[1,2,3,4,5,4,3,2,1];var everyResult=numbers.every(function(item,index,array)&#123; return(item&gt;2);&#125;);//falsevar someResult=numbers.some(function(item,index,array)&#123; return(item&gt;2);&#125;);//truevar filterResult=numbers.filter(function(item,index,array)&#123; return(item&gt;2);&#125;);//3,4,5,4,3var mapResult=numbers.map(function(item,index,array)&#123; return item*2;&#125;);//2,4,6,8,10,8,6,4,2 归并方法两个归并数组的方法reduce()和reduceRight,这两个方法都会迭代数组的所有项，然后构建一个最终的返回值。这两个方法接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。其中函数接受四个参数：前一个值，当前值，项的索引，数组对象。var value=[1,2,3,4,5];var sum=value.reduce(function(pre,cur,index,array)&#123; return pre+cur;&#125;); Date类型创建日期对象var now=new Date(); RegExp类型 正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。其它参考 Function类型函数是对象，函数名是指针。function sum(num1,num2)&#123; return num1+num2;&#125;//函数声明var sum=function(num1,num2)&#123; return num1+num2;&#125;;//函数表达式 一个函数可能有多个名字function sum(num1,num2)&#123; return num1+num2;&#125;alert(sum(10,10);//20var anotherSum=sum;sum=null;alert(anotherSum(10,10));//20 没有重载作为值的函数将一个函数像传递参数一样传递给另一个函数。也可以作为一个函数的结果返回：function createComparisonFunction(propertyName)&#123; return function(object1,object2)&#123; var value1=object1[propertyName]; var value2=object2[propertyName]; if(value1&gt;value2)&#123; return -1; &#125;else if(value1&lt;value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;;&#125;var data=[&#123;name:\"Zachary\",age:28&#125;,&#123;name:\"Nicholas\",age:29&#125;];data.sort(createComparisonFunction(\"name\"));//data[0].name=Nicholasdata.sort(createComparisonFunction(\"age\"));//data[0].name=Zachary 函数属性和方法apply()和call()用途为在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply()接受两个参数：1.运行函数的作用域 2.参数数组（可以是Array实例或者是argument对象）call()传递给函数的参数必须逐个列举出来。事实上，它们真正强大的地方在于扩充函数赖以运行的作用域。window.color=\"red\";var o=&#123;color:\"blue\"&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor.call(this);//redsayColor.call(o);//bluesayColor.call(window);//red 基本包装类型为了便于操作基本类型值，ECMAScript还提供了三个特殊的引用类型Boolean，Number,String。引用类型和基本包装类型的主要区别就是对象的生存周期。var s1=\"some text\";s1.color=\"red\";alert(s1.color);//undefined String类型创建String对象var stringObject=new String(&quot;hello world&quot;);1.字符方法charAt(),charCodeAt()2.字符串操作方法concat()(实践中更多使用+)slice()和substring()根据start和end的值，截取子串，只有一个参数，默认end为结尾。substr()根据start和numbers的值，截取字串，只有一个参数，默认截取到字符串尾部。3.字符串位置方法indexOf()和lastIndexOf(),接受一个参数，表示起始搜索点。4.trim()方法删除前置和后缀的所有空格。5.字符串大小写转换方法toLowerCase()和toUpperCase()6.字符串模式匹配match()接受一个参数：要么是一个正则表达式，要么是一个RegExp对象。search()唯一的参数与match()相同，返回字符串中第一个匹配项的索引。replace()第一个参数可以是字符串或者是一个RegExp对象，第二个参数可以是一个字符串或者一个函数。split()基于指定的分隔符将一个字符串分割成多个字串，并将结果放在一个数组中。7.localCompare()方法这个方法比较两个字符串。var stringValue=\"yellow\";console.log(stringValue.localeCompare(\"brick\"));//1console.log(stringValue.localeCompare(\"yellow\"));//0console.log(stringValue.localeCompare(\"zoo\"));//-1","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://Persuingsdu.github.io/tags/JavaScript/"}]},{"title":"","slug":"随笔”","date":"2018-01-26T15:53:23.000Z","updated":"2018-01-26T16:24:06.970Z","comments":true,"path":"2018/01/26/随笔”/","link":"","permalink":"http://Persuingsdu.github.io/2018/01/26/随笔”/","excerpt":"","text":"我住的城市从不下雪记忆却堆满冷的感觉思念的旺季霓虹扫过喧哗的街把快乐赶得好远落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞它陪我过夜Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞它陪我过夜Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑电话不接不要被人发现我整夜都关在房间狂欢的笑声听来像哀悼的音乐眼眶的泪 温热冻结望着电视里的无聊节目躺在沙发上变成没知觉的植物Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑Merry christmasMerry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑谁来陪我过这圣诞节","categories":[],"tags":[]},{"title":"Trie","slug":"Trie","date":"2017-12-24T07:12:34.000Z","updated":"2017-12-29T09:01:48.036Z","comments":true,"path":"2017/12/24/Trie/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Trie/","excerpt":"字典樹","text":"字典樹學習了一下字典樹的簡單實現方式Reference节点的定义#define Maxn 26struct trieNode &#123; int count;//以该节点为结尾的单词的个数 trieNode* next[Maxn]; trieNode(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;; 在字典中插入新的字符串void insert(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root;//根节点 //一个一个字符插入 for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a';//26个字母中的位置 if (p-&gt;next[index]==NULL) p-&gt;next[index] = new trieNode(0);//创建 p = p-&gt;next[index]; &#125; //以该字符为结尾的单词 p-&gt;count++;&#125; 刪除字典中的元素void del(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) return; p = p-&gt;next[index]; &#125; p-&gt;count--;&#125; 查找字典中是否存在某個字符串bool search(trieNode* root, string str) &#123; if (root == NULL) &#123; return false; &#125; int size = str.size(); trieNode *p = root; int index; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; // 无法转移到下一个字符 if (p-&gt;next[index] == NULL) &#123; return false; &#125;//if // 继续下一个字符 p = p-&gt;next[index]; &#125; return p-&gt;count &gt; 0;//是否有&#125; 遍曆輸出整個字典//利用递归程序查询整个字典void printDic(trieNode* root, vector&lt;vector&lt;char&gt;&gt; &amp;words, vector&lt;char&gt; &amp;word) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;count &gt; 0) &#123; words.push_back(word); &#125;//到了根且有值 for (int i = 0; i &lt; 26; ++i) &#123; if (root-&gt;next[i]) &#123;//26个循环 word.push_back('a' + i); printDic(root-&gt;next[i], words, word); word.pop_back();//回溯 &#125; &#125;&#125; LeetCode上的相關題目一.題目鏈接使用字典樹的解法#define Maxn 26struct node &#123; int count; int value; node* next[Maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;;class MapSum &#123;public: /** Initialize your data structure here. */ MapSum() &#123; root = new node(0); &#125; void insert(string key, int val) &#123; int size = key.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = key[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++; p-&gt;value = val; &#125; node* help(string prefix) &#123; int size = prefix.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = prefix[i] - 'a'; if (p-&gt;next[index] == NULL) return NULL; p = p-&gt;next[index]; &#125; return p;//有该前缀 &#125; void search(node* root,int&amp; res) &#123; if (root == NULL)//空 return; if (root-&gt;count &gt; 0) res += root-&gt;value; for (int i = 0; i &lt; Maxn; i++) if (root-&gt;next[i]) search(root-&gt;next[i], res); &#125; int sum(string prefix) &#123; int res = 0; node* current = help(prefix); search(current,res); return res; &#125;private: node* root;&#125;; 二.題目鏈接#define maxn 26struct node &#123; int count; node* next[maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; maxn; i++) next[i] = NULL; &#125;&#125;;void insert(node* root,string str)&#123; int size = str.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++;&#125;int search(node* &amp;root, char c) &#123; if (root == NULL) &#123; return -1; &#125; int index = c - 'a'; if (root-&gt;next[index] == NULL) return -1;//不存在 root = root-&gt;next[index]; if (root-&gt;count &gt; 0) return 1;//存在 return 0;//可能存在&#125;string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) &#123; int size = dict.size(); node* root = new node(0); string res = \"\"; for (int i = 0; i &lt; size; i++) insert(root, dict[i]); int keysize = sentence.size(); for (int j = 0; j &lt; keysize; ) &#123; node* p = root; string element = \"\"; bool tag = false; while (j &lt; keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; int com = search(p, sentence[j]); if (com==-1) &#123; j++; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; j++; &#125; res += element; res += \" \"; tag = true; break; &#125; if (com == 0) &#123; //do noing &#125; if (com == 1) &#123; res += element; res += \" \"; tag = true; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') j++; break; &#125; j++; &#125; if (!tag) &#123; res += element; res += \" \"; &#125; j++; &#125; res.pop_back(); return res;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]}]}