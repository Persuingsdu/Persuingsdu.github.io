{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"About","date":"2017-12-30T11:11:09.847Z","updated":"2017-12-30T11:11:09.847Z","comments":true,"path":"about/index.html","permalink":"http://Persuingsdu.github.io/about/index.html","excerpt":"","text":"山東大學計算機科學與技術專業在讀位于青島市即墨區東裏村一個小白，正在學習之中微信 amastaciaQQ 1169284282 _hcwp = window._hcwp || [];_hcwp.push({widget:”Stream”, widget_id: 99554});(function() {if(“HC_LOAD_INIT” in window)return;HC_LOAD_INIT = true;var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || “en”).substr(0, 2).toLowerCase();var hcc = document.createElement(“script”); hcc.type = “text/javascript”; hcc.async = true;hcc.src = (“https:” == document.location.protocol ? “https” : “http”)+”://w.hypercomments.com/widget/hc/99554/“+lang+”/widget.js”;var s = document.getElementsByTagName(“script”)[0];s.parentNode.insertBefore(hcc, s.nextSibling);})();comments powered by HyperComments"},{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Photo","date":"2017-12-29T09:22:50.000Z","updated":"2017-12-30T11:10:05.583Z","comments":true,"path":"photo/index.html","permalink":"http://Persuingsdu.github.io/photo/index.html","excerpt":"","text":"這是一個假的實現相冊的功能，現在還不會，學了前端再說（但願能學會"},{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"岁末","slug":"岁末","date":"2017-12-30T10:40:16.000Z","updated":"2017-12-30T10:54:10.753Z","comments":true,"path":"2017/12/30/岁末/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/30/岁末/","excerpt":"","text":"今天中午去了一趟海邊，下午給博客增加了評論的功能。一開始用的是Disqus，然而祖國的高牆導致不通過科學上網的方式，無法加載出來，于是放棄。又用了gitment，然而，只能通過GitHub登陸，又放棄了。最後選擇了Hypercomment，免費的Lite版本，最終實現了評論的功能。馬上一年又過去了，感覺自己還是太水了，下面要好好加油了。剛剛看到一個小夥伴的博客，感覺很不錯呢。","categories":[{"name":"生活","slug":"生活","permalink":"http://Persuingsdu.github.io/categories/生活/"}],"tags":[]},{"title":"KMP","slug":"KMP","date":"2017-12-29T06:21:36.000Z","updated":"2017-12-29T08:59:56.113Z","comments":true,"path":"2017/12/29/KMP/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/29/KMP/","excerpt":"字符串問題","text":"字符串問題參考鏈接讀書筆記，大致了解一下。KMP算法的關鍵在于求出next數組，next數組考慮的是除當前字符外的最長相同的前綴和後綴。next數組告訴我們，當模式串中的某個字符跟文本串中的某個字符匹配失配時，模式串下一步應該跳到哪個位置。注意前綴不包含最後一個元素，後綴不包含第一個元素。失配時，模式串向右移動的位數為：失配字符所在位置 - 失配字符對應的next值。問題的關鍵在于如何計算出next數組。遞推計算出next數組void getNext(string p, vector&lt;int&gt;&amp; next) &#123; int size = p.size(); next[0] = -1; int k = -1; int j = 0; while (j &lt; size - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; if (p[j] != p[k]) next[j] = k; else next[j] = next[k]; &#125; else k = next[k]; &#125;&#125; 基于next數組的字符串匹配int KmpSearch(string s, string p,vector&lt;int&gt;&amp; next) &#123; int i = 0; int j = 0; int sLen = s.size(); int pLen = p.size(); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 //移动 j = next[j]; &#125; if (j == pLen) return i - j; else return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/tags/算法/"}]},{"title":"Huffman","slug":"Hffuman","date":"2017-12-28T13:22:32.000Z","updated":"2017-12-30T11:10:08.480Z","comments":true,"path":"2017/12/28/Hffuman/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/28/Hffuman/","excerpt":"利用Stl中的優先隊列，實現Huffman樹和Huffman編碼問題","text":"利用Stl中的優先隊列，實現Huffman樹和Huffman編碼問題樹的定義#pragma once#include&lt;iostream&gt;using namespace std;struct treeNode &#123; int element; treeNode* leftChild; treeNode* rightChild; treeNode(const int&amp; theElement, treeNode* left, treeNode* right) &#123; element = theElement; leftChild = left; rightChild = right; &#125;&#125;;class linkedTree &#123;public: linkedTree() &#123; root = NULL; treeSize = 0; &#125; int size() &#123; return treeSize; &#125; treeNode* getRoot() &#123; return root; &#125; void makeTree(const int&amp; , linkedTree&amp;, linkedTree&amp;);private: treeNode* root; int treeSize;&#125;;//合并void linkedTree::makeTree(const int&amp; theElement, linkedTree&amp; left, linkedTree&amp; right) &#123; root = new treeNode(theElement, left.root, right.root);// this-&gt;treeSize = left.size + right.size + 1; left.root = right.root = NULL; left.treeSize = right.treeSize = 0;&#125; Huffman節點的定義：每個節點都含有指向一個樹的指針和權值,並且含有自定義的比較函數，以期利用優先隊列struct huffmanNode &#123; linkedTree* tree;//树 int weight; huffmanNode() &#123;&#125;; huffmanNode(linkedTree* theTree, int theWeight) &#123; tree = theTree; weight = theWeight; &#125; friend bool operator &lt;(huffmanNode a, huffmanNode b) &#123; return a.weight &gt; b.weight; &#125;&#125;; 構建Huffman樹linkedTree* huffmanTree(vector&lt;int&gt;&amp; weight) &#123; priority_queue&lt;huffmanNode&gt; p; int size = weight.size(); huffmanNode* hNode = new huffmanNode[size + 1];//数组 linkedTree emptyTree; for (int i = 1; i &lt;= size; i++) &#123; hNode[i].weight = weight[i - 1]; hNode[i].tree = new linkedTree();//实体化树 hNode[i].tree-&gt;makeTree(weight[i-1], emptyTree, emptyTree); p.push(hNode[i]); &#125; while (p.size() != 1) &#123; huffmanNode a = p.top(); p.pop(); huffmanNode b = p.top(); p.pop(); int newWeight = a.weight + b.weight; linkedTree* newTree = new linkedTree(); newTree-&gt;makeTree(newWeight, *a.tree, *b.tree); huffmanNode c(newTree, newWeight); p.push(c); &#125; return p.top().tree;&#125; 實現Huffman編碼void dfs(treeNode* root, vector&lt;int&gt;&amp; e, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (!root-&gt;leftChild &amp;&amp; !root-&gt;rightChild) &#123; e.push_back(root-&gt;element); res.push_back(e);//标明元素 e.pop_back(); &#125; if (root-&gt;leftChild) &#123; e.push_back(0); dfs(root-&gt;leftChild, e, res); &#125; if (root-&gt;rightChild) &#123; e.push_back(1); dfs(root-&gt;rightChild, e, res); &#125; if (!e.empty()) e.pop_back();//回溯&#125;vector&lt;vector&lt;int&gt;&gt; huffmanCode(vector&lt;int&gt;&amp; weight) &#123; linkedTree* tree = huffmanTree(weight); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; e; dfs(tree-&gt;getRoot(), e, res); return res;&#125; 測試數據int main() &#123; vector&lt;int&gt; a = &#123; 5,4,3,2,1 &#125;; linkedTree* tree = huffmanTree(a); tree-&gt;dfsTravel(); cout &lt;&lt; endl; vector&lt;vector&lt;int&gt;&gt; res = huffmanCode(a); for (int i = 0; i &lt; res.size(); i++) &#123; for (int j = 0; j &lt; res[i].size(); j++) &#123; if (j == res[i].size() - 1) &#123; cout &lt;&lt; endl; cout &lt;&lt; \"对应的编码为: \"; &#125; cout &lt;&lt; res[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125; Huffman樹 15 / \\6 9 / \\ / \\ 3 3 4 5 / \\ 1 2 結果輸出","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"Graph","slug":"Graph","date":"2017-12-27T04:58:44.000Z","updated":"2017-12-29T09:00:58.665Z","comments":true,"path":"2017/12/27/Graph/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/27/Graph/","excerpt":"圖","text":"圖一個連通圖的生成樹是指一個連通子圖，它含有圖中全部n個頂點，但只有足以構成一棵樹的n-1條邊。一顆有n個頂點的生成樹有且僅有n-1條邊，如果生成樹中再添加一條邊，則必定成環。最小生成樹是一副連通加權無向圖中一棵權值最小的生成樹。先寫一點，後面慢慢更新。代碼和參考鏈接，慢慢學習。可視化工具一些節點的定義#pragma once#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define INF 0xfffff//权值的上限struct node &#123; node(int vertex, int weight, node* next) &#123; this-&gt;vertex = vertex; this-&gt;weight = weight; this-&gt;next = next; &#125; int vertex; int weight;//权值 node* next;&#125;;struct head &#123; int data;//储存头结点信息 node* first;//第一个边&#125;;struct pNode &#123; int key; int v; friend bool operator&lt;(pNode a, pNode b) &#123; return a.key &gt; b.key;//权值小的优先级高 &#125;&#125;; 類的定義及方法class wuGraph &#123;public: wuGraph(int vertex); int getVertex() &#123; return vertex; &#125; int getArc() &#123; return arc; &#125; void insert(int l, int r, int weight);//头插法 void printGraph(); void dfs(int start); void dfsTravel(); void bfs(int start); void bfsTravel(); void minTree();private: head* graph; int vertex; int arc; bool* visited;&#125;;wuGraph::wuGraph(int theVertex) &#123; vertex = theVertex; visited = new bool[vertex + 1]; graph = new head[vertex + 1]; //1 - vertex for (int i = 1; i &lt;= vertex; i++) &#123; graph[i].data = i; graph[i].first = NULL; &#125; &#125;//插入边void wuGraph::insert(int l, int r, int weight) &#123;//l - r -weight //l - r node* rNode = new node(r, weight, graph[l].first); graph[l].first = rNode; //r - l node* lNode = new node(l, weight, graph[r].first); graph[r].first = lNode; arc++;&#125;void wuGraph::printGraph() &#123; //1 - vertex cout &lt;&lt; \"邻接表如下所示：\" &lt;&lt; endl; for (int i = 1; i &lt;= vertex; i++) &#123; cout &lt;&lt; graph[i].data&lt;&lt; \" &gt;\"; node* p = graph[i].first; while (p) &#123; cout &lt;&lt; \"---&gt;\"; cout &lt;&lt; \"weight:\" &lt;&lt; p-&gt;weight &lt;&lt; \"-\" &lt;&lt; p-&gt;vertex; p = p-&gt;next; &#125; cout &lt;&lt; endl; &#125;&#125; BFSvoid wuGraph::bfs(int start) &#123; queue&lt;int&gt; q; visited[start] = true; q.push(start); while (!q.empty()) &#123; int index = q.front();//第一个元素 cout &lt;&lt; index &lt;&lt; \" \"; q.pop(); node* p = graph[index].first; while (p) &#123; if (!visited[p-&gt;vertex]) &#123; visited[p-&gt;vertex] = true;//设为访问过 q.push(p-&gt;vertex); &#125; p = p-&gt;next; &#125; &#125;&#125;void wuGraph::bfsTravel() &#123; for (int i = 1; i &lt;= vertex; i++) visited[i] = false; cout &lt;&lt; \"BFS：\" &lt;&lt; endl; for (int i = 1; i &lt;= vertex; i++) &#123; if (!visited[i]) bfs(i); &#125;&#125; DFSvoid wuGraph::dfs(int start) &#123; cout &lt;&lt; graph[start].data &lt;&lt; \" \"; visited[start] = true; node* p = graph[start].first; while (p) &#123; if (!visited[p-&gt;vertex]) dfs(p-&gt;vertex); p = p-&gt;next; &#125;&#125;void wuGraph::dfsTravel() &#123; cout &lt;&lt; \"DFS:\" &lt;&lt; endl; for (int i = 1; i &lt;= vertex; i++) visited[i] = false; for (int i = 1; i &lt;= vertex; i++) if (!visited[i]) dfs(i);&#125; 最小生成树//所有节点的父节点保存在parent数组中//与父节点的权值保存在vx[i].key中void wuGraph::minTree() &#123; int* parent = new int[vertex + 1];//每个节点的父节点 bool* pvisited = new bool[vertex + 1];//是否已经加入树中 pNode* vx = new pNode[vertex + 1];//保存每个节点与父节点连接边的权值 priority_queue&lt;pNode&gt; p; for (int i = 1; i &lt;= vertex; i++) &#123; vx[i].v = i; vx[i].key = INF;//权值为无穷大 parent[i] = -1; pvisited[i] = false;//树中无该元素 &#125; vx[1].key = 0;//作为父节点 p.push(vx[1]); while (!p.empty()) &#123; pNode n = p.top(); p.pop(); if (pvisited[n.v])//访问过 continue; pvisited[n.v] = true;//访问过该节点 node* current = graph[n.v].first; while (current) &#123; //树中无该元素 &amp;&amp; 求某个节点与其所有节点中权值最小的父节点 if (!pvisited[current-&gt;vertex] &amp;&amp; current-&gt;weight &lt; vx[current-&gt;vertex].key) &#123; parent[current-&gt;vertex] = n.v; vx[current-&gt;vertex].key = current-&gt;weight; vx[current-&gt;vertex].v = current-&gt;vertex; p.push(vx[current-&gt;vertex]);//按照权值来进行排序 &#125; current = current-&gt;next; &#125; &#125;&#125; 參考鏈接一參考鏈接二參考鏈接三 幾個不錯的Blog鏈接Blog鏈接一Blog鏈接二Blog鏈接三","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"Priority_queue","slug":"Priority-queue","date":"2017-12-26T13:53:51.000Z","updated":"2017-12-29T09:01:19.026Z","comments":true,"path":"2017/12/26/Priority-queue/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/26/Priority-queue/","excerpt":"Stl中優先隊列的使用","text":"Stl中優先隊列的使用一.題目鏈接使用優先隊列struct node &#123; int x, y; friend bool operator &lt;(node a, node b) &#123; if (a.y == b.y) return a.x &gt; b.x; else return a.y &lt; b.y; &#125; node(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; priority_queue&lt;node&gt; p; unordered_map&lt;int, int&gt; mp; int size = nums.size(); for (int i = 0; i &lt; size; i++) mp[nums[i]]++; auto iter = mp.begin(); int pos = mp.size() - k; while (iter != mp.end()) &#123; p.push(node(iter-&gt;first, iter-&gt;second)); if (p.size() &gt; pos) &#123; res.push_back(p.top().x); p.pop(); &#125; iter++; &#125; return res;&#125; 直接利用map,沒想到Runtime很快You are here! Your runtime beats 92.96 % of cpp submissions.二.題目鏈接仿照前面定義結構體nodestruct node &#123; string x; int y; friend bool operator &lt;(node a, node b) &#123; //y为数量 if (a.y == b.y)//数量相同 return a.x[0] &lt; b.x[0];//升序 else return a.y &lt; b.y; &#125; node(string x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) &#123; vector&lt;string&gt; res; priority_queue&lt;node&gt; p; unordered_map&lt;string, int&gt; mp; int size = words.size(); for (int i = 0; i &lt; size; i++) mp[words[i]]++; auto iter = mp.begin(); int pos = mp.size() - k; while (iter != mp.end()) &#123; p.push(node(iter-&gt;first, iter-&gt;second)); if (p.size() &gt; pos) &#123; res.push_back(p.top().x); p.pop(); &#125; iter++; &#125; return res;&#125; 自定義比較函數vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) &#123; unordered_map&lt;string, int&gt; freq; for (auto w : words) &#123; freq[w]++; &#125; auto comp = [&amp;](const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp; b) &#123; return a.second &gt; b.second || (a.second == b.second &amp;&amp; a.first &lt; b.first); &#125;; typedef priority_queue&lt; pair&lt;string, int&gt;, vector&lt;pair&lt;string, int&gt;&gt;, decltype(comp) &gt; my_priority_queue_t; my_priority_queue_t pq(comp); for (auto w : freq) &#123; pq.emplace(w.first, w.second); if (pq.size()&gt;k) pq.pop(); &#125; vector&lt;string&gt; output; while (!pq.empty()) &#123; output.insert(output.begin(), pq.top().first); pq.pop(); &#125; return output;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"Trie","slug":"Trie","date":"2017-12-24T07:12:34.000Z","updated":"2017-12-29T09:01:48.036Z","comments":true,"path":"2017/12/24/Trie/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Trie/","excerpt":"字典樹","text":"字典樹學習了一下字典樹的簡單實現方式Reference节点的定义#define Maxn 26struct trieNode &#123; int count;//以该节点为结尾的单词的个数 trieNode* next[Maxn]; trieNode(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;; 在字典中插入新的字符串void insert(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root;//根节点 //一个一个字符插入 for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a';//26个字母中的位置 if (p-&gt;next[index]==NULL) p-&gt;next[index] = new trieNode(0);//创建 p = p-&gt;next[index]; &#125; //以该字符为结尾的单词 p-&gt;count++;&#125; 刪除字典中的元素void del(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) return; p = p-&gt;next[index]; &#125; p-&gt;count--;&#125; 查找字典中是否存在某個字符串bool search(trieNode* root, string str) &#123; if (root == NULL) &#123; return false; &#125; int size = str.size(); trieNode *p = root; int index; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; // 无法转移到下一个字符 if (p-&gt;next[index] == NULL) &#123; return false; &#125;//if // 继续下一个字符 p = p-&gt;next[index]; &#125; return p-&gt;count &gt; 0;//是否有&#125; 遍曆輸出整個字典//利用递归程序查询整个字典void printDic(trieNode* root, vector&lt;vector&lt;char&gt;&gt; &amp;words, vector&lt;char&gt; &amp;word) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;count &gt; 0) &#123; words.push_back(word); &#125;//到了根且有值 for (int i = 0; i &lt; 26; ++i) &#123; if (root-&gt;next[i]) &#123;//26个循环 word.push_back('a' + i); printDic(root-&gt;next[i], words, word); word.pop_back();//回溯 &#125; &#125;&#125; LeetCode上的相關題目一.題目鏈接使用字典樹的解法#define Maxn 26struct node &#123; int count; int value; node* next[Maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;;class MapSum &#123;public: /** Initialize your data structure here. */ MapSum() &#123; root = new node(0); &#125; void insert(string key, int val) &#123; int size = key.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = key[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++; p-&gt;value = val; &#125; node* help(string prefix) &#123; int size = prefix.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = prefix[i] - 'a'; if (p-&gt;next[index] == NULL) return NULL; p = p-&gt;next[index]; &#125; return p;//有该前缀 &#125; void search(node* root,int&amp; res) &#123; if (root == NULL)//空 return; if (root-&gt;count &gt; 0) res += root-&gt;value; for (int i = 0; i &lt; Maxn; i++) if (root-&gt;next[i]) search(root-&gt;next[i], res); &#125; int sum(string prefix) &#123; int res = 0; node* current = help(prefix); search(current,res); return res; &#125;private: node* root;&#125;; 二.題目鏈接#define maxn 26struct node &#123; int count; node* next[maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; maxn; i++) next[i] = NULL; &#125;&#125;;void insert(node* root,string str)&#123; int size = str.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++;&#125;int search(node* &amp;root, char c) &#123; if (root == NULL) &#123; return -1; &#125; int index = c - 'a'; if (root-&gt;next[index] == NULL) return -1;//不存在 root = root-&gt;next[index]; if (root-&gt;count &gt; 0) return 1;//存在 return 0;//可能存在&#125;string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) &#123; int size = dict.size(); node* root = new node(0); string res = \"\"; for (int i = 0; i &lt; size; i++) insert(root, dict[i]); int keysize = sentence.size(); for (int j = 0; j &lt; keysize; ) &#123; node* p = root; string element = \"\"; bool tag = false; while (j &lt; keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; int com = search(p, sentence[j]); if (com==-1) &#123; j++; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; j++; &#125; res += element; res += \" \"; tag = true; break; &#125; if (com == 0) &#123; //do noing &#125; if (com == 1) &#123; res += element; res += \" \"; tag = true; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') j++; break; &#125; j++; &#125; if (!tag) &#123; res += element; res += \" \"; &#125; j++; &#125; res.pop_back(); return res;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"Heap","slug":"Heap","date":"2017-12-24T02:06:46.000Z","updated":"2017-12-29T09:00:39.268Z","comments":true,"path":"2017/12/24/Heap/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Heap/","excerpt":"考試過半，昨天去青島市區轉了一圈，走在五四廣場的海邊，聽聽海浪拍打的聲音，真是不錯呢。","text":"考試過半，昨天去青島市區轉了一圈，走在五四廣場的海邊，聽聽海浪拍打的聲音，真是不錯呢。給博客換了主題，很大衆也很雅致的主題。昨天下午四點多回來之後，去超市買了一些零食，慵懶地躺在床上，看了一部電影，叫做情聖，還是比較有意思的。晚上，寫了幾道Leetcode上的題目，補了一下數據結構實驗的作業。要求利用鏈表實現一個堆struct heapNode &#123; heapNode(const int&amp; theElement, heapNode* p) &#123; parent = p; element = theElement; left = right = NULL; &#125; int element; heapNode* parent; heapNode* left; heapNode* right;&#125;;class maxHeap &#123;public: int&amp; top() &#123; if (root) return root-&gt;element; &#125;//获取堆顶元素 void insert(const int&amp; theElement);//插入 int size() &#123; return heapSize; &#125; void pop();//删除 void initialize(vector&lt;int&gt;&amp; nums);//初始化一个大根堆private: heapNode* root; int heapSize; deque&lt;heapNode*&gt; pars;//储存节点 int childNumber;//孩子的数量&#125;; 插入void maxHeap::insert(const int&amp; theElement) &#123; if (heapSize == 0) &#123;//空堆 root = new heapNode(theElement, NULL); root-&gt;parent = root; heapSize++; pars.push_back(root); childNumber = 0; return; &#125; //插入新的元素 heapNode* p = pars.front(); heapNode* newNode = new heapNode(theElement, p); heapSize++; pars.push_back(newNode); if (childNumber == 0)//左节点 p-&gt;left = newNode; if (childNumber == 1)//右节点 p-&gt;right = newNode; childNumber++; if (childNumber == 2) &#123;//孩子节点满了 pars.pop_front(); childNumber = 0; &#125; heapNode* current = newNode; while (current-&gt;parent != current&amp;&amp;current-&gt;element &gt; current-&gt;parent-&gt;element) &#123; //交换孩子节点与父节点的元素 int tempt = current-&gt;element; current-&gt;element = current-&gt;parent-&gt;element; current-&gt;parent-&gt;element = tempt; current = current-&gt;parent; &#125; return;&#125; 删除void maxHeap::pop() &#123; if (!root)//空堆 return; heapNode* lastChild = pars.back(); root-&gt;element = lastChild-&gt;element;//替换 heapNode* p = lastChild-&gt;parent; if (p == root &amp;&amp; heapSize==1 ) &#123;//本身 root = NULL; heapSize--; childNumber = 0; pars.pop_back();//删除 return; &#125; if (childNumber == 0) &#123;//满了 p-&gt;right = NULL; pars.push_front(p);//添加节点 heapSize--; childNumber = 1; pars.pop_back();//删除 lastChild = pars.back(); &#125; else &#123; p-&gt;left = NULL; heapSize--; childNumber--; pars.pop_back(); lastChild = pars.back(); &#125; //自上而下地进行更新 heapNode* current = root; while (current-&gt;left&amp;&amp;current-&gt;right) &#123; heapNode* tempt = (current-&gt;left-&gt;element &gt; current-&gt;right-&gt;element) ? current-&gt;left : current-&gt;right;//数值较大者 if (current-&gt;element &gt; tempt-&gt;element) return; int value = tempt-&gt;element; tempt-&gt;element = current-&gt;element; current-&gt;element = value; current = tempt;//替换更新 &#125; //数值交换 if (current-&gt;left&amp;&amp;current-&gt;left-&gt;element &gt; current-&gt;element) &#123; int leftTempt = current-&gt;left-&gt;element; current-&gt;left-&gt;element = current-&gt;element; current-&gt;element = leftTempt; &#125;&#125; 初始化一个大根堆//建立一个大根堆//先建立一个用链表表示的堆，然后进行调整void maxHeap::initialize(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return; //建立一棵树 stack&lt;heapNode*&gt; pNodes;//用于保存所有的父节点 root = new heapNode(nums[0], NULL); root-&gt;parent = root; childNumber = 0; heapSize++; pars.push_back(root); for (int i = 1; i &lt; nums.size(); i++) &#123; heapNode* p = pars.front(); heapNode* newNode = new heapNode(nums[i], p); heapSize++; pars.push_back(newNode); if (childNumber == 0)//左节点 p-&gt;left = newNode; if (childNumber == 1)//右节点 p-&gt;right = newNode; childNumber++; if (childNumber == 2) &#123; pNodes.push(pars.front());//将满孩子的节点存进去 pars.pop_front(); childNumber = 0; &#125; &#125; //对树进行自上而下的调整 if (pars.front()-&gt;left) pNodes.push(pars.front()); while (!pNodes.empty()) &#123;//check 所有的父节点 heapNode* current = pNodes.top(); pNodes.pop(); while (current-&gt;left&amp;&amp;current-&gt;right) &#123; heapNode* tempt = (current-&gt;left-&gt;element &gt; current-&gt;right-&gt;element) ? current-&gt;left : current-&gt;right;//数值较大者 if (current-&gt;element &gt; tempt-&gt;element) break; int value = tempt-&gt;element; tempt-&gt;element = current-&gt;element; current-&gt;element = value; current = tempt;//替换更新 &#125; //数值交换 if (current-&gt;left&amp;&amp;current-&gt;left-&gt;element &gt; current-&gt;element) &#123; int leftTempt = current-&gt;left-&gt;element; current-&gt;left-&gt;element = current-&gt;element; current-&gt;element = leftTempt; &#125; &#125; return;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"杂感","slug":"杂感","date":"2017-12-11T12:35:03.000Z","updated":"2017-12-11T12:55:58.151Z","comments":true,"path":"2017/12/11/杂感/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/11/杂感/","excerpt":"2017/12/11","text":"2017/12/11现在是20:36；写一些很杂的东西吧，先是两道题目；1.Bing It On Solution#include&lt;map&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;map&lt;string, int&gt;mp;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string key; cin &gt;&gt; key; for (int i = 1; i &lt; key.size(); i++) &#123; mp[key.substr(0, i)]++; &#125; cout &lt;&lt; mp[key] &lt;&lt; endl; mp[key]++; &#125;&#125; map的使用#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; map&lt;int, int&gt; mp; mp[1];//输出 1 0 mp[1]++;//输出 1 1 auto it = mp.begin(); while (it != mp.end()) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl; it++; &#125;&#125; 2.Power String可用KMP算法解决，直接用暴力做了 Solution #include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main() &#123; string key; for (int i = 0; ; i++) &#123; bool tag = false;//找到了吗 if (key == \".\") break; vector&lt;int&gt; pos; cin &gt;&gt; key; for (int j = 1; j &lt; key.size(); j++) if (key[j] == key[0]) pos.push_back(j); if (pos.empty()) &#123; cout &lt;&lt; 1 &lt;&lt; endl;//空的 continue; &#125; for (int k = 0; k &lt; pos.size(); k++) &#123; bool flag = true; if (key.size() % pos[k] != 0) &#123;//确定整除 continue; &#125; //每一段的长度为pos[k] for (int i = pos[k]; i &lt; key.size();) &#123; if (key[i] != key[0]) &#123; flag = false; break; &#125; i += pos[k]; &#125; if (!flag) continue;//不匹配 string tempt = key.substr(0, pos[k]);//第一段字符 int l = pos[k]; bool judge = true; while (l != key.size()) &#123; if (tempt != key.substr(l, pos[k])) &#123; judge = false;//不匹配 break; &#125; l += pos[k]; &#125; if (judge) &#123;//找到 cout &lt;&lt; key.size() / pos[k] &lt;&lt; endl; tag = true;//找到 break; &#125; &#125; //没有找到 if (!tag) cout &lt;&lt; 1 &lt;&lt; endl; &#125;&#125; 马上考试了，电路也结课了，这样周六周日周一都没有课了。最近作息是10点起床，中午晚上一直在自习室呢。现在博客代码显示不好看，也不想重新换个主题了，有点太麻烦了。前端的知识也没有接触过，寒假学学js，弄弄页面吧。 没想到会有人浏览我这个博客，可能互联网太浩瀚了吧，总有人会在这片海洋相遇，感谢你们的到访！这个博客，主要也是放一些平时的作业之类的，水平太水了，也没什么高级的东西，也没有认真地写，只是放了一些代码； 感谢你们的来访！微博这个东西，可能也马上不用了吧。怎么说呢？ 2018、2019好运！","categories":[],"tags":[{"name":"杂感","slug":"杂感","permalink":"http://Persuingsdu.github.io/tags/杂感/"}]},{"title":"Something","slug":"Something","date":"2017-12-10T12:22:59.000Z","updated":"2017-12-10T12:41:52.155Z","comments":true,"path":"2017/12/10/Something/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/10/Something/","excerpt":"2017/12/10","text":"2017/12/10Hello,Homework!给出前序和中序遍历，构建一个二叉树. 代码BinaryTreeNode&lt;E&gt;* build(int ps,int pt,int is,int it,vector&lt;E&gt;&amp; preOrder,vector&lt;E&gt;&amp; inOrder)&#123; if (ps &gt;= pt) return NULL; BinaryTreeNode&lt;E&gt;* res = new BinaryTreeNode&lt;E&gt;(preOrder[ps]); int cnt = find(inOrder.begin(), inOrder.end(), preOrder[ps]) - inOrder.begin() - is; res-&gt;left = build(ps + 1, ps + 1 + cnt, is, is + cnt, preOrder, inOrder); res-&gt;right = build(ps + 1 + cnt, pt, is + cnt + 1, it, preOrder, inOrder); return res;&#125;void buildTree(vector&lt;E&gt;&amp; preorder, vector&lt;E&gt;&amp; inorder) &#123; int size = preorder.size(); root = build(0, size, 0, size, preorder, inorder);&#125; 读取txt类型的文件参考链接1参考链接2 代码void readTxt(string file) &#123; ifstream infile; infile.open(file.data());//将文件流对象与文件连接起来 assert(infile.is_open());//若失败，输出错误消息，并停止 string s; while (getline(infile, s)) &#123; //操作 &#125; infile.close();&#125;//逐个字符读入，忽略空格与回车void readSingle(string file) &#123; ifstream infile; infile.open(file.data());//将文件流对象与文件连接起来 assert(infile.is_open());//若失败，输出错误消息，并停止 char c; while (!infile.eof()) &#123; infile &gt;&gt; c; //操作 &#125; infile.close();&#125;//逐个字符读入，包括回车和空格void readSingleTxt(string file) &#123; ifstream infile; infile.open(file.data()); //将文件流对象与文件连接起来 assert(infile.is_open()); //若失败,则输出错误消息,并终止程序运行 char c; infile &gt;&gt; noskipws; while (!infile.eof()) &#123; infile &gt;&gt; c; //操作 &#125; infile.close();//关闭文件输入流 &#125;int main() &#123; readSingle(\"C:\\\\Users\\\\11692\\\\Desktop\\\\maze.txt\");//括号内string为文件的地址&#125; 实现的二叉树类，提供了基本的操作自己认真地实现了一下，初学了vs的调试方法；这里面主要学习的是函数指针的使用格式 ret_type(*var_name)(arg_list)可以通过两棵二叉树合并构造一个二叉树，也可以通过树的根节点构造一棵二叉树； 代码如下，省略了树节点的定义#pragma once#include\"BinaryTreeNode.h\"#include\"booster.h\"#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;template&lt;class E&gt;class linkedBinaryTree &#123;public: linkedBinaryTree() &#123; root = NULL; treeSize = 0; &#125; linkedBinaryTree(BinaryTreeNode&lt;E&gt;* theRoot) &#123; root = theRoot; treeSize = 0; &#125; ~linkedBinaryTree() &#123; destory();&#125; bool empty() const &#123; return treeSize == 0; &#125; int size() &#123; sizeTravel(root); return treeSize + 1; &#125; void makeTree(const E&amp; element, linkedBinaryTree&lt;E&gt;&amp;, linkedBinaryTree&lt;E&gt;&amp;); //前序遍历并且确定对节点进行的操作 void preOrder(void(*theVist)(BinaryTreeNode&lt;E&gt;*)) &#123; visit = theVist;//给访问函数赋值,确定访问函数 preOrder(root); &#125; void inOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*)) &#123; visit = theVisit; inOrder(root); &#125; void postOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*)) &#123; visit = theVisit; postOrder(root); &#125; void levelOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*));//BFS遍历 void preOrderOutput() &#123; preOrder(output); cout &lt;&lt; endl; &#125;//调用public的preOrder给visit赋值 void inOrderOutput() &#123; inOrder(output); cout &lt;&lt; endl; &#125; void postOrderOutput() &#123; postOrder(output); cout &lt;&lt; endl; &#125; void levelOrderOutput() &#123; levelOrder(output); cout &lt;&lt; endl; &#125; void destory() &#123; erase(root); root = NULL; &#125; void erase(BinaryTreeNode&lt;E&gt;* t) &#123; if (!t) return; if (t-&gt;left) erase(t-&gt;left); if (t-&gt;right) erase(t-&gt;right); delete t; &#125; int height() const &#123; return height(root); &#125; void sizeTravel(BinaryTreeNode&lt;E&gt;* t) &#123; if (!t) return; if (t-&gt;left) &#123; treeSize++; sizeTravel(t-&gt;left); &#125; if (t-&gt;right) &#123; treeSize++; sizeTravel(t-&gt;right); &#125; &#125; /* 1 / \\ 3 5 / 7 \\ 9 前序遍历： 1 3 7 9 5 中序遍历： 7 9 3 1 5 */ BinaryTreeNode&lt;E&gt;* build(int ps,int pt,int is,int it,vector&lt;E&gt;&amp; preOrder,vector&lt;E&gt;&amp; inOrder)&#123; if (ps &gt;= pt) return NULL; BinaryTreeNode&lt;E&gt;* res = new BinaryTreeNode&lt;E&gt;(preOrder[ps]); int cnt = find(inOrder.begin(), inOrder.end(), preOrder[ps]) - inOrder.begin() - is; res-&gt;left = build(ps + 1, ps + 1 + cnt, is, is + cnt, preOrder, inOrder); res-&gt;right = build(ps + 1 + cnt, pt, is + cnt + 1, it, preOrder, inOrder); return res; &#125; void buildTree(vector&lt;E&gt;&amp; preorder, vector&lt;E&gt;&amp; inorder) &#123; int size = preorder.size(); root = build(0, size, 0, size, preorder, inorder); &#125;private: BinaryTreeNode&lt;E&gt;* root; int treeSize; static int count;//子树节点的个数 //函数指针 //格式 ret_type(*var_name)(arg_list) static void (*visit)(BinaryTreeNode&lt;E&gt;*);//访问函数 指针指向函数 不是具体的函数相当于一个指针指向函数 static void preOrder(BinaryTreeNode&lt;E&gt;* t);//前 static void inOrder(BinaryTreeNode&lt;E&gt;* t);//中 static void postOrder(BinaryTreeNode&lt;E&gt;* t);//后 static void output(BinaryTreeNode&lt;E&gt;* t) &#123;//输出节点的值 cout &lt;&lt; t-&gt;element &lt;&lt; \" \"; &#125; static int height(BinaryTreeNode&lt;E&gt;* t);&#125;;void(*linkedBinaryTree&lt;int&gt;::visit)(BinaryTreeNode&lt;int&gt;*);void(*linkedBinaryTree&lt;booster&gt;::visit)(BinaryTreeNode&lt;booster&gt;*);void(*linkedBinaryTree&lt;pair&lt;int, int&gt;&gt;::visit)(BinaryTreeNode&lt;pair&lt;int, int&gt; &gt;*);void(*linkedBinaryTree&lt;pair&lt;const int, char&gt;&gt;::visit)(BinaryTreeNode&lt;pair&lt;const int, char&gt; &gt;*);void(*linkedBinaryTree&lt;pair&lt;const int, int&gt;&gt;::visit)(BinaryTreeNode&lt;pair&lt;const int, int&gt; &gt;*);template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::makeTree(const E&amp; element, linkedBinaryTree&lt;E&gt;&amp; leftTree, linkedBinaryTree&lt;E&gt;&amp; rightTree) &#123; root = new BinaryTreeNode&lt;E&gt;(element, leftTree.root, rightTree.root); //treeSize = leftTree.treeSize + rightTree.treeSize + 1; leftTree.root = rightTree.root = NULL; //leftTree.treeSize = rightTree.treeSize = 0;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::preOrder(BinaryTreeNode&lt;E&gt;* t)&#123;// Preorder traversal. if (t) &#123; linkedBinaryTree&lt;E&gt;::visit(t);//访问节点t,执行相应的操作 preOrder(t-&gt;left); preOrder(t-&gt;right); &#125;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::inOrder(BinaryTreeNode&lt;E&gt;* t)&#123;// Inorder traversal. if (t != NULL) &#123; inOrder(t-&gt;left); linkedBinaryTree&lt;E&gt;::visit(t);//访问 inOrder(t-&gt;right); &#125;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::postOrder(BinaryTreeNode&lt;E&gt;* t)&#123;// Postorder traversal. if (t != NULL) &#123; postOrder(t-&gt;left); postOrder(t-&gt;right); linkedBinaryTree&lt;E&gt;::visit(t);//访问 &#125;&#125;template&lt;class E&gt;void linkedBinaryTree&lt;E&gt;::levelOrder(void(*theVisit)(BinaryTreeNode&lt;E&gt;*)) &#123; queue&lt;BinaryTreeNode&lt;E&gt;*&gt; p; BinaryTreeNode&lt;E&gt;* t; if (root != NULL) p.push(root); while (!p.empty()) &#123; t = p.front(); theVisit(t);//访问该节点 if (t-&gt;left) p.push(t-&gt;left); if (t-&gt;right) p.push(t-&gt;right); p.pop();//删除 &#125;&#125;template &lt;class E&gt;int linkedBinaryTree&lt;E&gt;::height(BinaryTreeNode&lt;E&gt;* t)&#123;// Return height of tree rooted at *t. if (t == NULL) return 0; // empty tree int hl = height(t-&gt;left); // height of left int hr = height(t-&gt;right); // height of right if (hl &gt; hr) return ++hl; else return ++hr;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"计算表达式的数值","slug":"计算表达式的数值","date":"2017-12-08T12:02:23.000Z","updated":"2017-12-08T12:34:00.722Z","comments":true,"path":"2017/12/08/计算表达式的数值/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/08/计算表达式的数值/","excerpt":"2017/12/8","text":"2017/12/8 计算表达式的数值这个方法计算不含有括号的数值，也是核心的内容。首先处理掉乘号与除号,然后计算数值;用一个队列来储存加号与减号;用一个双向队列来存放数值，思想是遇到乘法或者除法,先取出两个数，然后计算出结果，然后再存入队列；处理完表达式中的乘法和除法之后，然后再计算数值； 代码double cal(int l, int r, string s) &#123; queue&lt;char&gt; f; deque&lt;double&gt; value; if (s.size() == 0) return 0; for (int i = l; i &lt; r; ) &#123; if (isdigit(s[i]) || s[i] == '.') &#123; string ss = \"\"; while ((isdigit(s[i]) || s[i] == '.') &amp;&amp; i&lt;r) &#123; ss += s[i]; i++; &#125; value.push_back(atof(ss.c_str())); &#125; if (s[i] == '+' || s[i] == '-') &#123; f.push(s[i]); i++; &#125; if (s[i] == '*') &#123; double x1 = value.back(); value.pop_back(); string p = \"\"; while ((isdigit(s[i + 1]) || s[i + 1] == '.') &amp;&amp; i + 1 &lt; r) &#123; p += s[i + 1]; i++; &#125; double x2 = atof(p.c_str()); double multi = x1*x2; value.push_back(multi); i++; &#125; if (s[i] == '/') &#123; double y1 = value.back(); value.pop_back(); string p = \"\"; while ((isdigit(s[i + 1]) || s[i + 1] == '.') &amp;&amp; i + 1&lt;r) &#123; p += s[i + 1]; i++; &#125; double y2 = atof(p.c_str()); double divi = y1 / y2; value.push_back(divi); i++; &#125; &#125; while (!f.empty()) &#123; if (f.front() == '-') &#123; double s1 = value.front(); value.pop_front(); double s2 = value.front(); value.pop_front(); value.push_front(s1 - s2); &#125; if (f.front() == '+') &#123; double s1 = value.front(); value.pop_front(); double s2 = value.front(); value.pop_front(); value.push_front(s1 + s2); &#125; f.pop(); &#125; return value.front();&#125; 计算含有括号遇到不是 ) 就存进栈中，遇到 ) ,就计算出最近的左括号和这个右括号中的表达式的值，存进栈中。 代码double calculate(string s) &#123; stack&lt;char&gt; a; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] != ')') a.push(s[i]); if (s[i] == ')') &#123; string ss = \"\"; while (!a.empty() &amp;&amp; a.top() != '(') &#123; ss += a.top(); a.pop(); &#125; a.pop(); reverse(ss.begin(), ss.end()); double p = cal(0, ss.size(), ss); string r = to_string(p); for (int i = 0; i &lt; r.size(); i++) a.push(r[i]); &#125; &#125; string res = \"\"; while (!a.empty()) &#123; res += a.top(); a.pop(); &#125; reverse(res.begin(), res.end()); return cal(0, res.size(), res);&#125; 注意 STL中stack、queue、deque的使用; 使用atof、stringstream将字符串转化为数字时，注意精度的丢失; 想要保留精度，可以不用转成数字，直接利用string，利用高精度计算出表达式的值;","categories":[],"tags":[{"name":"数据结构作业","slug":"数据结构作业","permalink":"http://Persuingsdu.github.io/tags/数据结构作业/"}]},{"title":"动态内存与智能指针","slug":"动态内存与智能指针","date":"2017-11-23T06:51:53.000Z","updated":"2017-11-23T08:53:49.194Z","comments":true,"path":"2017/11/23/动态内存与智能指针/","link":"","permalink":"http://Persuingsdu.github.io/2017/11/23/动态内存与智能指针/","excerpt":"2017//11/23","text":"2017//11/23程序用堆来储存动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。动态内存与智能指针动态内存的管理通过一对操作运算符来完成。new，在动态内存中为对象分配空间，并返回一个指向该对象的指针；delete，接受一个动态对象的指针，销毁该对象，并释放与之相关的内存。1.忘记释放内存，产生内存泄露；2.尚有指针引用内存的情况下释放了它，产生引用非法内存的指针。 两种智能指针，负责自动释放所指向的对象,定义在memory头文件中。shared_ptr 允许多个指针指向同一个对象；unique_ptr 独占指向的对象； 创建智能指针shared_ptr&lt;string&gt; p1;//shared_ptr，可以指向stringshared_ptr&lt;list&lt;int&gt;&gt; p2;//使用大致与普通指针类似if(p1 &amp;&amp; p1-&gt;empty()) *p1=\"hi\"; make_shared函数最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数，定义在memory头文件中。shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10,'9');shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;();//指向一个值初始化的int,值为0 程序使用动态内存出于以下的三个原因之一：1.程序不知道自己需要使用多少个对象，例如容器类；2.程序不知道对象的准确类型；3.程序需要在多个对象之间共享数据，以下的例子用来说明改原因；#include&lt;memory&gt;#include&lt;initializer_list&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;class StrBlob &#123;public: typedef vector&lt;string&gt;::size_type size_type; StrBlob(); StrBlob(initializer_list&lt;string&gt; il); size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; //添加和删除元素 void push_back(string&amp; t) &#123; data-&gt;push_back(t); &#125; void pop_back(); //元素访问 string&amp; front(); string&amp; back();private: shared_ptr&lt;vector&lt;string&gt;&gt; data; void check(size_type i, const string&amp; msg) const;&#125;;//构造函数StrBlob::StrBlob():data(make_shared&lt;vector&lt;string&gt;&gt;())&#123;&#125;StrBlob::StrBlob(initializer_list&lt;string&gt; il): data(make_shared&lt;vector&lt;string&gt;&gt;(il))&#123;&#125;//检查给定的索引是否在合法的范围内void StrBlob::check(size_type i, const string&amp; msg) const &#123; if (i &gt;= data-&gt;size()) throw out_of_range(msg);&#125;string&amp; StrBlob::front() &#123; check(0, \"Front on empty StrBlob\"); return data-&gt;front();&#125;string&amp; StrBlob::back() &#123; check(0, \"Back on empty StrBlob\"); return data-&gt;back();&#125;void StrBlob::pop_back() &#123; check(0, \"pop_back on empty StrBlob\"); data-&gt;pop_back();&#125; 直接管理内存使用new动态分配和初始化对象int *p1 = new int;//p指向一个动态分配的、未初始化的无名对象string *ps = new string;//初始化为空的stringint *pi = new int(1024);string *ps = new string(10,'9');vector&lt;int&gt; *pv = new vector&lt;int&gt;&#123;0,1,2,3&#125;; 释放动态内存delete p//p必须指向一个动态分配的对象或者是一个空指针1.销毁给定的指针指向的对象；2.释放对应的内存； int i,*pil=&amp;i,*pi2=nullptr;double *pd = new double(33),*pd2=pd;delete i;//错误，i不是一个指针delete pil//未定义,pil指向一个局部变量,释放一个并非new分配的内存的行为是未定义的delete pd;//正确delete pd2;//未定义，pd2指向的内存已经被释放掉了delete pi2;//正确，释放一个空指针总是没有错误的 对于一个由内置指针管理的动态对象，直到被显示释放之前它都是一直存在的。//factory 返回一个指针，指向一个动态分配的对象Foo* factory(T arg)&#123; //处理arg return new Foo(arg);//调用者负责释放此内存&#125;void use_factory(T arg)&#123; Foo* p = factory(arg); //使用p但是不delete它&#125;//p离开了作用域，但它所指向的内存没有被释放掉//修正的方法void use_factory(arg)&#123; Foo *p = factory(arg); //使用p delete p;//记得释放内存&#125;Foo* use_factory(arg)&#123; Foo *p =fatcory(arg); //使用p return p;//调用者负责释放内存&#125;","categories":[],"tags":[{"name":"c++primer","slug":"c-primer","permalink":"http://Persuingsdu.github.io/tags/c-primer/"}]},{"title":"双向链表","slug":"双向链表","date":"2017-11-19T11:45:58.000Z","updated":"2017-11-22T14:40:32.510Z","comments":true,"path":"2017/11/19/双向链表/","link":"","permalink":"http://Persuingsdu.github.io/2017/11/19/双向链表/","excerpt":"学习了一下双向链表的实现。","text":"学习了一下双向链表的实现。Refernce数据结构的实验要求掌握链表遍历器的使用，由于书上的链表是单向链表，则迭代器也只能是向前的迭代器。为了实现双向迭代器，采用了双向链表这一数据结构。2017/11/22更新int main() &#123; vector&lt;doubleLink&lt;int&gt;*&gt; v;//存放指针 doubleLink&lt;int&gt; a; a.insert_first(3); a.output(cout); v.push_back(&amp;a); v[0]-&gt;output(cout);&#125; 结构体的定义Data部分以及向前和向后的指针template&lt;class T&gt;struct chainode &#123; T element; chainode&lt;T&gt;* pre; chainode&lt;T&gt;* next; chainode() &#123;&#125; chainode(T&amp; element) &#123; this-&gt;element = element; &#125; chainode(T&amp; element, chainode&lt;T&gt;* pre, chainode&lt;T&gt;* next) &#123; this-&gt;element = element; this-&gt;pre = pre; this-&gt;next = next; &#125;&#125;; 双向链表类的实现重点是内部类迭代器类的实现。//所有位置的下标是以 0 计数template&lt;class T&gt;class doubleLink &#123;public: doubleLink(); ~doubleLink(); int size() &#123; return listSize; &#125; bool empty() &#123; return listSize == 0; &#125; chainode&lt;T&gt;* get_node(int index);//获得index位置上的节点 T get(int index);//获得指定位置上的元素 void insert_first(T element);//将元素插入到第一个位置 void append_last(T element); void insert(int index, T elemet);//将元素插入到特定的位置 void erase(int index);//删除指定位置上的元素 void erase_e(T key);//删除指定的元素,如果该元素不存在,则什么也不操作,输出提示语句,返回 int indexOf(T value);//获取元素的位置,如果不存在就返回 0 void output(ostream&amp; out) const;//输出链表的元素 void rcout(doubleLink&lt;T&gt;&amp; theChain); void merge(doubleLink&lt;T&gt;&amp; a, doubleLink&lt;T&gt;&amp; b);//将a,b进行合并 class iterator; iterator begin() &#123; return iterator(firstNode-&gt;next); &#125;//第一个元素 iterator end() &#123; return iterator(firstNode); &#125;//空的头结点 //双向链表的迭代器 class iterator &#123; public: // typedefs required by C++ for a forward iterator typedef forward_iterator_tag iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; //构造函数 iterator(chainode&lt;T&gt;* theNode = NULL) &#123; node = theNode; &#125; // 解引用 T&amp; operator*() const &#123; return node-&gt;element; &#125; T* operator-&gt;() const &#123; return &amp;node-&gt;element; &#125; // 增加 iterator&amp; operator++() &#123; //前加 node = node-&gt;next; return *this; &#125; iterator operator++(int) &#123;//后加 iterator old = *this; node = node-&gt;next; return old; &#125; //递减 iterator&amp; operator--() &#123;//前减 node = node-&gt;pre; return *this; &#125; iterator operator--(int) &#123;//后减 iterator old = *this; node = node-&gt;pre; return old; &#125; //判断 bool operator!=(const iterator right) const&#123; return node != right.node; &#125; bool operator==(const iterator right) const&#123; return node == right.node; &#125;protected: chainode&lt;T&gt;* node;&#125;; private: int listSize; chainode&lt;T&gt;* firstNode;&#125;; 具体的方法实现 构造函数在这里初始化一个空的表头，在链表中头结点Data部分为空，初始化pre与next均为自身。 //表头不存储任何元素template&lt;class T&gt;doubleLink&lt;T&gt;::doubleLink() &#123; listSize = 0; firstNode = new chainode&lt;T&gt;();//空表头 firstNode-&gt;pre = firstNode-&gt;next = firstNode;&#125; 析构函数这里的删除每个节点与单向链表类似，注意遍历的方式，由于我们增加了一个空的表头，因此遍历的方式同循环链表最后，要删除空的表头。 //析构函数template&lt;class T&gt;doubleLink&lt;T&gt;::~doubleLink() &#123; chainode&lt;T&gt;* p; chainode&lt;T&gt;* q = firstNode-&gt;next; while (q != firstNode) &#123; p = q; q = q-&gt;next; delete p; &#125; //删除表头 delete firstNode;//存在的对象 firstNode = NULL;//节点指向的对象重置为NULL listSize = 0;&#125; 获取指定位置上的节点对于单向链表，只能从头遍历，但是由于双向链表能找到其前驱，于是有两种方式，从头开始找或者从尾节点开始找，根据index来确定采取何种方式，从而更快。 //获得位置为index的节点template&lt;class T&gt;chainode&lt;T&gt;* doubleLink&lt;T&gt;::get_node(int index) &#123; if (index&lt;0 || index&gt;=listSize) &#123; throw invalid_argument(\"invalid_argument\"); &#125; //正向查找 if (index &lt;= listSize / 2) &#123; chainode&lt;T&gt;* pos = firstNode-&gt;next; for (int i = 0; i &lt; index; i++) pos = pos-&gt;next; return pos; &#125; else &#123; int reverIndex = listSize - index - 1; chainode&lt;T&gt;* rpos = firstNode-&gt;pre;//尾节点 for (int j = 0; j &lt; reverIndex; j++) rpos = rpos-&gt;pre; return rpos; &#125;&#125; 插入元素与删除元素这也是与单向链表的显著不同的地方。 插入元素 //在指定位置上插入元素template&lt;class T&gt;void doubleLink&lt;T&gt;::insert(int index, T element) &#123; if (index == 0) &#123; insert_first(element); return; &#125; chainode&lt;T&gt;* pos = get_node(index); chainode&lt;T&gt;* newNode = new chainode&lt;T&gt;(element, pos-&gt;pre, pos); pos-&gt;pre-&gt;next = newNode; pos-&gt;pre = newNode; listSize++; return;&#125; 删除元素 //删除指定位置上的元素template&lt;class T&gt;void doubleLink&lt;T&gt;::erase(int index) &#123; chainode&lt;T&gt;* pos = get_node(index); pos-&gt;next-&gt;pre = pos-&gt;pre; pos-&gt;pre-&gt;next = pos-&gt;next; delete pos; listSize--; return;&#125; 链表的反向遍历 //反向输出链表的元素template&lt;class T&gt;void doubleLink&lt;T&gt;::rcout(doubleLink&lt;T&gt;&amp; theChain) &#123; auto iter = --theChain.end(); while (iter != --theChain.begin()) &#123; cout &lt;&lt; *iter &lt;&lt; \" \"; iter--; &#125;&#125; 两个有序链表合并 //merge将a,b进行合并,合并的方式为b的元素加到a的前面template&lt;class T&gt;//递增的两个链表进行合并void doubleLink&lt;T&gt;::merge(doubleLink&lt;T&gt;&amp;a, doubleLink&lt;T&gt;&amp; b) &#123; auto ib = b.begin(); chainode&lt;T&gt;* pos = a.firstNode-&gt;next; int i = 0; while (pos != firstNode&amp;&amp;ib != b.end()) &#123; if (*ib &lt; pos-&gt;element) &#123; a.insert(i, *ib); ib++; &#125; else &#123; pos = pos-&gt;next; &#125; i++; &#125; while (ib != b.end()) &#123; a.append_last(*ib); ib++; &#125; b.~doubleLink();//析构b&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"Leetcode Backtracking","slug":"Leetcode-Backtracking","date":"2017-10-29T03:09:33.000Z","updated":"2017-10-29T08:45:42.499Z","comments":true,"path":"2017/10/29/Leetcode-Backtracking/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/29/Leetcode-Backtracking/","excerpt":"用来总结leetcode上的一类问题","text":"用来总结leetcode上的一类问题 Combinations Combination Sum Combinations求幂集问题演化版My solution: int s = 0;void dfs(vector&lt;int&gt;&amp; ele, int n, int k, int i,vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; flag) &#123; if (s == k) &#123; int c = 0; for (int i = 1; i &lt;= n; i++) &#123; if (flag[i] == 1) &#123; ele.push_back(i); c++; &#125; if (c == k) break; &#125; res.push_back(ele); ele.clear(); return; &#125; if (i &gt; n) return; flag[i] = 1; s++; dfs(ele, n, k, i + 1,res,flag); flag[i] = 0; s--; dfs(ele, n, k, i + 1,res,flag);&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;int&gt; flag(n + 1, 0); vector&lt;int&gt; ele; vector&lt;vector&lt;int&gt;&gt; res; dfs(ele, n, k, 1, res, flag ); return res;&#125; Combination SumDiscuss","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://Persuingsdu.github.io/tags/Leetcode/"}]},{"title":"BST","slug":"BFS","date":"2017-10-22T07:23:38.000Z","updated":"2017-10-28T11:50:56.944Z","comments":true,"path":"2017/10/22/BFS/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/22/BFS/","excerpt":"2017/10/28更新","text":"2017/10/28更新 Kth Largest Element in an ArraySubsets Kth Largest Element in an Arrayquick sort int ans;void quick_sort(vector&lt;int&gt;&amp; s, int l, int r,int k)&#123; if (l &lt; r) &#123; //Swap(s[l], s[(l + r) / 2]); int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; s[j] &lt;= x) j--; if (i &lt; j) s[i++] = s[j]; while (i &lt; j &amp;&amp; s[i] &gt; x) i++; if (i &lt; j) s[j--] = s[i]; &#125; s[i] = x; if (i &gt; k-1 ) quick_sort(s, l, i - 1, k ); if (i &lt; k-1 ) // 2,3 3 quick_sort(s, i + 1, r, k); if (i == k-1 ) ans = s[i]; return; &#125; ans = s[l];&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; quick_sort(nums, 0, nums.size() - 1, k); return ans;&#125; SubsetsBacktarckingbacktracking &amp; bit manipulation &amp; iterativeDiscuss 2017/10/26更新Two Sum IV - Input is a BST Most Frequent Subtree Sum Two Sum IV - Input is a BST水题，树的中序遍历 &amp; two pointervoid travel(TreeNode* root,vector&lt;int&gt;&amp; nums) &#123; if (!root) return; if (root-&gt;left) travel(root-&gt;left,nums); nums.push_back(root-&gt;val); if (root-&gt;right) travel(root-&gt;right,nums);&#125;bool findTarget(TreeNode* root, int k) &#123; vector&lt;int&gt; nums; travel(root,nums); if (nums[0]+nums[1] &gt; k) return false; int i = 0, j = nums.size() - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &gt; k) j--; else &#123; if (nums[i] + nums[j] &lt; k) i++; else return true; &#125; &#125; return false;&#125; 2017/10/25更新又写了一些很烂的代码，好心焦…两道题的runtime均排在50%左右…效率不高，第一遍刷，先能过，之后尝试更快的方法。Convert BST to Greater Tree Validate Binary Search Tree Convert BST to Greater Tree void add(TreeNode* root,int value) &#123; if (!root) return; root-&gt;val += value; if (root-&gt;left) add(root-&gt;left,value); if (root-&gt;right) add(root-&gt;right, value);&#125;void dfs(TreeNode* root) &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right) return; if (root-&gt;right) &#123; dfs(root-&gt;right); TreeNode* p = root-&gt;right; while (p-&gt;left) p = p-&gt;left; root-&gt;val += p-&gt;val; &#125; if (root-&gt;left) &#123; dfs(root-&gt;left); add(root-&gt;left, root-&gt;val); &#125;&#125;TreeNode* convertBST(TreeNode* root) &#123; if(!root) return root; dfs(root); return root;&#125; Validate Binary Search Tree这道题的思想就是先对局部判断左右子节点和父节点的关系，然后判断父节点是否大于左子树的所有节点以及父节点是否小于右子树的所有节点。用了递归，但是必须递归完所有的情况，无法做到及时终止，有时间，再进行优化。 int ans = true;bool isValidBST(TreeNode* root) &#123; if (!root) return ans; if (root-&gt;left) &#123; if (root-&gt;left-&gt;val &gt;= root-&gt;val) ans= false; isValidBST(root-&gt;left); if (root-&gt;left-&gt;right) &#123; TreeNode* p = root-&gt;left-&gt;right; while (p) &#123; if (p-&gt;val &gt;= root-&gt;val) &#123; ans = false; &#125; p = p-&gt;right; &#125; &#125; &#125; if (root-&gt;right) &#123; if (root-&gt;right-&gt;val &lt;= root-&gt;val) ans= false; isValidBST(root-&gt;right); if (root-&gt;right-&gt;left) &#123; TreeNode* p = root-&gt;right-&gt;left; while (p) &#123; if (p-&gt;val &lt;= root-&gt;val) ans = false; p = p-&gt;left; &#125; &#125; &#125; return ans;&#125; c++实现BST #pragma once#include&lt;iostream&gt;#include&lt;utility&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;struct TreeNode &#123; int value; TreeNode* left; TreeNode* right; TreeNode() &#123; value = 0; left = right = NULL; &#125; TreeNode(int val) &#123; value = val; left = right = NULL; &#125;&#125;;class bst &#123;public: bst() &#123;&#125;; bst(int val); void insert(const int&amp; val); void erase(const int&amp; val); int size() const &#123; return capacity; &#125; bool empty()&#123; return capacity == 0; &#125; void bfs();private: int capacity; TreeNode* root;&#125;;bst::bst(int val) &#123; root = new TreeNode(val); capacity = 1;&#125;void bst::bfs() &#123; if (capacity == 0) return; queue&lt;TreeNode*&gt; unvisted; unvisted.push(root); while (!unvisted.empty()) &#123; TreeNode* current = unvisted.front(); unvisted.pop(); if (current-&gt;left) unvisted.push(current-&gt;left); if (current-&gt;right) unvisted.push(current-&gt;right); cout &lt;&lt; current-&gt;value &lt;&lt; \" \"; &#125;&#125;void bst::insert(const int&amp; val) &#123; if (capacity == 0) root = new TreeNode(val); else &#123; TreeNode* newNode = new TreeNode(val); TreeNode* current = root; while (current) &#123; if (val &lt;= current-&gt;value) &#123; if (!current-&gt;left) &#123; current-&gt;left = newNode; break; &#125; else current = current-&gt;left; &#125; else &#123; if (!current-&gt;right) &#123; current-&gt;right = newNode; break; &#125; else current = current-&gt;right; &#125; &#125; &#125; capacity++;&#125;void bst::erase(const int&amp; val) &#123; TreeNode* current = root; TreeNode* target = root; int pos; while (current) &#123; if (val &lt;= current-&gt;value) &#123; if (current-&gt;left) if (val == current-&gt;left-&gt;value) &#123; target = current-&gt;left;//left=0; pos = 0; break; &#125; else current = current-&gt;left; else return; &#125; else &#123; if (current-&gt;right) if (val == current-&gt;right-&gt;value) &#123; target = current-&gt;right; pos = 1;//right=1; break; &#125; else current = current-&gt;right; else return; &#125; //cout &lt;&lt; current-&gt;value &lt;&lt; endl; &#125; //target 为要删除的目标 //current 为它的父节点 if (!target-&gt;left) &#123; if (!target-&gt;right) &#123; if (pos) current-&gt;right = NULL; else current-&gt;left = NULL; capacity--; return; &#125; else &#123; TreeNode* rmin = target-&gt;right;//rch min element TreeNode* pmin = target; while (rmin-&gt;left) &#123; pmin = rmin; rmin = rmin-&gt;left; &#125; pmin-&gt;left = NULL; if (rmin != target-&gt;right) rmin-&gt;right = target-&gt;right; if (pos) current-&gt;right = rmin; else current-&gt;left = rmin; capacity--; return; &#125; &#125; //target有左子树 else &#123; //找到左子树的max TreeNode* lmax = target-&gt;left;//rch min element TreeNode* pmax = target-&gt;left; while (lmax-&gt;right) &#123; pmax = lmax; lmax = lmax-&gt;right; &#125; //存在右子树 pmax-&gt;right = NULL; if (lmax != target-&gt;left) lmax-&gt;left = target-&gt;left; if(target-&gt;right) lmax-&gt;right = target-&gt;right; if (pos) current-&gt;right = lmax; else current-&gt;left = lmax; capacity--; return; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"},{"name":"bst","slug":"bst","permalink":"http://Persuingsdu.github.io/tags/bst/"}]},{"title":"Leetcode","slug":"DFS","date":"2017-10-15T15:58:22.000Z","updated":"2017-10-25T15:24:00.488Z","comments":true,"path":"2017/10/15/DFS/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/15/DFS/","excerpt":"2017/10/21更新于图书馆","text":"2017/10/21更新于图书馆 Maximum Binary Tree 递归建树Populating Next Right Pointers in Each Node II bfsMaximum Depth of Binary Tree dfsBinary Tree Right Side View dfs / bfs 2017/10/20更新于图书馆Leetcode上关于树的递归程序大致可以编写为:void dfs(TreeNode* root)&#123; ... if(root-&gt;left)&#123; ... dfs(root-&gt;left); ... &#125; if(root-&gt;right)&#123; ... dfs(root-&gt;right); ... &#125; ...&#125; 大致结构如上，然后选择较小的数据，跟着程序走一遍，修正条件，即可。这样的做法可以解决大多数的关于树的dfs问题，关键是找寻更优解。 下面是关于树的bfs与dfs dfs 输出每条路径如下面的题目所述，不再赘述。 bfs 分行输出每行row中所有节点的值代码如下vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; queue&lt;TreeNode*&gt; unvisted; if (root == NULL) return ans; int count = 1; int child = 0; unvisted.push(root); while (!unvisted.empty()) &#123; vector&lt;int&gt; element; while (count--) &#123; TreeNode* current = unvisted.front(); unvisted.pop(); element.push_back(current-&gt;val); if (current-&gt;left) &#123; unvisted.push(current-&gt;left); child++; &#125; if (current-&gt;right) &#123; unvisted.push(current-&gt;right); child++; &#125; &#125; ans.push_back(element); count = child; child = 0; &#125; return ans;&#125; 在做一个题目时发现理解错了题目，于是弄出了一道新题目原题经过几次Wrong Answer之后，发现理解错了题意…于是意外地产生了一道新题：输出存在左叶子节点的深度最深处的一层最左边的左叶子节点的值(有点绕….)代码如下：注意每次递归调用结束后，回溯更新int depth = 0;int times = 1;int leftmost;int findBottomLeftValue(TreeNode* root) &#123; if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; if (times &gt; depth) leftmost = root-&gt;left-&gt;val; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; times--; return leftmost; &#125; if (root-&gt;left) &#123; times++; findBottomLeftValue(root-&gt;left); &#125; if (root-&gt;right) &#123; times++; findBottomLeftValue(root-&gt;right); &#125; times--; return leftmost;&#125; ————原文如下————这篇文章用来总结Leetcode上与dfs相关的题目，方法不是最佳，以后更新。与树相关的struct结构，如下定义struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; Path Sumlinkbool ans;bool hasPathSum(TreeNode* root, int sum) &#123; if (root == NULL) return false; if (root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) &#123; if (sum==root-&gt;val) return true; else return false; &#125; if (root-&gt;left != NULL) ans = hasPathSum(root-&gt;left, sum - root-&gt;val); if(ans==true) return ans; if (root-&gt;right != NULL) ans = hasPathSum(root-&gt;right, sum - root-&gt;val); return ans;&#125; Binary Tree Pathslink去掉了多余内容，只保留主要代码string ans = \"\";vector&lt;string&gt; s;//前提0-9void help(TreeNode* root) &#123; ans += root-&gt;val + '0'; if (root-&gt;left == NULL&amp;&amp;root-&gt;right == NULL) &#123; s.push_back(ans); ans.erase(ans.end() - 1); return; &#125; if (root-&gt;left != NULL) help(root-&gt;left); if (root-&gt;right != NULL) help(root-&gt;right); ans.erase(ans.end() - 1);//回溯&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]},{"title":"并查集","slug":"并查集","date":"2017-10-06T11:41:10.000Z","updated":"2017-10-06T12:29:26.316Z","comments":true,"path":"2017/10/06/并查集/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/06/并查集/","excerpt":"","text":"并查集路径压缩：每次查找时，令查找路径上的每个节点都直接指向根节点合并函数的性能改进：利用重量规则或者高度规则，具体代码见文章 带权并查集 定义两个数组fa和rank，fa用来判断集合关系，rank用来描述其与根节点的关系。因为关系满足传递性，所以可以推导出给出条件下的当前关系，再判断与之前已有关系是否矛盾。 例题：1.食物链2.Find them,Catch them","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://Persuingsdu.github.io/tags/并查集/"}]},{"title":"线段树基本操作(一)","slug":"线段树基本操作-一","date":"2017-10-05T14:44:10.000Z","updated":"2017-10-31T12:06:02.288Z","comments":true,"path":"2017/10/05/线段树基本操作-一/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/05/线段树基本操作-一/","excerpt":"国庆作业的需要，今晚学习了一下线段树的基本操作——建树,区间查询,单点更新后续学习区间更新及更多的知识,此处只放代码。主要参考此文章 数据结构——线段树","text":"国庆作业的需要，今晚学习了一下线段树的基本操作——建树,区间查询,单点更新后续学习区间更新及更多的知识,此处只放代码。主要参考此文章 数据结构——线段树 1.建树首先写一个函数,该函数用来更新父节点,指明父节点与左子树与右子树的关系void pushup(int i) { segTree[i] = max(segTree[2 i],segTree[2 i + 1]);}这里面的关系是可以自定义,可以进行求和,求最小值等等操作,这里选择了最大值作为示例//利用递归建树void build(int i, int l, int r) { if (l == r) segTree[i] = value[l]; else { //递归构造左右子树 build(2 i, l, (l + r) / 2); build(2 i + 1, (l + r) / 2 + 1, r); pushup(i);//回溯更新父节点 }} 2.区间查询i代表查询的结点,(b,e)代表该结点的范围,(l,r)代表查询结点的范围注意该函数的return值要与pushup更新父节点的目的匹配,此处就是返回该区间的最大值int query(int i, int b, int e, int l, int r) { int p1, p2; if (l &gt; e||r &lt; b) return INT_MIN; //无交集 if (b &gt;= l&amp;&amp;e &lt;= r) return segTree[i]; //需要查询的区间大于i存储的区间 p1 = query(2 i, b, (b + e) / 2, l, r); p2 = query(2 i + 1, (b + e) / 2 + 1, e, l, r); return max(p1, p2);} 3.单节点更新i代表结点,(b,e)代表该节点的范围,p代表我们要更新的结点位置,v代表要递增的数值void update_single(int i, int b, int e, int p, int v) { if (b == e) { segTree[i] += v; return; } int m = (b + e) / 2; if (p &lt;= m) update_single(2 i, b, m, p, v); else update_single(2 i + 1, m + 1, e, p, v); pushup(i);//回溯更新}特别注意,在实际用中,空间要开4*N 调试代码const int maxn = 256;int segTree[4 maxn + 10];int value[maxn];int main() { //开的空间为4N value[0] = 1; value[1] = 2; value[2] = 2; value[3] = 4; value[4] = 9; value[5] = 3; build(1, 0, 5); for (int i = 1; i &lt;= 20; i++) cout &lt;&lt; “seg “ &lt;&lt; i &lt;&lt; “=” &lt;&lt; segTree[i] &lt;&lt; endl; //我们定义pushup得到的最终结果便是segTree[1] update_single(1, 0, 5, 3, 8); query(1, 0, 5, 2, 4);} 2017/10/9 于图书馆更新例题 Potted Flowerconst int maxn = 100010;struct node { int sum, maxNow, minNow; int lmax, lmin; int rmax, rmin; int left, right;} T[4 maxn];int value[maxn];int n, m;//点数，修改次数void pushup(int i) { T[i].sum = T[2 i].sum + T[2 i + 1].sum; T[i].lmax = max(T[2 i].lmax, T[2 i].sum + T[2 i + 1].lmax); T[i].lmin = min(T[2 i].lmin, T[2 i].sum + T[2 i + 1].lmin); T[i].rmax = max(T[2 i + 1].rmax, T[2 i + 1].sum + T[2 i].rmax); T[i].rmin = min(T[2 i + 1].rmin, T[2 i + 1].sum + T[2 i].rmin); T[i].maxNow = max(max(T[2 i].maxNow, T[2 i + 1].maxNow), T[2 i].rmax + T[2 i + 1].lmax); T[i].minNow = min(min(T[2 i].minNow, T[2 i + 1].minNow), T[2 i].rmin + T[2 i + 1].lmin);}void build(int i, int l, int r) { T[i].left = l; T[i].right = r; if (l == r) {//叶子结点，将所有数据初始化为data[end],也就是线段树的元线段 T[i].sum = T[i].lmax = T[i].lmin = T[i].rmax = T[i].rmin = T[i].maxNow = T[i].minNow = value[l]; } else {//左右递归进行建树 int mid = (l + r) &gt;&gt; 1; build(2 i, l, mid); build(2 i + 1, mid+1, r); pushup(i); }}//i代表线段树中的节点,k代表要更新的数字的position,v代表valuevoid update_single(int i,int k,int v) { if (T[i].left == T[i].right) {//更新叶子结点 T[i].sum = T[i].lmax = T[i].lmin = T[i].rmax = T[i].rmin = T[i].maxNow = T[i].minNow = v; return; } int mid = (T[i].left + T[i].right) &gt;&gt; 1; if (k &lt;= mid) update_single(2 i, k, v); else update_single(2 * i + 1, k, v); pushup(i);//注意更新线段树}int main() { int ans, k, v; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) scanf_s(“%d”, &amp;value[i]); build(1, 1, n); cin &gt;&gt; m; while (m–) { cin &gt;&gt; k &gt;&gt; v; update_single(1, k, v); if (T[1].sum == T[1].maxNow) ans = T[1].sum - T[1].minNow; else ans = max(T[1].maxNow, T[1].sum - T[1].minNow); cout &lt;&lt; ans &lt;&lt; endl; }}","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"},{"name":"ACM","slug":"ACM","permalink":"http://Persuingsdu.github.io/tags/ACM/"},{"name":"线段树","slug":"线段树","permalink":"http://Persuingsdu.github.io/tags/线段树/"}]},{"title":"关于郑州的记忆","slug":"关于郑州的记忆","date":"2017-10-05T07:33:33.000Z","updated":"2017-10-20T15:23:06.031Z","comments":true,"path":"2017/10/05/关于郑州的记忆/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/05/关于郑州的记忆/","excerpt":"","text":"关于郑州的记忆关于郑州我知道的不多，为了爱情曾经去过那里多少次在火车上路过这城市，一个人悄悄地想起她她说她喜欢郑州冬天的阳光，巷子里飘满煤炉的味道雾气穿过她年轻的脖子，直到今天都没有散去关于郑州我想的全是你，想来想去都是忏悔和委屈关于郑州我爱的全是你，爱来爱去不明白爱的意义关于郑州只是偶尔想起，现在她的味道都在回忆里每次和朋友说起过去的旅行，我不敢说我曾去过那里关于郑州我想的全是你，想来生活无非是痛苦和美丽关于郑州我爱的全是你，爱到最后我们都无路可去似是而非或是世事可畏，有情有义又是有米无炊时间改变了很多又什么都没有让我再一次拥抱你，郑州","categories":[],"tags":[{"name":"生活杂感","slug":"生活杂感","permalink":"http://Persuingsdu.github.io/tags/生活杂感/"}]},{"title":"My first blog","slug":"My-first-blog","date":"2017-10-04T14:00:56.000Z","updated":"2017-10-26T13:38:53.357Z","comments":true,"path":"2017/10/04/My-first-blog/","link":"","permalink":"http://Persuingsdu.github.io/2017/10/04/My-first-blog/","excerpt":"今天是中秋节，个人的小博客终于搭建起来了😊！","text":"今天是中秋节，个人的小博客终于搭建起来了😊！访客地图","categories":[],"tags":[{"name":"生活杂感","slug":"生活杂感","permalink":"http://Persuingsdu.github.io/tags/生活杂感/"}]}]}