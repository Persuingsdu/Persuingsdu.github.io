{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"document","date":"2018-01-20T06:05:27.000Z","updated":"2018-01-20T06:05:27.285Z","comments":true,"path":"document/index.html","permalink":"http://Persuingsdu.github.io/document/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"最小生成树","slug":"最小生成树","date":"2018-03-27T10:14:14.000Z","updated":"2018-03-29T14:31:13.234Z","comments":true,"path":"2018/03/27/最小生成树/","link":"","permalink":"http://Persuingsdu.github.io/2018/03/27/最小生成树/","excerpt":"","text":"Kruscal算法伪代码MST-KRUSCAL(G,w)A=Φfor each vertex v∈G.V MAKE-SET(v)sort the edges of G.E into nondecreasing order by weight wfor each edge(u,v)∈G.E,taken in nondereasing order by weight if FIND-SET(u)≠FIND-SET(v) A=A∪&#123;(u,v)&#125; UNION(u,v)return A 代码实现：使用并查集#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct Edge &#123; int src, dest, weight; Edge(int src, int dest, int weight) &#123; this-&gt;src = src; this-&gt;dest = dest; this-&gt;weight = weight; &#125; Edge()&#123;&#125;&#125;;struct Graph &#123; int V; vector&lt;Edge&gt; edges;&#125;;Graph* creatGraph(int V) &#123; Graph* graph = new Graph; graph-&gt;V = V; return graph;&#125;struct subset &#123; int parent, rank;&#125;;int find(subset subsets[], int i) &#123; if (subsets[i].parent != i) subsets[i].parent = find(subsets, subsets[i].parent); return subsets[i].parent;&#125;//按rank合并void Union(subset subsets[], int x, int y) &#123; int xRoot = find(subsets, x); int yRoot = find(subsets, y); if (subsets[xRoot].rank &lt; subsets[yRoot].rank) subsets[xRoot].parent = yRoot; else if (subsets[xRoot].rank &gt; subsets[yRoot].rank) subsets[yRoot].parent = xRoot; else &#123; subsets[yRoot].parent = xRoot; subsets[xRoot].rank++; &#125;&#125;bool compare(Edge&amp; a, Edge&amp; b) &#123; return a.weight &lt; b.weight;&#125;void addEdge(Graph* graph, int src, int dest, int weight) &#123; graph-&gt;edges.push_back(Edge(src, dest, weight));&#125;void Kruscal(Graph* graph) &#123; int V = graph-&gt;V; Edge* res = new Edge[V];//最小生成树的边 int e = 0;//边 int i = 0; sort(graph-&gt;edges.begin(), graph-&gt;edges.end(), compare);//按照权值进行排序 subset* subsets = new subset[V]; for (int v = 0; v &lt; V; v++) &#123; subsets[v].parent = v; subsets[v].rank = 0; &#125; while (e &lt; V - 1) &#123; Edge next_Edge = graph-&gt;edges[i++]; int x = find(subsets, next_Edge.src); int y = find(subsets, next_Edge.dest); if (x != y) &#123; res[e++] = next_Edge; Union(subsets, x, y); &#125; &#125; cout &lt;&lt; \"Following are the edges in the constructed MST\\n\"; for (i = 0; i &lt; e; i++) cout &lt;&lt; res[i].src &lt;&lt; \"----\" &lt;&lt; res[i].dest &lt;&lt; \" == \" &lt;&lt; res[i].weight &lt;&lt; endl;&#125;int main() &#123; /* 10 0--------1 | \\ | 6| 5\\ |15 | \\ | 2--------3 4 */ Graph* graph = creatGraph(4); addEdge(graph, 0, 1, 10); addEdge(graph, 0, 2, 6); addEdge(graph, 0, 3, 5); addEdge(graph, 1, 3, 15); addEdge(graph, 2, 3, 4); Kruscal(graph);&#125; Prim算法伪代码MST-PRIM(G,w,r)1 for each u∈G.V2 u:key=∞3 u:π=NIL4 r:key=05 Q=G.V6 while Q≠Φ7 u=EXTRACT-MIN(Q)8 for each vertex v∈G.Adj[u]9 if v∈Q and w(u,v) &lt; v.key10 v.π=u11 v.key=w(u,v) Prim算法的运行时间取决于最小优先队列Q的实现方式。若将Q实现为一个二叉最小优先队列，那么建立最小堆的时间为O(V)。while循环中的语句一共要执行|V|次，每个EXTRACT-MIN的操作时间为O(lgV)，则该操作的总时间为O(VlgV)。所有邻接链表的长度为2|E|，8-11行总执行次数为O(E)，删除操作需要O(lgV)，所以Prim算法总时间代价为O(VlgV+ElgV)=O(ElgV)。从渐进意义上来说，它与Kruscal算法的运行时间相同。 并查集的应用1. Redundant Connection使用并查集判断形成环的最后一条边2. Redundant Connection II3. Friend CirclesDFS求连通分量的个数或者使用并查集。4. Number of Islands5. Longest Consecutive Sequence使用并查集，遍历其中元素，设当前数值为M，判断M+1或者M-1是否在前面出现过，若出现过，则进行合并。算法导论答案CLRS SolutionsSolutions","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/tags/算法/"}]},{"title":"基本的图算法","slug":"基本的图算法","date":"2018-03-22T06:27:01.000Z","updated":"2018-03-26T08:11:33.888Z","comments":true,"path":"2018/03/22/基本的图算法/","link":"","permalink":"http://Persuingsdu.github.io/2018/03/22/基本的图算法/","excerpt":"","text":"广度优先搜索算法伪代码：BFS(G)for each vertex u ∈G.V-&#123;s&#125; u.color=WHITE u.d= ∞ u.π=NILs.color=GRAYs.d=0s.π=NILQ≠фENQUEUE(G,s)while Q≠фu=DEQUEUE(Q)for each v∈G.Adj[u] if(v.color==WHITE) v.color=GRAY v.d=u.d+1 v.π=u ENQUEUE(Q,v)u.color=BLACK 时间复杂度为O(V+E)，广度优先搜索的运行时间是邻接链表大小的一个线性函数。下面的伪代码输出从源结点s到结点v的一条最短路径上的所有结点：PRINT-PATH(G,s,v)if v==s print selse if v.π==NIL print \"no path from\"s\"to\"v\"exits\"else PRINT-PATH(G,s,v.π) print v 深度优先搜索算法伪代码：DFS(G)for each vertex u ∈ G.V u.color=WHITE u.π=NILtime=0for each vertex u ∈ G.V if u.color==WHITE DFS-VISIT(G,u)DFS-VISIT(G,u)time=time+1 //white vertex u has just been discoveredu.d=timeu.color=GRAYfor each vertex v ∈ G:Adj[u] if v.color==WHITE v.π=u DFS-VISIT(G,v)u.color=BLACK //blacken u;it is finishedtime=time+1u.f=time 1.括号定理2.白色路径定理：在有向或无向图G=(V,E)的深度优先森林中，结点v是结点u的后代当且仅当在发现结点u的时间u.d，存在一条从结点u到结点v的全部由白色结点所构成的路径。边的分类：1.树边 2.后向边(back) 3.前向边(forward) 4.横向边(cross)当第一次探索边(u,v)时：1.结点v为白色表明该边是一条树边。2.结点v为灰色表明该边是一条后向边。3.结点v为黑色表明该边是一条前向边或横向边。 拓扑排序拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面TOPOLOGICAL-SORT(G)call DFS(G) to compute finishing time v.f for each vertex vas each vertex is finished,insert it onto the front of a linked listreturn the linked list of vertices 引理：一个有向图G=(V,E)是无环的，当且仅当对其进行的深度优先搜索不产生后向边。定理：拓扑排序算法生成的是有向无环图的拓扑排序。证明：在有向无环图G=(V,E)上运行DFS来计算结点的完成时间。只需要证明，对于任意一对不同的结点u,v∈V,如果图G包含一条从结点u到结点v的边，则v.f &lt; u.f。考虑算法DFS(G)所探索的边(u,v)。当这条边被探索时，结点v不可能是灰色。若为灰色，则结点v是结点u的祖先，所以(u,v)是一条后向边，与之前的引理矛盾。所以结点v为白色或者黑色。若为白色，v是u的后代，则v.f &lt; u.f若为黑色，则对其全部的处理已经完成，v.f已经被设置。还需对u进行探索，最终一定有v.f &lt; u.f。 拓扑排序的另外一种实现方式：Another way to perform topological sorting on a directed acyclic graph G = (V, E) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time O(V + E). What happens to this algorithm if G has cycles?General idea:Run BFS or DFS to calculate in-degree of each vertex. O(V+E)For each vertex that in-degree is 0, print it and update the in-degree of its neighbors accordingly, then there will be new in-degree=0 vertexes. Repeat this step until all vertex got printed. The entire process is also O(V+E)If G has cycles, then after several iterations there will be no in-degree=0 vertexes. But original topological sorting algorithm is also only applied to directed acyclic graph.判断一个有向图是否存在环，只要判断是否有backedge。题目Course Schedulebool res=true;void dfs_visited(vector&lt;int&gt;&amp; visited, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites, int s,vector&lt;list&lt;int&gt;&gt;&amp; adj)&#123; visited[s] = 0; list&lt;int&gt;::iterator i; for (i = adj[s].begin(); i != adj[s].end(); i++) &#123; if (visited[*i] == -1) dfs_visited(visited, prerequisites, *i, adj); if (visited[*i] == 0) &#123; res = false; return; &#125; &#125; visited[s] = 1;&#125;bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;int&gt; visited(numCourses, -1); vector&lt;list&lt;int&gt;&gt; adj(numCourses); for (int i = 0; i &lt; prerequisites.size(); i++) &#123; int u = prerequisites[i].second; int v = prerequisites[i].first; adj[u].push_back(v); &#125; for (int j = 0; j &lt; numCourses; j++) dfs_visited(visited, prerequisites, j, adj); return res;&#125; 强连通分量创建GT的时间为O(V+E)下面的线性时间算法使用两次深度优先搜索计算有向图G=(V,E)的强连通分量。这两次深度优先搜索一次运行在G上，一次运行在转置图GT上。call DFS(G) to compute finishing times u.f for each vertex ucompute GTcall DFS(GT),but in the main loop of DFS,consider the vertices in order of decreasing u.f(as computed in line 1)output the vertices of each tree in the depth-first forest formed in line 3 as a separated connected component 分量图的关键性质：分量图是一个有向无环图。定义：d(U)=min(u∈U){u.d},f(U)=max(u∈U){u.f}即d(U)和f(U)分别是结点集合U中所有结点里最早发现的时间和最晚的结束时间。 引理：设C和C’为有向图G=(V,E)的两个不同的强连通分量。假如存在一条边(u,v)∈E，这里u∈C，v∈C’。则：f(C)&gt;f(C’)证明:1.第一种情况：若d(C) &lt; d(C')，设x为C中最早被发现的结点。则在x.d时，所有C和C'中的结点都是白色。在该时刻，图G中包含一条从结点x到C中每个结点的仅有包含白色结点的路径。因为(u,v)∈E，对于任意结点w∈C'，在时刻x.d时，G中存在一条只包含白色结点的路径：x~u-v~w，所以根据白色路径定理，连通分量C'中的所有结点都成为深度优先搜索树中x的的后代，则根据22.8，结点x的完成时间比其它所有的后代都晚，则x.f=f(C)&gt;f(C')。2.第二种情况：如果d(C) &gt; d(C')，设y为C'中最早被发现的结点。则在y.d时，所有C'中的结点都是白色。且图C'包含一条从结点y到C'中每个结点的仅包含白色结点的路径。根据白色路径定理，C'中的所有结点都将成为深度优先搜索树中y的后代，有f(C')=y.f。在时刻y.d，所有C中的结点都为白色，有(u,v)，所以不可能存在从C'到C的路径，所以C中的结点不可能从y到达。在时刻y.f，所有C中的结点都为白色。因此对任意结点w∈C来说有w.f&gt;y.f，所以f(C)&gt;f(C')。 推论：设C和C’为有向图G=(V,E)两个不同的强连通分量，加入存在一条边(u,v)属于ET，这里u∈C，v∈C’则有f(C)&lt; f(C’)第二次深度优先搜索运行在GT上，我们从完成时间最晚的强连通分量C开始。搜索算法从C中的某个结点x开始，访问C中的所有结点。根据该推论，GT中不可能包含从C到其它任何强连通分量的边。定理：算法STRONGLY-CONNECTED-COMPONENTS能够正确地计算出有向图G的强连通分量利用归纳法证明。给定有向图G=(V,E)，如果对所有结点对u，v∈V，我们都有u~v或者v~u，则G是半连通的。给出一个有效的算法来判断图G是否是半连通的。先求出所有的强连通分量，然后利用拓扑排序，若存在链条式的结构则说明该图是半连通的。3/23更新 衔接点、桥和双连通分量Biconnected component参考一参考二求Articulation Points算法伪代码:GetArticulationPoints(i, d) visited[i] = true dis[i] = d low[i] = d //定义u.low=MIN(u.d,w.d:(v,w)是结点u的某个后代v的一个backedge) childCount = 0 isArticulation = false for each ni in adj[i] if not visited[ni]//没有访问过 parent[ni] = i GetArticulationPoints(ni, d + 1) childCount = childCount + 1 if low[ni] &gt;= dis[i] isArticulation = true low[i] = Min(low[i], low[ni]) else if ni &lt;&gt; parent[i] //访问过 low[i] = Min(low[i], dis[ni]) //较小者 ni为i能到达的结点，也就是backedge if (parent[i] &lt;&gt; null and isArticulation) or (parent[i] == null and childCount &gt; 1) Output i as articulation point Reason：Biconnected graph: A graph with no articulation point called biconnected. In other words, a graph is biconnected if and only if any vertex is deleted, the graph remains connected.判断一个图是否是Biconnected只需要判断图中是否存在articulation point Biconnected component: A biconnected component of a graph is a maximal biconnected subgraph- a biconnected subgraph that is not properly contained in a larger biconnected subgraph.参考一参考二","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/tags/算法/"}]},{"title":"计算机图形学","slug":"B计算机图形学","date":"2018-03-11T05:37:48.000Z","updated":"2018-03-11T10:32:38.038Z","comments":true,"path":"2018/03/11/B计算机图形学/","link":"","permalink":"http://Persuingsdu.github.io/2018/03/11/B计算机图形学/","excerpt":"","text":"Bresenham算法主要参考#include &lt;GL/glut.h&gt;#include&lt;math.h&gt;using namespace std;const GLfloat d = 0.04;//布局网格线 25*25void draw_line() &#123; int i; for (i = -25; i &lt; 25; i++) &#123; //垂线 glBegin(GL_LINES); glClear(GL_COLOR_BUFFER_BIT); glColor3f(0.0f, 0.0f, 0.0f); glLineWidth(2); glVertex2f(i*d, -25); glVertex2f(i*d, 25); glEnd(); //水平 glBegin(GL_LINES); glLineWidth(2); glVertex2f(-25, i*d); glVertex2f(25, i*d); glEnd(); glFlush(); &#125;&#125;//涂色void put_rect(int x, int y) &#123; glRectf(x*d, y*d, (x + 1)*d, (y + 1)*d);&#125;//画线void bresenham(int xf,int yf,int xt,int yt) &#123; int i, j; //根据坐标画出直线 glBegin(GL_LINES); glClear(GL_COLOR_BUFFER_BIT); glLineWidth(2); glVertex2f(xf*d, yf*d); //定点坐标范围 glVertex2f(xt*d, yt*d); glEnd(); draw_line();//网格 //Bresenham算法进行涂色 if (xf &gt; xt) &#123; int t; t = xf; xf = xt; xt = t; t = yf; yf = yt; yt = t; &#125; int dx = xt - xf; int dy = yt - yf; int f = 0; if (dy &gt;= 0 &amp;&amp; dy &lt;= dx) &#123; for (int x = xf, y = yf; x &lt;= xt; x++) &#123; put_rect(x, y); if ((f + dy) + (f + dy - dx) &lt; 0) f += dy; else &#123; f += dy - dx; y++; &#125; &#125; &#125; else if (dy &gt;= 0 &amp;&amp; dy &gt; dx) &#123; for (int x = xf, y = yf; y &lt;= yt; y++) &#123; put_rect(x, y); if ((f - dx) + (f - dx + dy) &gt; 0) f += -dx; else &#123; f += -dx + dy; x++; &#125; &#125; &#125; else if (dy &lt;= 0 &amp;&amp; -dy &lt;= dx) &#123; for (int x = xf, y = yf; x &lt;= xt; x++) &#123; put_rect(x, y); if ((f + dy) + (f + dy + dx) &gt; 0) f += dy; else &#123; f += dy + dx; y--; &#125; &#125; &#125; else if (dy &lt;= 0 &amp;&amp; -dy &gt; dx) &#123; for (int x = xf, y = yf; y &gt;= yt; y--) &#123; put_rect(x, y); if ((f + dx) + (f + dy + dx) &lt; 0) f += dx; else &#123; f += dy + dx; x++; &#125; &#125; &#125;&#125;void display() &#123; bresenham(-10,-18,20, 18);&#125;int main(int argc, char *argv[])&#123; //初始化opengl工具箱函数库 glutInit(&amp;argc, argv); //设置RGB色彩模式与单缓冲绘图模式 glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //设置图像显示窗口的左上角位置(0,0) glutInitWindowPosition(0, 0); //设置窗口大小(600,600) glutInitWindowSize(600, 600); //设置窗口标题 glutCreateWindow(\"Bressenham\"); glClearColor(1.0, 1.0, 1.0, 0.0); //设置当前清除颜色 glClear(GL_COLOR_BUFFER_BIT); //设置主程序循环显示过程中所调用的显示函数 //dispaly，表示取得函数名所对应的地址（函数地址） glutDisplayFunc(&amp;display); //程序主循环 glutMainLoop(); return 0;&#125; 运行结果：Liang-Barsky剪裁算法#include\"GL\\glut.h\"#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define Height 100#define Width 200#define StartX 100#define StartY 150GLint S[4], f, N[4];float u1 = 0, u2 = 1;void drawRect() &#123; glColor3f(1.0f, 1.0f, 1.0f); glBegin(GL_QUADS); glVertex2f(StartX, StartY); glVertex2f(StartX + Width, StartY); glVertex2f(StartX + Width, StartY + Height); glVertex2f(StartX, StartY + Height); glEnd(); glFlush();&#125;//布局void InitEnvironment()&#123; glClearColor(0.6, 0.6, 0.6, 0); glClear(GL_COLOR_BUFFER_BIT); glPointSize(6); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); gluOrtho2D(0, 400, 0, 400);&#125;void hilight(int x1, int y1, int x2, int y2) &#123; glColor3f(0.0f, 0.0f, 0.0f); glBegin(GL_LINES); glLineWidth(2); glVertex2f(x1, 400 - y1); glVertex2f(x2, 400 - y2); glEnd(); glFlush();&#125;//测试int LBLineClipTest(float p, float q, float &amp;umax, float &amp;umin) &#123; float r = 0.0; if (p &lt; 0.0) &#123; r = q / p; if (r &gt; umin) &#123; return 0; &#125; else if (r &gt; umax) &#123; umax = r; &#125; &#125; else if (p &gt; 0.0) &#123; r = q / p; if (r &lt; umax) &#123; return 0; &#125; else if (r &lt; umin) &#123; umin = r; &#125; &#125; else if (q &lt; 0.0) &#123; return 0; &#125; return 1;&#125;void LBLineClip(float xwl, float xwr, float ywb, float ywt, float x1, float y1, float x2, float y2) &#123; float umax, umin, deltax, deltay, xx2, yy2, xx1, yy1; deltax = x2 - x1; deltay = y2 - y1; umax = 0.0; umin = 1.0; if (LBLineClipTest(-deltax, x1 - xwl, umax, umin)) &#123; if (LBLineClipTest(deltax, xwr - x1, umax, umin)) &#123; if (LBLineClipTest(-deltay, y1 - ywb, umax, umin)) &#123; if (LBLineClipTest(deltay, ywt - y1, umax, umin)) &#123; xx1 = int(x1 + umax*deltax + 0.5); yy1 = int(y1 + umax*deltay + 0.5); xx2 = int(x1 + umin*deltax + 0.5); yy2 = int(y1 + umin*deltay + 0.5); &#125; hilight(xx1, yy1, xx2, yy2); &#125; &#125; &#125;&#125;void myDisplay(void)&#123; glClear(GL_COLOR_BUFFER_BIT); glFlush();&#125;//鼠标事件void OnMouse(int button, int state, int x, int y)&#123; drawRect(); if (button == GLUT_LEFT_BUTTON&amp;&amp;state == GLUT_DOWN) &#123; if (f % 2 == 0) &#123; f++; S[0] = x; S[1] = y; &#125; else &#123; f++; S[2] = x; S[3] = y; &#125; &#125; glBegin(GL_POINTS);//画点 glVertex2f(S[0], 400 - S[1]); glEnd(); glBegin(GL_POINTS);//画点 glVertex2f(S[2], 400 - S[3]); glEnd(); //画线 glColor3f(1.0f, 0.0f, 1.0f); glBegin(GL_LINES); glLineWidth(2); glVertex2f(S[0], 400 - S[1]); glVertex2f(S[2], 400 - S[3]); glEnd(); glFlush(); LBLineClip(StartX, StartX + Width, StartY, StartY + Height, S[0], S[1], S[2], S[3]);&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); //初始化GLUT glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(500, 200); glutInitWindowSize(400, 400); glutCreateWindow(\"LB\"); drawRect(); InitEnvironment(); //初始化 glutMouseFunc(&amp;OnMouse); //注册鼠标事件 glutDisplayFunc(&amp;myDisplay); //回调函数 glutMainLoop(); //持续显示，当窗口改变会重新绘制图形 return 0;&#125; 运行结果：","categories":[],"tags":[{"name":"CG","slug":"CG","permalink":"http://Persuingsdu.github.io/tags/CG/"}]},{"title":"函数","slug":"函数","date":"2018-02-18T05:10:10.000Z","updated":"2018-02-18T05:10:10.163Z","comments":true,"path":"2018/02/18/函数/","link":"","permalink":"http://Persuingsdu.github.io/2018/02/18/函数/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DOM扩展","slug":"DOM扩展","date":"2018-02-14T09:33:46.000Z","updated":"2018-02-14T11:43:11.228Z","comments":true,"path":"2018/02/14/DOM扩展/","link":"","permalink":"http://Persuingsdu.github.io/2018/02/14/DOM扩展/","excerpt":"","text":"尽管DOM作为API已经非常完善了，但为了实现更多的功能，仍然会有一些标准的或专有的扩展。对DOM的两个主要的扩展是Selection API(选择符API)和HTML5。这两个扩展都源自开发社区。 选择符API众多JavaScript库中最常用的一项功能，就是根据CSS选择符选择与某个模式匹配的DOM元素。实际上，jQuery的核心就是通过CSS选择符查询DOM文档取得元素的引用.SelectionAPILevel1的两个核心是两个方法：querySelector()，querySelectorAll()。在兼容的浏览器中，可以通过Document及Element类型的实例调用他们。1.querySelector()方法该方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有匹配的元素，返回null。例如：取得ID为”myDiv”的元素，var myDiv=document.querySelector(&quot;#myDiv&quot;);2.querySelectorAll()方法接收一个CSS选择符，返回的是一个NodeList的实例。能够调用该方法的类型包括Document，DocumentFragment和Element。//取得某&lt;div&gt;中的所有&lt;em&gt;元素var ems=document.getElementById(\"myDiv\").querySelectorAll(\"em\");//取得类为\"selected\"的所有元素var selected=document.querySelectorAll(\".selected\");//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strong=document.querySelectorAll(\"p strong\"); HTML5HTML5规范围绕如何使用新增标记定义了大量JavaScript API,其中一些API与DOM重叠，定义了浏览器应该支持的DOM扩展。1.与类相关的扩充1.getElementByClassName()接收一个包含一个多个类名的字符串，返回带有指定类的所有元素的NodeList。//取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓var allCurrentUsernames=document.getElementsByClassName(\"username current\");//取得ID为\"myDiv\"的元素中带有类名\"selected\"的所有元素var selected=document.getElementById(\"myDiv\").getElementsByClassName(\"selected\"); 2.classList属性支持该属性的浏览器有Firefox3.6+和Chrome。方法如下：1.add(value)2.contain(value)3.remove(value)4.toggle(value)如果列表中已经存在指定的值，删除它。如果列表中没有给定的值，添加它。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Persuingsdu.github.io/tags/javascript/"}]},{"title":"DOM","slug":"DOM","date":"2018-02-07T06:36:26.000Z","updated":"2018-02-14T11:48:57.199Z","comments":true,"path":"2018/02/07/DOM/","link":"","permalink":"http://Persuingsdu.github.io/2018/02/07/DOM/","excerpt":"","text":"DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外与其它节点存在某种关系，节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的HTML为例子:&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其它所有元素都包含在这个文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是元素。将上述HTML文档表示为一个层次结构 Node类型节点关系每个节点都有一个childNodes属性，其中保存着一个NodeList对象，可以用[]来访问NodeList的值，而且有length属性，并且它是基于DOM结构动态执行查询的结果，而不是在访问某一瞬间拍摄下来的快照。var firstChild=someNode.childNodes[0];var secondChild=someNode.childNodes.item(1);var count=someNode.childNodes.length; 将NodeList对象转换为数组。function convertToArray(nodes)&#123; var array=null; try&#123; array=Array.prototype.slice.call(nodes,0);//针对非ie浏览器 &#125;catch(ex)&#123; array=new Array(); for(var i=0,len=nodes.length;i&lt;len;i++)&#123; array.push(nodes[i]); &#125; &#125; return array;&#125; 每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes列表中所有节点都具有相同的父节点。此外，包含在其中的每个节点相互之间都是同胞节点。使用previousSibling和nextSibling属性，可以访问同一列表中的其他节点。并且第一个节点的previousSibling和最后一个节点的nextSibling为null。父节点的firstChild和lastChild属性分别指向childNodes列表中的第一个节点和最后一个节点。hasChildNodes()方法在节点包含一个或多个节点的情况下返回true。所有节点都有的一个属性是ownerDocument，该属性指向表示整个文档的文档节点。操作节点因为关系指针都是只读的，所以DOM提供了一些操作节点的方法。appendChild()，用于向childNodes列表的末尾添加一个节点，如果该节点已经是文档的一部分，就将该节点从原来位置转移到新位置。insertBefore()放到childNodes列表中某个特定的位置上，接受两个参数：要插入的节点和作为参照的节点。//插入后成为最后一个节点var returnNode=someNode.insertBefore(newNode,null);alert(returnNode==someNode.lastChild);//true;//插入后成为第一个节点returnNode=someNode.insertBefore(newNode,someNode.firstChild);alert(returnNode==newNode);//truealert(newNode=someNode.firstChild);//true replaceChild()接受两个参数：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档中移除，同时由要插入的节点占据其位置。被替换的节点仍然还在文档中，但它在文档中已经没有自己的位置removeChild()也是类似。//替换第一个节点var returnNode=someNode.replaceChild(newNode,someNode.firstChild);//移除第一个节点var formerFirstChild=someNode.removeChild(someNode.firstChild); cloneNode()接受一个布尔值，表示是否执行深复制。 Document类型JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且Document对象是window对象的一个属性，因此可以将其作为全局对象访问。Document类型可以表示HTML页面或者其它基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以获得与页面有关的信息，而且还能操作页面的外观及其底层结构。1.文档的子节点 documentElement，该属性始终指向HTML页面中的元素var html=document.documentElement; body属性直接指向body元素var body=document.body; 2.文档信息//取得文档标题var oringinalTitle=document.title;//设置文档document.title=\"New Page title\";//取得完整的URLvar url=document.URL;//取得域名var domain=document.domain;//取得来源页面的URLvar referrer=document.referrer; 3.查找元素1.getElementById()如果页面中多个元素的ID值相同，只返回文档中第一次出现的元素&lt;div id=\"myDiv\"&gt;Some text&lt;/div&gt;var div=document.getElementById(\"myDiv\");//获得&lt;div&gt;元素的引用 由于IE7特性，最好不要让表单字段的name值与其它元素的id值相同。2.getElementByTagName()在HTML文档中，这个方法会返回一个HTMLCollection对象，使用方括号或者item()方法来访问该对象中的项，通过length属性获得该对象中元素的个数,使用namedItem()通过元素的name特性取得集合中的项。&lt;img src=\"myimage.gif\" name=\"myImage\"&gt;var images=document.getElementsByTagName(\"img\");alert(images.length);//输出图像的数量alert(images[0].src);//输出第一个图像元素的src特性alert(images.item(0).src);//通过如下方式从images变量中获得&lt;img&gt;元素var myImg=images.namedItem(\"myImage\");var myImg=images[\"myImage\"] 4.特殊集合document.images document.linksdocument.anchors document.forms5.文档写入write()和writel()(字符串末尾添加一个换行\\n符号)方法都会接受一个字符串参数，即要写入到输出流中的文本。并且在文档加载结束后再调用document.write(),那么输出的内容将会重写整个页面。&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;document.write() Example&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;The current data and time is: &lt;script type=\"text/javascript\"&gt; document.write(\"&lt;strong&gt;\"+(new Date()).toString()+\"&lt;/strong&gt;\") &lt;/script&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果如下: Element类型除了Document类型之外，Element类型就算是Web编程中最常用的类型了。Element类型用于表现XML或HXML元素，提供了对元素标签名、子节点及特性的访问。使用nodeName或者tagName属性来访问元素的标签名。&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;可以像下面这样取得这个元素及其标签名var div=document.getElementById(\"myDiv\");alert(div.tagName);//DIValert(div.tagName==div.nodeName);//true 1.HTML元素所有HTML元素都由HTMLElement类型表示。HTMLElement类型都直接继承自Element并添加了一些如下属性id,title,lang(元素内容的语言代码，很少使用)dir(语言的方向，值为ltr或者rtl，很少使用),className2.取得特性每个元素都有一或多个特性，用途是给出相应元素或其内容的附加信息。操作特性的DOM方法主要有三个，getAttribute(),setAttribute(),removeAttribute()以上方法可以针对任何特性使用，包括那些以HTMLElement类型属性的形式定义的特性。开发人员不常用getAttribute(),而是只使用对象的属性，只有在取得自定义特性值的情况下，才会使用该方法。3.设置属性setAttribute()接受两个参数：要设置的特性名和值。div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;);4.attribues属性Element类型是使用attribute属性的唯一一个DOM方法。attribute属性中包含一个NamedNodeMap，是一个“动态”的集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。NamedNodeMap拥有以下方法:getNamedItem(name),removedNamedItem(name),setNamedItem(node),item(pos)attributes属性包含一系列节点，每个节点的nodeName就是特性的名称，nodeValue就是特性的值。例如取得元素的id特性：var id=element.attributes.getNamedItem(&quot;id&quot;).nodeValue;5.创建元素使用document.createElement();可以创建新元素。可以操作元素的特性，为它添加更多的子节点。div.id=\"myNewDiv\";div.className=\"box\"; 使用appendChild(),insertBefore(),replaceChild()可以把新元素添加到文档树中。下面的代码会把新创建的元素添加到文档的元素中：document.body.appendChild(div); Text类型文本节点由Text类型，包含的可以是按照字面解释的纯文本内容。纯文本中可以包含转义的HTML字符，但不能包含HTML代码。可以通过nodeValue属性或者data属性访问Text节点中包含的文本。使用下列方法可以操作节点中的文本：appendData(text),deleteData(offset,count),insertData(offset,text),replaceData(offset,count,text),splitText(offset),substringData(offset,count)。length属性保存着节点中字符的数目。1.创建文本节点使用createTextNode(),例如：var element=document.createElement(\"div\");element.className=\"message\";var textNode=document.createTextNode(\"HelloWorld\");element.appendChild(textNode);document.body.appendChild(element); 2.规范化文本节点normalize()能够将相邻文本节点合并成一个节点。3.分割文本节点splitText(),这个会将 一个文本节点分成两个文本节点，即按照指定的位置分割nodeValue值。 Comment类型注释在DOM中是通过Comment类型来表示的。var div=document.getElementById(\"myDiv\");var comment=div.firstChild;alert(comment.nodeValue); 开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。其余几种类型：CDATASection类型，DocumentType类型，DocumentFragment类型，Attr类型。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Persuingsdu.github.io/tags/javascript/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2018-02-06T14:33:30.000Z","updated":"2018-02-06T12:53:28.382Z","comments":true,"path":"2018/02/06/正则表达式/","link":"","permalink":"http://Persuingsdu.github.io/2018/02/06/正则表达式/","excerpt":"","text":"正则表达式的定义正则表达式（regular expression）是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法，后者使用正则表达式进行更强大的模式匹配和文本检索和替换功能。直接字符量字母和数字字符 \\o \\t \\n \\v \\f \\r字符类将直接量字符直接放进方括号内就组成了字符类（character class）[...] [^...] . \\w \\W \\s \\S \\d \\D重复{n,m} {n,} {n} ? + *一些例子：/\\d{2,4}/ 匹配2~4个数字/\\w{3}\\d/ 精确匹配三个单词和一个可选的数字/\\s+java\\s+/ 匹配前后带有一个或者多个空格的字符串“java”/[^(]*/ 匹配一个或多个非左括号的符号非贪婪的重复?? +? *? {1,5}?/a+/匹配aaa三个字符，不过/a+?/只匹配第一个。/a+b/和/a+?b/匹配aaab时都会匹配整个字符串，因为正则表达式的模式匹配总会寻找字符串中第一个可能匹配的位置。选择、分组和引用字符|用于分隔供选择的字符，/d{3}|[a-z]{4}/匹配的是三个数字或者四个小写字母。从左到右匹配，如果左边的匹配就忽略右边的匹配项。正则表达式中圆括号的作用： 把单独的项组合成子表达式 /java(script)?/ 在完整的模式中定义子模式 /[a-z]+(\\d+)/ 允许同一正则表达式的后部引用前面的表达式 /([&#39;&quot;][^&#39;&quot;]*\\1)/ 指定匹配位置^ $ \\b \\B (?=p) (?!p)修饰符i g m 用于模式匹配的String方法String对象的一些用以执行正则表达式模式匹配和检索和替换操作的方法。1.search()接受一个正则表达式，返回第一个与之匹配的字串的起始位置，若找不到匹配的字串，它将返回-1.下面的调用返回值为4 &quot;JavaScript&quot;.search(/script/i)2.replace()方法用以执行检索和替换操作。接受两个参数：第一个是正则表达式，第二个为参数要进行替换的字符串。txt.replace(/javascript/gi,&quot;JavaScript&quot;)替换字符中出现了$加数字var txt=\"\\\"javaScripT i jAvaScriPt\\\"\";var quote=/\"([^\"]*)\"/g;console.log(txt);//\"javaScripT i jAvaScriPt\"txt=txt.replace(quote,'\\'$1\\'');console.log(txt);//'javaScripT i jAvaScriPt' 并且replace()的第二个参数可以是函数，该函数能够动态地计算替换字符串。3.match()唯一的参数为正则表达式，返回的是一个由匹配结果组成的数组，如果正则表达式设置了修饰符g，则该方法返回的数组中包含字符中的所有匹配的结果。如果没有修饰符g，它只检索第一个匹配。var url=/(\\w+):\\/\\/([\\w.]+)\\/(\\S*)/;var text=\"Visit my blog at http://www.example.com/~david\";var result=text.match(url);if(result)&#123; var fullurl=result[0];//http://www.example.com/~david var protocol=result[1];//http var host=result[2];//www.example.com var path=result[3];//~david&#125; a[0]存放的是完整的匹配，a[n]存放的是$n的内容。4.splict()这个方法用以调用它的字符串拆分为一个字串组成的数组。 RegExp对象除了RegExp()构造函数之外，RegExp对象还支持三个方法和一个属性。RegExp()构造函数带有两个字符串参数，其中第二个参数是可选的。var zipcode=new RegExp(&quot;\\\\d{5}&quot;,&quot;g&quot;)全局匹配字符串中的5个数字，注意这里用了\\\\,而不是\\。属性1.source包含正则表达式的文本，只读。2.global说明正则表达式是否带有修饰符g3.ignoreCase说明正则表达式是否都带有修饰符i4.multiline说明正则表达式是否带有修饰符m5.lastIndex是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一个检索的开始位置，这个属性会被exec()和test()方法用到。 RegExp方法exec()返回一个数组，属性index包含了发生匹配的字符位置，属性input引用的是正在检索的字符串。当同一个正则表达式第二次调用exec()时，它将从lastIndex属性所指示的字符串处开始检索。var pattern=/Java/gvar text=\"JavaScript is more fun than Java!\";var result;while((result=pattern.exec(text))!=null)&#123; console.log(\"Matched'\"+result[0]+\"'\"+\" at position \"+result.index+ \"; next search at \"+pattern.lastIndex); console.log(result.input);//JavaScript is more fun than Java!&#125;//Matched'Java' at position 0; next search at 4//Matched'Java' at position 28; next search at 32 test()使用var pattern=/java/i;patter.test(\"JavaScript\"); 更多参考以上内容源于《JavaScript权威指南》","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Persuingsdu.github.io/tags/javascript/"}]},{"title":"面向对象程序设计","slug":"面向对象程序设计","date":"2018-02-05T06:44:12.000Z","updated":"2018-02-05T13:19:43.972Z","comments":true,"path":"2018/02/05/面向对象程序设计/","link":"","permalink":"http://Persuingsdu.github.io/2018/02/05/面向对象程序设计/","excerpt":"","text":"面向对象程序设计ECMA-262把对象定义为“无序属性的集合，其属性可以包含基本值、对象或者函数”，严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都一个名字，而每个名字都映射到一个值。1.常用对象字面量创建这种使用Object来创建自定义对象的方法。var person=&#123; name:\"Nicholas\", age:29, job:\"Software Engineer\" sayName:function()&#123; console.log(this.name); &#125;&#125;; 属性类型ECMAScript中有两种属性：数据属性和访问器属性1.数据属性[[Configurable]],[[Enumerble]],[[Writable]],[[Value]]直接在对象上定义的属性，它们的前三种特性都被设置为true，而[[Value]]特性被设置为指定的值。使用Obejct.defineProperty()修改属性默认的特性，接受三个参数属性所在的对象、属性的名字和一个描述符对象。var person=&#123;&#125;;Object.defineProperty(person,\"name\",&#123; writable:false, value:\"Nicholas\"&#125;); 一旦把configurable设置为false之后就会有限制了。在调用Obejct.defineProperty()方法创建一个新的属性时，如果不指定，其三种特定都被设置为false。2.访问器属性[[Configurable]],[[Enumerable]],[[Get]],[[Set]]访问器属性不能够直接定义，必须使用Obejct.defineProperty()来定义。var book=&#123; _year:2004, edition:1&#125;;Object.defineProperty(book,\"year\",&#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year=newValue; this.edition+=newValue-2004;//设置一个属性的值会导致其它属性的值发生变化 &#125; &#125;&#125;);book.year = 2005;console.log(book.edition);//2 定义多个属性的值，使用Object.defineProperties，接受两个对象参数：一个对象是要添加或者修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。读取属性的特性Object.getOwnPropertyDescriptor();,接受两个参数：属性所在的对象和要读取其描述符的属性名称。 创建对象构造函数模式function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; console.log(this.name); &#125;&#125;var person1=new Person(\"Nicholas\",29,\"Software Engineer\"); 存在的问题：每个方法在每个实例上都要重新创建一遍。原型模式我们创建的每个函数都一个prototype(原型)属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。每当代码读取某个对象的某个属性时，都会执行一次搜索，首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值。如果没有这个值，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。当为对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。使用delete操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。使用hasOwnProperty()方法可以检测一个属性是否存在于实例中，还是存在于原型中。更简单的原型语法function Person()&#123;&#125;Person.prototype=&#123; constructor:Person, name:\"Nicholas\", age:29, job:\"Software Engineer\", sayName:function()&#123; console.log(this.name); &#125;&#125;; 原型的动态性var friend=new Person();Person.prototype.sayHi=function()&#123; console.log(\"Hi\")&#125;friend.sayHi();//Hi 原型对象存在数据共享的问题。组合使用构造函数和原型模式避免构造函数和原型对象产生的问题。function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=[\"Shelby\",\"Court\"];&#125;Person.prototype=&#123; constructor:Person, sayName:function()&#123; console.log(this.name); &#125;&#125;var person1=new Person(\"Nicholas\",29,\"Software Engineer\");var person2=new Person(\"Grey\",27,\"Doctor\");person1.friends.push(\"Van\");console.log(person1.friends);//\"Shelby,Court,Van\"console.log(person2.friends);//\"Shelby,Court\" 继承ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针1.实现原型链的基本模式function SuperType()&#123; this.propery=true;&#125;SuperType.prototype.getSuperValue=function()&#123; return this.propery;&#125;function SubType()&#123; this.subproperty=false;&#125;//继承了SuperTypeSubType.prototype=new SuperType();SubType.prototype.getSubValue=function()&#123; return this.subproperty;&#125;var instance=new SubType();console.log(instance.getSuperValue());//true 关系图示原型链存在的问题：1.包含引用类型值的原型。2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。使用构造函数传递参数function SuperType(name)&#123; this.name=name;&#125;function SubType()&#123; //继承了SuperType,同时还传递了参数 SuperType.call(this,\"Nicholas\"); this.age=29;&#125;var instance=new SubType();console.log(instance.name);console.log(instance.age); 组合继承组合继承（combination inheritance）：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。function SuperType(name)&#123; this.name=name; this.colors=[\"red\",\"blue\",\"green\"];&#125;SuperType.prototype.sayName=function()&#123; console.log(this.name);&#125;function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age=age;&#125;//继承方法SubType.prototype=new SuperType();SubType.constructor=SubType;SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;;var instance1=new SubType(\"Nicholas\",29);instance1.colors.push(\"black\");console.log(instance1.colors);//\"red,blue,green,black\"instance1.sayName();//Nichaolasinstance1.sayAge();//29var instance2=new SubType(\"Grey\",27);console.log(instance2.colors);//\"red,blue,green\"instance2.sayName();//Greyinstance2.sayAge();//27 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，称为JavaScript中最常用的继承模式。原型式继承要求必须有一个对象作为另一个对象的基础。ECMAScript5通过新增Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义的额外的属性。var person=&#123; name:\"Nicholas\", friends:[\"Shelby\",\"Court\",\"Van\"]&#125;;var anotherPerson=Object.create(person);anotherPerson.name=\"Grey\";anotherPerson.friends.push(\"Rob\");var yetAnotherPerson=Object.create(person);yetAnotherPerson.name=\"Linda\";yetAnotherPerson.friends.push(\"Barbie\");console.log(person.friends);//\"Shelby,Court,Van,Rob,Barbie\" 寄生式继承寄生式（parasitic）即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。function createAnother(original)&#123; var clone=Object(original); clone.sayHi=function()&#123; console.log(\"Hi\"); &#125; return clone;&#125;var person=&#123; name:\"Nicholas\", friends:[\"Shelby\",\"Court\",\"Van\"]&#125;;var anotherPerson=createAnother(person);anotherPerson.sayHi();//Hi 包含引用类型的值始终会共享相应的值。寄生组合式继承function inheritPrototype(subType,superType)&#123; var prototype=Object(superType.prototype); prototype.constructor=subType; subType.prototype=prototype;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Persuingsdu.github.io/tags/javascript/"}]},{"title":"引用类型","slug":"引用类型","date":"2018-01-31T14:50:30.000Z","updated":"2018-02-02T15:25:38.786Z","comments":true,"path":"2018/01/31/引用类型/","link":"","permalink":"http://Persuingsdu.github.io/2018/01/31/引用类型/","excerpt":"","text":"引用类型引用类型的值（对象）是引用类型的一个实例。引用类型有时候也被称为对象定义，因为它们描述的是一类对象具有的属性和方法；新对象是使用new操作符和一个构造函数来创建。 Object类型创建Object实例的方法：1.使用new操作符后跟Object构造函数var person = new Object();person.name = \"Nicholas\";person.age = 29; 2.使用对象字面量表示方法var person = &#123;name:\"Nicolas\",age:29&#125; var person=&#123;&#125;;//与new Object()相同person.name=\"Nicholas\";person.age=29; 开发人员更青睐于使用对象字面量语法，因为语法要求的代码量少，并且有封装数据的感觉，同时，也是向函数传递大量可选参数的首选方式，例如：function displayInfo(args)&#123; var output=\"\"; if(typeof args.name==\"string\")&#123; output+=\"Name:\"+args.name+\"\\n\"; &#125; if(typeof args.age==\"number\")&#123; output+=\"Age:\"+args.age+\"\\n\"; &#125; console.log(output);&#125;displayInfo(&#123;name:\"Nicholas\",age:29&#125;);displayInfo(&#123;name:\"Grey\"&#125;); Array类型创建数组的基本方式var colors=new Array();var colors=new Array(20);var colors=new Arry(\"red\",\"green\",\"blue\"); 第二种使用数组字面量表示法var colors=[\"red\",\"green\",\"blue\"];var names=[];//创建一个空数组 可以通过索引来访问元素，如果设置某个值的索引超过了该数组的现有项数，数组就会自动添加到该索引的值加1var colors=[\"red\",\"green\",\"blue\"];colors[99]=\"black\";alert(colors.length);//100//数组大小为100，位置3-98实际上是不存在的，所有访问它们，都将返回undefined 另外，可以通过修改数组的length属性，可以从数组的末尾移除项或者向数组中添加新项；var colors=[\"red\",\"green\",\"blue\"];colors.length=2;alert(colors[2]);//undefined 检测数组if(Array.isArray(value))确定某个对象是不是数组栈方法ECMAScript专门提供了push()和pop()方法，以便实现类似栈的行为。push()方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后的数组的长度。var colors=new Array();var count=colors.push(\"red\",\"green\");//2 pop()方法var item=colors.pop();//item=\"green\" 队列方法shift()移除数组中的第一项并且返回该项，同时数组的长度减1。unshift()可以在数组的前端添加任意个项并返回新数组的长度。重排序方法reverse()反转数组项的顺序sort()会调用每个数据项的toString()方法，然后比较字符串来排序，即便是数组中的每一项都是数值。利用比较函数排序function compare(value1,value2)&#123; return value1-value2;&#125;var values=[0,1,5,10,15];values.sort();//0,1,10,15,5values.sort(compare);//15,10,5,1,0 操作方法concat()var colors=[\"red\",\"green\",\"blue\"];var colors2=colors.concat(\"yello\",[\"black\",\"brown\"]); slice()方法接受一个参数或者两个参数，接受一个参数，返回该位置到数组末尾的所有项。两个参数，返回起始位置和结束位置之间的项，但不包括结束项。splice()1.删除：指定两个参数，第一项的位置和要删除的项数。splice(0,2)2.插入：指定三个参数，起始位置，0，要插入的项splice(0,2,&quot;red&quot;,&quot;green&quot;)3.替换：指定三个参数，起始位置，要删除的项数，要插入的任意数量的项。splice(2,1,&quot;red&quot;,&quot;greem)位置方法indexOf()和lastIndexOf()接受两个参数：要查找的项和（可选的）表示查找起点位置索引。迭代方法每个方法接受2个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象。传入这些方法中的函数会接受三个参数：数据项的值，该项在数组中的位置和数组对象本身。1.every()每一项都返回true，返回true。2.filter()返回函数会返回true的项组成的数组。3.forEach()无返回值。4.map()对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。5.some()如果函数的任一项返回true，则返回true。every()var numbers=[1,2,3,4,5,4,3,2,1];var everyResult=numbers.every(function(item,index,array)&#123; return(item&gt;2);&#125;);//falsevar someResult=numbers.some(function(item,index,array)&#123; return(item&gt;2);&#125;);//truevar filterResult=numbers.filter(function(item,index,array)&#123; return(item&gt;2);&#125;);//3,4,5,4,3var mapResult=numbers.map(function(item,index,array)&#123; return item*2;&#125;);//2,4,6,8,10,8,6,4,2 归并方法两个归并数组的方法reduce()和reduceRight,这两个方法都会迭代数组的所有项，然后构建一个最终的返回值。这两个方法接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。其中函数接受四个参数：前一个值，当前值，项的索引，数组对象。var value=[1,2,3,4,5];var sum=value.reduce(function(pre,cur,index,array)&#123; return pre+cur;&#125;); Date类型创建日期对象var now=new Date(); RegExp类型 正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。其它参考 Function类型函数是对象，函数名是指针。function sum(num1,num2)&#123; return num1+num2;&#125;//函数声明var sum=function(num1,num2)&#123; return num1+num2;&#125;;//函数表达式 一个函数可能有多个名字function sum(num1,num2)&#123; return num1+num2;&#125;alert(sum(10,10);//20var anotherSum=sum;sum=null;alert(anotherSum(10,10));//20 没有重载作为值的函数将一个函数像传递参数一样传递给另一个函数。也可以作为一个函数的结果返回：function createComparisonFunction(propertyName)&#123; return function(object1,object2)&#123; var value1=object1[propertyName]; var value2=object2[propertyName]; if(value1&gt;value2)&#123; return -1; &#125;else if(value1&lt;value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;;&#125;var data=[&#123;name:\"Zachary\",age:28&#125;,&#123;name:\"Nicholas\",age:29&#125;];data.sort(createComparisonFunction(\"name\"));//data[0].name=Nicholasdata.sort(createComparisonFunction(\"age\"));//data[0].name=Zachary 函数属性和方法apply()和call()用途为在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply()接受两个参数：1.运行函数的作用域 2.参数数组（可以是Array实例或者是argument对象）call()传递给函数的参数必须逐个列举出来。事实上，它们真正强大的地方在于扩充函数赖以运行的作用域。window.color=\"red\";var o=&#123;color:\"blue\"&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor.call(this);//redsayColor.call(o);//bluesayColor.call(window);//red 基本包装类型为了便于操作基本类型值，ECMAScript还提供了三个特殊的引用类型Boolean，Number,String。引用类型和基本包装类型的主要区别就是对象的生存周期。var s1=\"some text\";s1.color=\"red\";alert(s1.color);//undefined String类型创建String对象var stringObject=new String(&quot;hello world&quot;);1.字符方法charAt(),charCodeAt()2.字符串操作方法concat()(实践中更多使用+)slice()和substring()根据start和end的值，截取子串，只有一个参数，默认end为结尾。substr()根据start和numbers的值，截取字串，只有一个参数，默认截取到字符串尾部。3.字符串位置方法indexOf()和lastIndexOf(),接受一个参数，表示起始搜索点。4.trim()方法删除前置和后缀的所有空格。5.字符串大小写转换方法toLowerCase()和toUpperCase()6.字符串模式匹配match()接受一个参数：要么是一个正则表达式，要么是一个RegExp对象。search()唯一的参数与match()相同，返回字符串中第一个匹配项的索引。replace()第一个参数可以是字符串或者是一个RegExp对象，第二个参数可以是一个字符串或者一个函数。split()基于指定的分隔符将一个字符串分割成多个字串，并将结果放在一个数组中。7.localCompare()方法这个方法比较两个字符串。var stringValue=\"yellow\";console.log(stringValue.localeCompare(\"brick\"));//1console.log(stringValue.localeCompare(\"yellow\"));//0console.log(stringValue.localeCompare(\"zoo\"));//-1","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://Persuingsdu.github.io/tags/JavaScript/"}]},{"title":"","slug":"随笔","date":"2018-01-26T15:53:23.000Z","updated":"2018-01-26T16:24:06.970Z","comments":true,"path":"2018/01/26/随笔/","link":"","permalink":"http://Persuingsdu.github.io/2018/01/26/随笔/","excerpt":"","text":"我住的城市从不下雪记忆却堆满冷的感觉思念的旺季霓虹扫过喧哗的街把快乐赶得好远落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞它陪我过夜Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞它陪我过夜Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑电话不接不要被人发现我整夜都关在房间狂欢的笑声听来像哀悼的音乐眼眶的泪 温热冻结望着电视里的无聊节目躺在沙发上变成没知觉的植物Merry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑Merry christmasMerry merry christmasLonely lonely christmas想祝福不知该给谁爱被我们打了死结Lonely lonely christmasMerry merry christmas写了卡片能寄给谁心碎的像街上的纸屑谁来陪我过这圣诞节","categories":[],"tags":[]},{"title":"Trie","slug":"Trie","date":"2017-12-24T07:12:34.000Z","updated":"2017-12-29T09:01:48.036Z","comments":true,"path":"2017/12/24/Trie/","link":"","permalink":"http://Persuingsdu.github.io/2017/12/24/Trie/","excerpt":"字典樹","text":"字典樹學習了一下字典樹的簡單實現方式Reference节点的定义#define Maxn 26struct trieNode &#123; int count;//以该节点为结尾的单词的个数 trieNode* next[Maxn]; trieNode(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;; 在字典中插入新的字符串void insert(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root;//根节点 //一个一个字符插入 for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a';//26个字母中的位置 if (p-&gt;next[index]==NULL) p-&gt;next[index] = new trieNode(0);//创建 p = p-&gt;next[index]; &#125; //以该字符为结尾的单词 p-&gt;count++;&#125; 刪除字典中的元素void del(trieNode* &amp;root, string str) &#123; int size = str.size(); int index; trieNode* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) return; p = p-&gt;next[index]; &#125; p-&gt;count--;&#125; 查找字典中是否存在某個字符串bool search(trieNode* root, string str) &#123; if (root == NULL) &#123; return false; &#125; int size = str.size(); trieNode *p = root; int index; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; // 无法转移到下一个字符 if (p-&gt;next[index] == NULL) &#123; return false; &#125;//if // 继续下一个字符 p = p-&gt;next[index]; &#125; return p-&gt;count &gt; 0;//是否有&#125; 遍曆輸出整個字典//利用递归程序查询整个字典void printDic(trieNode* root, vector&lt;vector&lt;char&gt;&gt; &amp;words, vector&lt;char&gt; &amp;word) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;count &gt; 0) &#123; words.push_back(word); &#125;//到了根且有值 for (int i = 0; i &lt; 26; ++i) &#123; if (root-&gt;next[i]) &#123;//26个循环 word.push_back('a' + i); printDic(root-&gt;next[i], words, word); word.pop_back();//回溯 &#125; &#125;&#125; LeetCode上的相關題目一.題目鏈接使用字典樹的解法#define Maxn 26struct node &#123; int count; int value; node* next[Maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; Maxn; i++) next[i] = NULL; &#125;&#125;;class MapSum &#123;public: /** Initialize your data structure here. */ MapSum() &#123; root = new node(0); &#125; void insert(string key, int val) &#123; int size = key.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = key[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++; p-&gt;value = val; &#125; node* help(string prefix) &#123; int size = prefix.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = prefix[i] - 'a'; if (p-&gt;next[index] == NULL) return NULL; p = p-&gt;next[index]; &#125; return p;//有该前缀 &#125; void search(node* root,int&amp; res) &#123; if (root == NULL)//空 return; if (root-&gt;count &gt; 0) res += root-&gt;value; for (int i = 0; i &lt; Maxn; i++) if (root-&gt;next[i]) search(root-&gt;next[i], res); &#125; int sum(string prefix) &#123; int res = 0; node* current = help(prefix); search(current,res); return res; &#125;private: node* root;&#125;; 二.題目鏈接#define maxn 26struct node &#123; int count; node* next[maxn]; node(int x) &#123; count = x; for (int i = 0; i &lt; maxn; i++) next[i] = NULL; &#125;&#125;;void insert(node* root,string str)&#123; int size = str.size(); int index; node* p = root; for (int i = 0; i &lt; size; i++) &#123; index = str[i] - 'a'; if (p-&gt;next[index] == NULL) p-&gt;next[index] = new node(0); p = p-&gt;next[index]; &#125; p-&gt;count++;&#125;int search(node* &amp;root, char c) &#123; if (root == NULL) &#123; return -1; &#125; int index = c - 'a'; if (root-&gt;next[index] == NULL) return -1;//不存在 root = root-&gt;next[index]; if (root-&gt;count &gt; 0) return 1;//存在 return 0;//可能存在&#125;string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) &#123; int size = dict.size(); node* root = new node(0); string res = \"\"; for (int i = 0; i &lt; size; i++) insert(root, dict[i]); int keysize = sentence.size(); for (int j = 0; j &lt; keysize; ) &#123; node* p = root; string element = \"\"; bool tag = false; while (j &lt; keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; int com = search(p, sentence[j]); if (com==-1) &#123; j++; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') &#123; element += sentence[j]; j++; &#125; res += element; res += \" \"; tag = true; break; &#125; if (com == 0) &#123; //do noing &#125; if (com == 1) &#123; res += element; res += \" \"; tag = true; while (j&lt;keysize &amp;&amp; sentence[j] != ' ') j++; break; &#125; j++; &#125; if (!tag) &#123; res += element; res += \" \"; &#125; j++; &#125; res.pop_back(); return res;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Persuingsdu.github.io/tags/数据结构/"}]}]}