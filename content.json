{"meta":{"title":"Persuing","subtitle":"study & life","description":null,"author":"Persuing","url":"http://Persuingsdu.github.io"},"pages":[{"title":"Project","date":"2017-12-14T06:26:52.648Z","updated":"2017-12-14T06:26:52.648Z","comments":true,"path":"project/index.html","permalink":"http://Persuingsdu.github.io/project/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-29T09:11:08.000Z","updated":"2017-12-29T09:18:42.270Z","comments":true,"path":"categories/index.html","permalink":"http://Persuingsdu.github.io/categories/index.html","excerpt":"","text":""},{"title":"document","date":"2018-01-20T06:05:27.000Z","updated":"2018-01-20T06:05:27.285Z","comments":true,"path":"document/index.html","permalink":"http://Persuingsdu.github.io/document/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-29T09:21:37.356Z","updated":"2017-12-29T09:21:37.356Z","comments":true,"path":"tags/index.html","permalink":"http://Persuingsdu.github.io/tags/index.html","excerpt":"","text":""},{"title":"test","date":"2018-04-11T10:35:00.000Z","updated":"2018-04-11T10:35:00.322Z","comments":true,"path":"test/index.html","permalink":"http://Persuingsdu.github.io/test/index.html","excerpt":"","text":""}],"posts":[{"title":"edu邮箱","slug":"edu邮箱","date":"2018-06-09T03:05:35.000Z","updated":"2018-06-11T01:27:41.071Z","comments":true,"path":"2018/06/09/edu邮箱/","link":"","permalink":"http://Persuingsdu.github.io/2018/06/09/edu邮箱/","excerpt":"","text":"用edu邮箱申请了JetBrains的学生授权申请OneDrive 1024GB 使用空间，速度很快","categories":[],"tags":[]},{"title":"单源最短路径","slug":"单源最短路径","date":"2018-03-31T04:25:05.000Z","updated":"2018-03-31T08:22:37.168Z","comments":true,"path":"2018/03/31/单源最短路径/","link":"","permalink":"http://Persuingsdu.github.io/2018/03/31/单源最短路径/","excerpt":"","text":"Bellman-Ford算法Bellman-Ford算法解决的是一般情况下的单源最短路径问题，在这里，边的权重可以为负值。算法返回一个布尔值，以表明是否存在一个从源结点可以到达的权重为负值的环路。如果存在这样一个环路，则算法将返回False，以表明不存在解决方案。反之，算法将给出最短路径和它们的权重。Bellman-Ford算法伪代码BELLMAN-FORD(G,w,s) INITIALIZE-SIGLE-SOURCE(G,s) for i=1 to|G.V|-1 //重复对每一边进行松弛操作 for each egde(u,v)∈G.E RELAX(u,v,w) for each edge(u,v)∈G.E //检查负权环 if v.d&gt;u.d+w(u,v) return FALSE return TRUE 松弛操作实际上是对相邻结点的访问，第n次松弛操作保证了所有深度为n的路径最短。由于图的最短路径最长不会经过超过V-1条边，所以可知该算法所得为最短路径。循环的提前跳出：若没有边进行松弛操作，则可以直接跳出。算法复杂度：O(VE)代码实现：//只放核心代码void relase(Edge E) &#123; if (dis[E.src]!=INT_MAX&amp;&amp;dis[E.dest] &gt; dis[E.src] + E.weight) &#123; dis[E.dest] = dis[E.src] + E.weight; parent[E.dest] = E.src; t = true; &#125;&#125;void initialize(Graph* graph, int s) &#123; dis = new int[graph-&gt;V]; parent = new int[graph-&gt;V]; for (int i = 0; i &lt; graph-&gt;V; i++) &#123; dis[i] = INT_MAX; parent[i] = -1; &#125; dis[s] = 0; parent[s] = s;&#125;//寻找路径void findPath(int s, int t) &#123; if (s == t) cout &lt;&lt; s &lt;&lt; \" \"; else if (t == -1) cout &lt;&lt; \"No path\"; else &#123; findPath(s, parent[t]); cout &lt;&lt; t &lt;&lt; \" \"; &#125;&#125;bool bellman_ford(Graph* graph, int s) &#123; initialize(graph, s); int E = graph-&gt;edges.size(); for (int i = 0; i &lt; graph-&gt;V - 1; i++) &#123; //n-1次对每条边松弛 t = false; for (int j = 0; j &lt; E; j++) &#123; relase(graph-&gt;edges[j]); &#125; if (!t) break;//未有松弛，及时终止 &#125; for (int j = 0; j &lt; E; j++) &#123; //判断是否有环 Edge E = graph-&gt;edges[j]; if (dis[E.dest] &gt; dis[E.src] + E.weight) return false; &#125; return true;&#125; Dijkstra算法Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。伪代码：DIJKSTRA(G,w,s) INITIALIZE-SINGAL-SOURCE(G,s) S=ф Q=G.V while Q≠ф u=EXTRACT-MIN(Q) S=S∪&#123;u&#125; for each vertex v∈G.Adj[u] RELAX(u,v,w) 代码实现：void dijkstra(Graph* graph, int s) &#123; init(graph, s); //初始化 Q.push(make_pair(0, s)); while (!Q.empty()) &#123; P x = Q.top(); Q.pop(); int u = x.second; if (done[u]) continue; done[u] = 1; //该点已经加入S list&lt;Edge&gt;::iterator iter; for (iter = graph-&gt;adj[u].begin(); iter != graph-&gt;adj[u].end(); iter++) &#123; int v = iter-&gt;dest; if (dis[v] &gt; dis[u] + iter-&gt;weight) &#123; dis[v] = dis[u] + iter-&gt;weight; Q.push(make_pair(dis[v], v)); &#125; &#125; &#125;&#125; 因为Dijkstra算法总是选择V-S中“最轻”或“最近”的结点来加入到集合S中，该算法使用的是贪心策略。这里的关键是证明这样的一个事实：该算法每次选择结点u来加入到集合S时，有u.d=min{w(p):s-p-u}。相关问题：1.Network Delay Time","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/tags/算法/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2018-03-27T10:14:14.000Z","updated":"2018-03-29T14:31:13.234Z","comments":true,"path":"2018/03/27/最小生成树/","link":"","permalink":"http://Persuingsdu.github.io/2018/03/27/最小生成树/","excerpt":"","text":"Kruscal算法伪代码MST-KRUSCAL(G,w)A=Φfor each vertex v∈G.V MAKE-SET(v)sort the edges of G.E into nondecreasing order by weight wfor each edge(u,v)∈G.E,taken in nondereasing order by weight if FIND-SET(u)≠FIND-SET(v) A=A∪&#123;(u,v)&#125; UNION(u,v)return A 代码实现：使用并查集#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct Edge &#123; int src, dest, weight; Edge(int src, int dest, int weight) &#123; this-&gt;src = src; this-&gt;dest = dest; this-&gt;weight = weight; &#125; Edge()&#123;&#125;&#125;;struct Graph &#123; int V; vector&lt;Edge&gt; edges;&#125;;Graph* creatGraph(int V) &#123; Graph* graph = new Graph; graph-&gt;V = V; return graph;&#125;struct subset &#123; int parent, rank;&#125;;int find(subset subsets[], int i) &#123; if (subsets[i].parent != i) subsets[i].parent = find(subsets, subsets[i].parent); return subsets[i].parent;&#125;//按rank合并void Union(subset subsets[], int x, int y) &#123; int xRoot = find(subsets, x); int yRoot = find(subsets, y); if (subsets[xRoot].rank &lt; subsets[yRoot].rank) subsets[xRoot].parent = yRoot; else if (subsets[xRoot].rank &gt; subsets[yRoot].rank) subsets[yRoot].parent = xRoot; else &#123; subsets[yRoot].parent = xRoot; subsets[xRoot].rank++; &#125;&#125;bool compare(Edge&amp; a, Edge&amp; b) &#123; return a.weight &lt; b.weight;&#125;void addEdge(Graph* graph, int src, int dest, int weight) &#123; graph-&gt;edges.push_back(Edge(src, dest, weight));&#125;void Kruscal(Graph* graph) &#123; int V = graph-&gt;V; Edge* res = new Edge[V];//最小生成树的边 int e = 0;//边 int i = 0; sort(graph-&gt;edges.begin(), graph-&gt;edges.end(), compare);//按照权值进行排序 subset* subsets = new subset[V]; for (int v = 0; v &lt; V; v++) &#123; subsets[v].parent = v; subsets[v].rank = 0; &#125; while (e &lt; V - 1) &#123; Edge next_Edge = graph-&gt;edges[i++]; int x = find(subsets, next_Edge.src); int y = find(subsets, next_Edge.dest); if (x != y) &#123; res[e++] = next_Edge; Union(subsets, x, y); &#125; &#125; cout &lt;&lt; \"Following are the edges in the constructed MST\\n\"; for (i = 0; i &lt; e; i++) cout &lt;&lt; res[i].src &lt;&lt; \"----\" &lt;&lt; res[i].dest &lt;&lt; \" == \" &lt;&lt; res[i].weight &lt;&lt; endl;&#125;int main() &#123; /* 10 0--------1 | \\ | 6| 5\\ |15 | \\ | 2--------3 4 */ Graph* graph = creatGraph(4); addEdge(graph, 0, 1, 10); addEdge(graph, 0, 2, 6); addEdge(graph, 0, 3, 5); addEdge(graph, 1, 3, 15); addEdge(graph, 2, 3, 4); Kruscal(graph);&#125; Prim算法伪代码MST-PRIM(G,w,r)1 for each u∈G.V2 u:key=∞3 u:π=NIL4 r:key=05 Q=G.V6 while Q≠Φ7 u=EXTRACT-MIN(Q)8 for each vertex v∈G.Adj[u]9 if v∈Q and w(u,v) &lt; v.key10 v.π=u11 v.key=w(u,v) Prim算法的运行时间取决于最小优先队列Q的实现方式。若将Q实现为一个二叉最小优先队列，那么建立最小堆的时间为O(V)。while循环中的语句一共要执行|V|次，每个EXTRACT-MIN的操作时间为O(lgV)，则该操作的总时间为O(VlgV)。所有邻接链表的长度为2|E|，8-11行总执行次数为O(E)，删除操作需要O(lgV)，所以Prim算法总时间代价为O(VlgV+ElgV)=O(ElgV)。从渐进意义上来说，它与Kruscal算法的运行时间相同。 并查集的应用1. Redundant Connection使用并查集判断形成环的最后一条边2. Redundant Connection II3. Friend CirclesDFS求连通分量的个数或者使用并查集。4. Number of Islands5. Longest Consecutive Sequence使用并查集，遍历其中元素，设当前数值为M，判断M+1或者M-1是否在前面出现过，若出现过，则进行合并。算法导论答案CLRS SolutionsSolutions","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/tags/算法/"}]},{"title":"基本的图算法","slug":"基本的图算法","date":"2018-03-22T06:27:01.000Z","updated":"2018-03-26T08:11:33.888Z","comments":true,"path":"2018/03/22/基本的图算法/","link":"","permalink":"http://Persuingsdu.github.io/2018/03/22/基本的图算法/","excerpt":"","text":"广度优先搜索算法伪代码：BFS(G)for each vertex u ∈G.V-&#123;s&#125; u.color=WHITE u.d= ∞ u.π=NILs.color=GRAYs.d=0s.π=NILQ≠фENQUEUE(G,s)while Q≠фu=DEQUEUE(Q)for each v∈G.Adj[u] if(v.color==WHITE) v.color=GRAY v.d=u.d+1 v.π=u ENQUEUE(Q,v)u.color=BLACK 时间复杂度为O(V+E)，广度优先搜索的运行时间是邻接链表大小的一个线性函数。下面的伪代码输出从源结点s到结点v的一条最短路径上的所有结点：PRINT-PATH(G,s,v)if v==s print selse if v.π==NIL print \"no path from\"s\"to\"v\"exits\"else PRINT-PATH(G,s,v.π) print v 深度优先搜索算法伪代码：DFS(G)for each vertex u ∈ G.V u.color=WHITE u.π=NILtime=0for each vertex u ∈ G.V if u.color==WHITE DFS-VISIT(G,u)DFS-VISIT(G,u)time=time+1 //white vertex u has just been discoveredu.d=timeu.color=GRAYfor each vertex v ∈ G:Adj[u] if v.color==WHITE v.π=u DFS-VISIT(G,v)u.color=BLACK //blacken u;it is finishedtime=time+1u.f=time 1.括号定理2.白色路径定理：在有向或无向图G=(V,E)的深度优先森林中，结点v是结点u的后代当且仅当在发现结点u的时间u.d，存在一条从结点u到结点v的全部由白色结点所构成的路径。边的分类：1.树边 2.后向边(back) 3.前向边(forward) 4.横向边(cross)当第一次探索边(u,v)时：1.结点v为白色表明该边是一条树边。2.结点v为灰色表明该边是一条后向边。3.结点v为黑色表明该边是一条前向边或横向边。 拓扑排序拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面TOPOLOGICAL-SORT(G)call DFS(G) to compute finishing time v.f for each vertex vas each vertex is finished,insert it onto the front of a linked listreturn the linked list of vertices 引理：一个有向图G=(V,E)是无环的，当且仅当对其进行的深度优先搜索不产生后向边。定理：拓扑排序算法生成的是有向无环图的拓扑排序。证明：在有向无环图G=(V,E)上运行DFS来计算结点的完成时间。只需要证明，对于任意一对不同的结点u,v∈V,如果图G包含一条从结点u到结点v的边，则v.f &lt; u.f。考虑算法DFS(G)所探索的边(u,v)。当这条边被探索时，结点v不可能是灰色。若为灰色，则结点v是结点u的祖先，所以(u,v)是一条后向边，与之前的引理矛盾。所以结点v为白色或者黑色。若为白色，v是u的后代，则v.f &lt; u.f若为黑色，则对其全部的处理已经完成，v.f已经被设置。还需对u进行探索，最终一定有v.f &lt; u.f。 拓扑排序的另外一种实现方式：Another way to perform topological sorting on a directed acyclic graph G = (V, E) is to repeatedly find a vertex of in-degree 0, output it, and remove it and all of its outgoing edges from the graph. Explain how to implement this idea so that it runs in time O(V + E). What happens to this algorithm if G has cycles?General idea:Run BFS or DFS to calculate in-degree of each vertex. O(V+E)For each vertex that in-degree is 0, print it and update the in-degree of its neighbors accordingly, then there will be new in-degree=0 vertexes. Repeat this step until all vertex got printed. The entire process is also O(V+E)If G has cycles, then after several iterations there will be no in-degree=0 vertexes. But original topological sorting algorithm is also only applied to directed acyclic graph.判断一个有向图是否存在环，只要判断是否有backedge。题目Course Schedulebool res=true;void dfs_visited(vector&lt;int&gt;&amp; visited, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites, int s,vector&lt;list&lt;int&gt;&gt;&amp; adj)&#123; visited[s] = 0; list&lt;int&gt;::iterator i; for (i = adj[s].begin(); i != adj[s].end(); i++) &#123; if (visited[*i] == -1) dfs_visited(visited, prerequisites, *i, adj); if (visited[*i] == 0) &#123; res = false; return; &#125; &#125; visited[s] = 1;&#125;bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;int&gt; visited(numCourses, -1); vector&lt;list&lt;int&gt;&gt; adj(numCourses); for (int i = 0; i &lt; prerequisites.size(); i++) &#123; int u = prerequisites[i].second; int v = prerequisites[i].first; adj[u].push_back(v); &#125; for (int j = 0; j &lt; numCourses; j++) dfs_visited(visited, prerequisites, j, adj); return res;&#125; 强连通分量创建GT的时间为O(V+E)下面的线性时间算法使用两次深度优先搜索计算有向图G=(V,E)的强连通分量。这两次深度优先搜索一次运行在G上，一次运行在转置图GT上。call DFS(G) to compute finishing times u.f for each vertex ucompute GTcall DFS(GT),but in the main loop of DFS,consider the vertices in order of decreasing u.f(as computed in line 1)output the vertices of each tree in the depth-first forest formed in line 3 as a separated connected component 分量图的关键性质：分量图是一个有向无环图。定义：d(U)=min(u∈U){u.d},f(U)=max(u∈U){u.f}即d(U)和f(U)分别是结点集合U中所有结点里最早发现的时间和最晚的结束时间。 引理：设C和C’为有向图G=(V,E)的两个不同的强连通分量。假如存在一条边(u,v)∈E，这里u∈C，v∈C’。则：f(C)&gt;f(C’)证明:1.第一种情况：若d(C) &lt; d(C')，设x为C中最早被发现的结点。则在x.d时，所有C和C'中的结点都是白色。在该时刻，图G中包含一条从结点x到C中每个结点的仅有包含白色结点的路径。因为(u,v)∈E，对于任意结点w∈C'，在时刻x.d时，G中存在一条只包含白色结点的路径：x~u-v~w，所以根据白色路径定理，连通分量C'中的所有结点都成为深度优先搜索树中x的的后代，则根据22.8，结点x的完成时间比其它所有的后代都晚，则x.f=f(C)&gt;f(C')。2.第二种情况：如果d(C) &gt; d(C')，设y为C'中最早被发现的结点。则在y.d时，所有C'中的结点都是白色。且图C'包含一条从结点y到C'中每个结点的仅包含白色结点的路径。根据白色路径定理，C'中的所有结点都将成为深度优先搜索树中y的后代，有f(C')=y.f。在时刻y.d，所有C中的结点都为白色，有(u,v)，所以不可能存在从C'到C的路径，所以C中的结点不可能从y到达。在时刻y.f，所有C中的结点都为白色。因此对任意结点w∈C来说有w.f&gt;y.f，所以f(C)&gt;f(C')。 推论：设C和C’为有向图G=(V,E)两个不同的强连通分量，加入存在一条边(u,v)属于ET，这里u∈C，v∈C’则有f(C)&lt; f(C’)第二次深度优先搜索运行在GT上，我们从完成时间最晚的强连通分量C开始。搜索算法从C中的某个结点x开始，访问C中的所有结点。根据该推论，GT中不可能包含从C到其它任何强连通分量的边。定理：算法STRONGLY-CONNECTED-COMPONENTS能够正确地计算出有向图G的强连通分量利用归纳法证明。给定有向图G=(V,E)，如果对所有结点对u，v∈V，我们都有u~v或者v~u，则G是半连通的。给出一个有效的算法来判断图G是否是半连通的。先求出所有的强连通分量，然后利用拓扑排序，若存在链条式的结构则说明该图是半连通的。3/23更新 衔接点、桥和双连通分量Biconnected component参考一参考二求Articulation Points算法伪代码:GetArticulationPoints(i, d) visited[i] = true dis[i] = d low[i] = d //定义u.low=MIN(u.d,w.d:(v,w)是结点u的某个后代v的一个backedge) childCount = 0 isArticulation = false for each ni in adj[i] if not visited[ni]//没有访问过 parent[ni] = i GetArticulationPoints(ni, d + 1) childCount = childCount + 1 if low[ni] &gt;= dis[i] isArticulation = true low[i] = Min(low[i], low[ni]) else if ni &lt;&gt; parent[i] //访问过 low[i] = Min(low[i], dis[ni]) //较小者 ni为i能到达的结点，也就是backedge if (parent[i] &lt;&gt; null and isArticulation) or (parent[i] == null and childCount &gt; 1) Output i as articulation point Reason：Biconnected graph: A graph with no articulation point called biconnected. In other words, a graph is biconnected if and only if any vertex is deleted, the graph remains connected.判断一个图是否是Biconnected只需要判断图中是否存在articulation point Biconnected component: A biconnected component of a graph is a maximal biconnected subgraph- a biconnected subgraph that is not properly contained in a larger biconnected subgraph.参考一参考二","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://Persuingsdu.github.io/tags/算法/"}]}]}